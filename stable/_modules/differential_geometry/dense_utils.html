
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>differential_geometry.dense_utils &#8212; PyMetric  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/differential_geometry/dense_utils';</script>
    <link rel="icon" href="../../_static/pm_favicon.svg"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">PyMetric  documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../auto_quickstart/index.html">
    PyMetric Quickstart Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api_base.html">
    API
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../auto_quickstart/index.html">
    PyMetric Quickstart Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api_base.html">
    API
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">differential_geometry.dense_utils</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for differential_geometry.dense_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Utility functions for performing basic tensor manipulations including index raising and lowering.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">string</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>


<span class="c1"># ------------------------------------------ #</span>
<span class="c1"># General Utilities                          #</span>
<span class="c1"># ------------------------------------------ #</span>
<span class="c1"># These are low-level tensor field utilities with little to</span>
<span class="c1"># no protection in place to ensure correct behavior of the</span>
<span class="c1"># inputs.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_dense_contract_index_with_metric</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contract a tensor index with a metric (or inverse metric) using :py:func:`numpy.einsum`.</span>

<span class="sd">    This operation performs the index contraction:</span>

<span class="sd">    .. math::</span>

<span class="sd">        T^{\ldots\mu\ldots} = g^{\mu\nu} T^{\ldots}_{\ldots\nu\ldots}</span>

<span class="sd">    or</span>

<span class="sd">    .. math::</span>

<span class="sd">        T_{\ldots\mu\ldots} = g_{\mu\nu} T_{\ldots}^{\ldots\nu\ldots}</span>

<span class="sd">    depending on context and whether the provided metric is the metric tensor or its inverse.</span>
<span class="sd">    The contraction is performed over a single tensor index (specified by `index`), replacing it</span>
<span class="sd">    with the contracted result.</span>

<span class="sd">    This function assumes that the tensor rank occupies the last `rank` axes of `tensor_field`,</span>
<span class="sd">    and that the metric has shape ``(..., N, N)``, where `N` matches the size of the contracted index.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function performs a full batched matrix multiplication via :py:func:`numpy.einsum`.</span>
<span class="sd">        If your metric is diagonal or otherwise structured (e.g., orthogonal or identity),</span>
<span class="sd">        specialized routines may offer better performance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        A dense tensor field with shape ``(..., i_1, ..., i_rank)``, where the last `rank` axes</span>
<span class="sd">        represent tensor indices.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            Dense tensors are technically ``(..., Ndim, ..., Ndim)``; however, :func:`dense_contract_index_with_metric`</span>
<span class="sd">            has slightly looser behavior allowing for any array shape ``(*grid_shape,*element_shape)`` so long as</span>
<span class="sd">            ``element_shape[index]`` matches the shape of the `metric_field`.</span>

<span class="sd">    metric_field : numpy.ndarray</span>
<span class="sd">        The metric (or inverse metric) tensor used for contraction.</span>
<span class="sd">        Must have shape ``(..., N, N)``, broadcastable with the leading dimensions of `tensor_field`.</span>
<span class="sd">    index : int</span>
<span class="sd">        The index among the trailing `rank` tensor indices to contract with the metric.</span>
<span class="sd">        Must satisfy ``0 &lt;= index &lt; rank``.</span>
<span class="sd">    rank : int</span>
<span class="sd">        The number of trailing axes in `tensor_field` that represent tensor indices.</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional output array to store the result. If provided, must have the same shape as the expected</span>
<span class="sd">        output: identical to `tensor_field` but with the contracted index replaced by the new one.</span>

<span class="sd">        This allows for memory reuse and avoids allocating a new array, which can improve performance</span>
<span class="sd">        in tight loops or high-throughput workflows. If not provided, a new array is returned.</span>

<span class="sd">        The dtype and shape must be compatible with the result of the einsum contraction.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments passed to :py:func:`numpy.einsum`.</span>
<span class="sd">        For example, use `optimize=True` to enable internal optimization of the contraction path.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The resulting tensor field after contraction. The output shape is broadcasted over</span>
<span class="sd">        the leading dimensions of both `tensor_field` and `metric_field`, and the contracted</span>
<span class="sd">        index is replaced by the output index from the metric.</span>

<span class="sd">        Specifically, if `tensor_field` has shape ``(..., I₁, ..., I_rank)`` and the contraction</span>
<span class="sd">        is performed over index `i` with size `N`, and `metric_field` has shape ``(..., N, N)``,</span>
<span class="sd">        then the resulting array has shape:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            broadcast(... from both inputs, ..., I₁, ..., I_{i-1}, N, I_{i+1}, ..., I_rank)</span>

<span class="sd">        where the contracted index axis (of size `N`) is replaced by the output metric index.</span>

<span class="sd">        This shape supports broadcasting of mismatched dimensions, such as contraction of a</span>
<span class="sd">        field with shape ``(A, 1, C)`` and a metric of shape ``(A, B, C, C)`` resulting in output</span>
<span class="sd">        shape ``(A, B, C)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Contract a random tensor with an identity metric:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(10, 10, 3)  # scalar field with a vector index (rank-1)</span>
<span class="sd">    &gt;&gt;&gt; ginv = np.eye(3)[np.newaxis,np.newaxis,:,:] * np.ones((10,10,1,1))              # inverse metric (identity in this case)</span>
<span class="sd">    &gt;&gt;&gt; _dense_contract_index_with_metric(T, ginv, index=0, rank=1).shape</span>
<span class="sd">    (10, 10, 3)</span>

<span class="sd">    :func:`dense_contract_index_with_metric` can also broadcast for inconsistent</span>
<span class="sd">    tensor and metric shapes. In this case, we&#39;ll contract a tensor of shape ``(10, 1, 3)``</span>
<span class="sd">    with a metric ``(10, 10, 3, 3)``.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(10, 1, 3)  # scalar field with a vector index (rank-1)</span>
<span class="sd">    &gt;&gt;&gt; ginv = np.eye(3)[np.newaxis,np.newaxis,:,:] * np.ones((10,10,3,3))              # inverse metric (identity in this case)</span>
<span class="sd">    &gt;&gt;&gt; _dense_contract_index_with_metric(T, ginv, index=0, rank=1).shape</span>
<span class="sd">    (10, 10, 3)</span>

<span class="sd">    Arrays can be implicitly broadcastable as well:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(10, 3)  # Inconsistent field shape</span>
<span class="sd">    &gt;&gt;&gt; ginv = np.eye(3)[np.newaxis,np.newaxis,:,:] * np.ones((10,10,3,3))              # inverse metric (identity in this case)</span>
<span class="sd">    &gt;&gt;&gt; _dense_contract_index_with_metric(T, ginv, index=0, rank=1).shape</span>
<span class="sd">    (10, 10, 3)</span>

<span class="sd">    But direct inconsistency will lead to an error:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(12, 3)  # VERY Inconsistent field shape</span>
<span class="sd">    &gt;&gt;&gt; ginv = np.eye(3)[np.newaxis,np.newaxis,:,:] * np.ones((10,10,3,3))              # inverse metric (identity in this case)</span>
<span class="sd">    &gt;&gt;&gt; _dense_contract_index_with_metric(T, ginv, index=0, rank=1).shape # doctest: +SKIP</span>
<span class="sd">    ValueError: operands could not be broadcast together with remapped shapes [original-&gt;remapped]: (12,3)-&gt;(12,newaxis,3) (10,10,3,3)-&gt;(10,10,3,3)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.einsum : Generalized Einstein summation in NumPy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract any relevant metadata from the tensor field to</span>
    <span class="c1"># ensure that this operation can be performed effectively.</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span>

    <span class="c1"># Construct the index strings. This is faster than moving around</span>
    <span class="c1"># axes of the resulting array. We&#39;ll create 3 sets (field, tensor, and metric).</span>
    <span class="n">__letters__</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span>
    <span class="n">tensor_indices</span> <span class="o">=</span> <span class="n">__letters__</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:</span> <span class="n">ndim</span><span class="p">]</span>

    <span class="c1"># Fix the tensor index to have a matching summation.</span>
    <span class="n">tensor_indices</span> <span class="o">=</span> <span class="n">tensor_indices</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;I&quot;</span> <span class="o">+</span> <span class="n">tensor_indices</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
    <span class="n">output_indices</span> <span class="o">=</span> <span class="n">tensor_indices</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;J&quot;</span> <span class="o">+</span> <span class="n">tensor_indices</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>

    <span class="c1"># Write the expression string.</span>
    <span class="n">__expression__</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;...</span><span class="si">{</span><span class="n">tensor_indices</span><span class="si">}</span><span class="s2">,...IJ-&gt;...</span><span class="si">{</span><span class="n">output_indices</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Perform the computation.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">__expression__</span><span class="p">,</span> <span class="n">tensor_field</span><span class="p">,</span> <span class="n">metric_field</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dense_contract_index_with_diagonal_metric</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contract a tensor index with a diagonal metric (or inverse metric) using scalar multiplication.</span>

<span class="sd">    This operation performs the contraction:</span>

<span class="sd">    .. math::</span>

<span class="sd">        T^{\ldots\mu\ldots} = g^{\mu\mu} T^{\ldots}_{\ldots\mu\ldots}</span>

<span class="sd">    or</span>

<span class="sd">    .. math::</span>

<span class="sd">        T_{\ldots\mu\ldots} = g_{\mu\mu} T_{\ldots}^{\ldots\mu\ldots}</span>

<span class="sd">    depending on context and whether the provided metric is the metric tensor or its inverse.</span>
<span class="sd">    The contraction is performed by directly scaling the tensor along a single index axis using</span>
<span class="sd">    the diagonal entries of the metric.</span>

<span class="sd">    This function assumes that the metric is diagonal and only requires the diagonal entries</span>
<span class="sd">    as a field with shape ``(..., N)``, where `N` is the size of the tensor index being contracted.</span>
<span class="sd">    The contraction is carried out by broadcasting the diagonal metric values and multiplying them</span>
<span class="sd">    along the appropriate axis.</span>

<span class="sd">    Unlike full metric contractions, no summation is performed; this function is significantly more</span>
<span class="sd">    efficient and numerically stable when the metric is known to be diagonal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        A dense tensor field with shape ``(..., i_1, ..., i_rank)``, where the last `rank` axes</span>
<span class="sd">        represent tensor indices.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            This function expects `tensor_field` to have shape ``(*grid_shape, *tensor_shape)``, and</span>
<span class="sd">            `tensor_shape[index]` must match the size of the final axis in `metric_field`.</span>

<span class="sd">    metric_field : numpy.ndarray</span>
<span class="sd">        A diagonal metric (or inverse metric) represented as an array of shape ``(..., N)``,</span>
<span class="sd">        where the leading dimensions must be broadcast-compatible with the grid dimensions</span>
<span class="sd">        of `tensor_field`.</span>

<span class="sd">    index : int</span>
<span class="sd">        The index among the trailing `rank` tensor indices to contract with the metric.</span>
<span class="sd">        Must satisfy ``0 &lt;= index &lt; rank``.</span>

<span class="sd">    rank : int</span>
<span class="sd">        The number of trailing axes in `tensor_field` that represent tensor indices.</span>

<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional array into which the result will be stored. If provided, must have the same</span>
<span class="sd">        shape as `tensor_field`. If not provided, a new array is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The resulting tensor field after contraction. The shape is identical to `tensor_field`,</span>
<span class="sd">        with the contracted index scaled (not removed or reduced).</span>

<span class="sd">        Broadcasting allows, for example, a contraction of shape ``(A, 1, C)`` against a metric</span>
<span class="sd">        of shape ``(A, C)`` to produce a result of shape ``(A, 1, C)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Contract a vector field with a diagonal inverse metric tensor:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(10, 10, 3)  # Inconsistent field shape</span>
<span class="sd">    &gt;&gt;&gt; ginv = np.ones((10,10,3))              # inverse metric (identity in this case)</span>
<span class="sd">    &gt;&gt;&gt; dense_contract_index_with_diagonal_metric(T, ginv, index=0, rank=1).shape</span>
<span class="sd">    (10, 10, 3)</span>

<span class="sd">    With broadcasting:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(10, 3)  # Inconsistent field shape</span>
<span class="sd">    &gt;&gt;&gt; ginv = np.ones((10,10,3))              # inverse metric (identity in this case)</span>
<span class="sd">    &gt;&gt;&gt; _dense_contract_index_with_diagonal_metric(T, ginv, index=0, rank=1).shape</span>
<span class="sd">    (10, 10, 3)</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dense_contract_index_with_metric : Full contraction using general metric tensors.</span>
<span class="sd">    numpy.multiply : Element-wise multiplication in NumPy.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Technically, neither ``index`` or ``rank`` is actually used in this function. This function</span>
<span class="sd">    is just a wrapper on :func:`numpy.multiply`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">field_ndim</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">field_ndim</span> <span class="o">+</span> <span class="n">index</span>  <span class="c1"># actual axis in tensor_field</span>

    <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">field_ndim</span><span class="p">])</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rank</span>
    <span class="n">broadcast_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">metric_broadcast</span> <span class="o">=</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tensor_field</span> <span class="o">*</span> <span class="n">metric_broadcast</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">tensor_field</span><span class="p">,</span> <span class="n">metric_broadcast</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dense_compute_tensor_trace</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform a trace over two tensor indices of a rank-`r` tensor field.</span>

<span class="sd">    This function contracts two specified tensor axes in the field by summing over</span>
<span class="sd">    matching values, effectively reducing the rank of the tensor by 2. The indices</span>
<span class="sd">    must refer to distinct axes within the trailing `rank` tensor slots.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        A dense tensor field with shape ``(..., i₁, ..., i_r)``, where the last `rank` axes</span>
<span class="sd">        represent the tensor indices and the leading axes represent the field (grid) dimensions.</span>
<span class="sd">    indices : tuple of int</span>
<span class="sd">        A pair of indices (i, j) among the trailing `rank` dimensions to contract.</span>
<span class="sd">        Must satisfy ``0 &lt;= i, j &lt; rank`` and ``i != j``.</span>
<span class="sd">    rank : int</span>
<span class="sd">        The number of trailing tensor dimensions of `tensor_field`.</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional output array to store the result. If provided, must have the same shape</span>
<span class="sd">        as the expected output: the shape of `tensor_field` with the specified `indices`</span>
<span class="sd">        removed (i.e., `rank - 2` fewer trailing axes).</span>

<span class="sd">        Enables memory reuse and avoids additional allocations, which is beneficial in</span>
<span class="sd">        high-performance or memory-sensitive workflows. Must be broadcast-compatible with</span>
<span class="sd">        the output of `np.trace`.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments passed to :py:func:`numpy.trace`, such as `dtype` or `out`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Tensor field with the specified pair of tensor indices traced (contracted).</span>
<span class="sd">        The result has the same field dimensions and `rank - 2` tensor dimensions.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If indices are invalid or refer to the same axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.zeros((4, 4, 3, 3))  # 2nd-rank tensor field over 4x4 grid</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(T[0, 0], 1)</span>
<span class="sd">    &gt;&gt;&gt; _dense_compute_tensor_trace(T, indices=(0, 1), rank=2)[0, 0]</span>
<span class="sd">    3.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the number of field dimensions.</span>
    <span class="n">field_ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span>

    <span class="c1"># Now perform and return the trace.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span>
        <span class="n">tensor_field</span><span class="p">,</span>
        <span class="n">axis1</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">field_ndim</span><span class="p">,</span>
        <span class="n">axis2</span><span class="o">=</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">field_ndim</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="infer_metric_type">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.infer_metric_type.html#differential_geometry.dense_utils.infer_metric_type">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">infer_metric_type</span><span class="p">(</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">field_shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;diagonal&quot;</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infer whether the given metric (or inverse metric) tensor is diagonal or full.</span>

<span class="sd">    The function compares the shape of the metric tensor against the field&#39;s spatial shape.</span>
<span class="sd">    A metric is considered:</span>

<span class="sd">    - &quot;diagonal&quot; if it has shape broadcastable to ``field_shape + (N,)``</span>
<span class="sd">    - &quot;full&quot;     if it has shape broadcastable to ``field_shape + (N, N)``</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metric_field : numpy.ndarray</span>
<span class="sd">        Metric or inverse metric tensor. Shape must be either (..., N) for diagonal,</span>
<span class="sd">        or (..., N, N) for full metrics.</span>

<span class="sd">    field_shape : tuple of int</span>
<span class="sd">        Shape of the spatial (non-tensor) portion of the tensor field the metric will apply to.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    {&quot;diagonal&quot;, &quot;full&quot;}</span>
<span class="sd">        A string indicating the type of metric tensor.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the metric shape is not compatible with the field shape, or cannot be interpreted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mshape</span> <span class="o">=</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ndim_field</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">ndim_field</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Possibly diagonal: check broadcastability</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">field_shape</span><span class="p">,</span> <span class="n">mshape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Diagonal metric shape </span><span class="si">{</span><span class="n">mshape</span><span class="si">}</span><span class="s2"> is not broadcast-compatible with field shape </span><span class="si">{</span><span class="n">field_shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;diagonal&quot;</span>

    <span class="k">elif</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">ndim_field</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mshape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mshape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected square trailing dimensions for full metric, but got </span><span class="si">{</span><span class="n">mshape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">field_shape</span><span class="p">,</span> <span class="n">mshape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Full metric shape </span><span class="si">{</span><span class="n">mshape</span><span class="si">}</span><span class="s2"> is not broadcast-compatible with field shape </span><span class="si">{</span><span class="n">field_shape</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;full&quot;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Metric shape </span><span class="si">{</span><span class="n">mshape</span><span class="si">}</span><span class="s2"> is incompatible with field shape </span><span class="si">{</span><span class="n">field_shape</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="s2">&quot;Expected shape ending in (N,) for diagonal or (N, N) for full metric.&quot;</span>
        <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_dense_adjust_tensor_signature</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">tensor_signature</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust multiple tensor indices (simultaneously) using einsum with appropriate metric or inverse metric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        The tensor field with shape ``(..., I₁, ..., I_r)``, where the last `r` axes represent tensor indices</span>
<span class="sd">        and the leading axes represent spatial/grid dimensions.</span>
<span class="sd">    indices : List[int]</span>
<span class="sd">        Indices among the last `rank` axes to be modified.</span>
<span class="sd">    tensor_signature : numpy.ndarray</span>
<span class="sd">        Array of integers, +1 for contravariant, -1 for covariant index.</span>
<span class="sd">    metric_field : numpy.ndarray, optional</span>
<span class="sd">        Metric tensor of shape (..., N, N).</span>
<span class="sd">    inverse_metric_field : numpy.ndarray, optional</span>
<span class="sd">        Inverse metric tensor of shape (..., N, N).</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional array to store the result of the einsum contraction. Must have the same</span>
<span class="sd">        shape as the expected output. If provided, will be used in-place by `np.einsum`.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : numpy.ndarray</span>
<span class="sd">        Tensor field with modified indices.</span>
<span class="sd">    new_signature : numpy.ndarray</span>
<span class="sd">        Tensor signature after modifications. Same shape as `tensor_signature`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the rank and dimensionality</span>
    <span class="c1"># of the tensor field.</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">size</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span>

    <span class="c1"># Start building the indices arrays from</span>
    <span class="c1"># strings. This is the core of the function and is</span>
    <span class="c1"># the cumulatively passed to numpy.einsum.</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span>
    <span class="n">caps</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span>

    <span class="c1"># Field (non-tensor) indices</span>
    <span class="n">tensor_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">letters</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:</span> <span class="n">ndim</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># We need to manipulate later -&gt; list.</span>
    <span class="n">cap_tensor_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">caps</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:</span> <span class="n">ndim</span><span class="p">]</span>
    <span class="p">)</span>  <span class="c1"># We need to manipulate later -&gt; list.</span>
    <span class="n">output_indices</span> <span class="o">=</span> <span class="n">tensor_indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Start building the flags that are going to contain</span>
    <span class="c1"># the operation information for this function. We&#39;re</span>
    <span class="c1"># going to utilize these to store the strings and optimize</span>
    <span class="c1"># checks.</span>
    <span class="n">__operands__</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor_field</span><span class="p">]</span>
    <span class="n">__lhs__</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tensor_indices</span><span class="p">),</span>
    <span class="p">]</span>
    <span class="n">__rhs__</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">output_indices</span>

    <span class="c1"># Copy and update the signature</span>
    <span class="n">new_signature</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Pass through each of the tensor&#39;s indices and</span>
    <span class="c1"># check if we need to alter it based on the passed through</span>
    <span class="c1"># indices. We always alter to the opposite variance.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">variance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_signature</span><span class="p">):</span>
        <span class="c1"># Check if we are actually making any modifications to</span>
        <span class="c1"># this tensor.</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># A modification is required - check that the</span>
        <span class="c1"># metric / inverse metric was provided.</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">metric_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Lowering a contravariant index requires the metric tensor.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">variance</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">inverse_metric_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Raising a covariant index requires the inverse metric tensor.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Add the correct metric to the __operands__ list.</span>
        <span class="n">__operands__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">metric_field</span> <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">inverse_metric_field</span><span class="p">)</span>

        <span class="c1"># Every operation looks like abcd...,aA,bB,..., ABcDe... so we pull out</span>
        <span class="c1"># the capitalized and lowercase version of the current index and</span>
        <span class="c1"># add a metric element with that signature.</span>
        <span class="n">__lhs__</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;...</span><span class="si">{</span><span class="n">tensor_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="si">}{</span><span class="n">cap_tensor_indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">__rhs__</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">__rhs__</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">new_signature</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Flip variance</span>

    <span class="c1"># Now we construct the full einsum expression. We keep in</span>
    <span class="c1"># mind that EVERYTHING gets the same set of field indices.</span>
    <span class="n">__rhs__</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">__rhs__</span><span class="p">)</span>
    <span class="n">__lhs__</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">__lhs__</span><span class="p">)</span>
    <span class="n">einsum_expr</span> <span class="o">=</span> <span class="n">__lhs__</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="n">__rhs__</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">einsum_expr</span><span class="p">,</span> <span class="o">*</span><span class="n">__operands__</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span> <span class="n">new_signature</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dense_adjust_tensor_signature_diagonal_metric</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">tensor_signature</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust specified tensor indices by scaling with diagonal metric components (or inverse).</span>

<span class="sd">    This function applies index raising or lowering on the specified tensor indices</span>
<span class="sd">    assuming a diagonal metric. It avoids full matrix multiplication and instead uses</span>
<span class="sd">    elementwise multiplication or division, with optional in-place behavior.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        The input tensor field to be transformed. Must have shape ``(..., I₁, ..., I_r)`` with</span>
<span class="sd">        `r` trailing tensor index axes.</span>

<span class="sd">        The array should have shape ``(F₁, ..., F_m, I₁, ..., I_r)``, where:</span>

<span class="sd">        - ``(F₁, ..., F_m)`` are the field (spatial or grid) dimensions,</span>
<span class="sd">        - ``(I₁, ..., I_r)`` are the tensor index dimensions, and</span>
<span class="sd">        - `r` is the tensor rank (i.e., the number of tensor indices, inferred from `tensor_signature`).</span>
<span class="sd">    indices : List[int]</span>
<span class="sd">        The indices among the trailing `rank` axes to modify.</span>
<span class="sd">    tensor_signature : numpy.ndarray</span>
<span class="sd">        Array of integers: +1 for contravariant, -1 for covariant indices.</span>
<span class="sd">    metric_field : numpy.ndarray, optional</span>
<span class="sd">        The diagonal metric entries (e.g., (..., N)).</span>
<span class="sd">    inverse_metric_field : numpy.ndarray, optional</span>
<span class="sd">        The diagonal inverse metric entries (e.g., (..., N)).</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Output array. If provided, will be modified in-place.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : numpy.ndarray</span>
<span class="sd">        Tensor field with modified indices.</span>
<span class="sd">    new_signature : numpy.ndarray</span>
<span class="sd">        Tensor signature after modifications. Same shape as `tensor_signature`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pymetric.differential_geometry.dense_utils import dense_adjust_tensor_signature</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Coordinate values</span>
<span class="sd">    &gt;&gt;&gt; r = 2.0</span>
<span class="sd">    &gt;&gt;&gt; theta = np.pi / 4</span>
<span class="sd">    &gt;&gt;&gt; sin2 = np.sin(theta) ** 2</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Define a rank-2 tensor with a single nonzero component T^{theta,phi}</span>
<span class="sd">    &gt;&gt;&gt; T = np.zeros((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; T[1, 2] = 1.0</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Diagonal metric and inverse metric</span>
<span class="sd">    &gt;&gt;&gt; g = np.array([1.0, r**2, r**2 * sin2])</span>
<span class="sd">    &gt;&gt;&gt; g_inv = np.array([1.0, 1/r**2, 1/(r**2 * sin2)])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Lower both indices (contravariant → covariant)</span>
<span class="sd">    &gt;&gt;&gt; _dense_adjust_tensor_signature_diagonal_metric(</span>
<span class="sd">    ...     tensor_field=T,</span>
<span class="sd">    ...     indices=[0, 1],</span>
<span class="sd">    ...     tensor_signature=np.array([+1, +1]),</span>
<span class="sd">    ...     metric_field=g</span>
<span class="sd">    ... )</span>
<span class="sd">    (array([[0., 0., 0.],</span>
<span class="sd">           [0., 0., 8.],</span>
<span class="sd">           [0., 0., 0.]]), array([-1, -1]))</span>

<span class="sd">    &gt;&gt;&gt; # Raise both indices back (covariant → contravariant)</span>
<span class="sd">    &gt;&gt;&gt; T_lowered = T</span>
<span class="sd">    &gt;&gt;&gt; _dense_adjust_tensor_signature_diagonal_metric(</span>
<span class="sd">    ...     tensor_field=T_lowered,</span>
<span class="sd">    ...     indices=[0, 1],</span>
<span class="sd">    ...     tensor_signature=np.array([-1, -1]),</span>
<span class="sd">    ...     inverse_metric_field=g_inv</span>
<span class="sd">    ... )</span>
<span class="sd">    (array([[0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.   , 0.   , 0.125],</span>
<span class="sd">           [0.   , 0.   , 0.   ]]), array([1, 1]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the rank and dimensionality</span>
    <span class="c1"># of the tensor field.</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">size</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span>

    <span class="c1"># Manage the &quot;out&quot; array. If it hasn&#39;t been created we need to</span>
    <span class="c1"># create it.</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">tensor_field</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tensor_field</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor_field</span>

    <span class="c1"># Pass through each of the indices in the</span>
    <span class="c1"># tensor field and check if we are altering it. If we are, we need to</span>
    <span class="c1"># simply scale all elements by the values of the correct metric.</span>
    <span class="n">new_signature</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">variance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_signature</span><span class="p">):</span>
        <span class="c1"># Check if we are actually making any modifications to</span>
        <span class="c1"># this tensor.</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Create the broadcast shape for the metric tensor</span>
        <span class="c1"># to compy with for this index.</span>
        <span class="n">reshape</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span><span class="p">])</span>
            <span class="o">+</span> <span class="p">[</span>
                <span class="mi">1</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="o">*</span> <span class="n">rank</span>
        <span class="p">)</span>
        <span class="n">reshape</span><span class="p">[</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="o">+</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We are going to try to lower the index. This is either</span>
            <span class="c1"># a multiplication with the metric or a division with the</span>
            <span class="c1"># inverse metric.</span>
            <span class="k">if</span> <span class="n">metric_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">*=</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reshape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">inverse_metric_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">/=</span> <span class="n">inverse_metric_field</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reshape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot lower contravariant index: no metric or inverse metric provided.&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">variance</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We are going to try to lower the index. This is either</span>
            <span class="c1"># a multiplication with the metric or a division with the</span>
            <span class="c1"># inverse metric.</span>
            <span class="k">if</span> <span class="n">inverse_metric_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">*=</span> <span class="n">inverse_metric_field</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reshape</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">metric_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">/=</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">reshape</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot raise covariant index: no metric or inverse metric provided.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Flip the new variance</span>
        <span class="n">new_signature</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">return</span> <span class="n">out</span><span class="p">,</span> <span class="n">new_signature</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_dense_transform_tensor</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tensor_signature</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">jacobian_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inverse_jacobian_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a coordinate transformation to a tensor field using the Jacobian and/or its inverse.</span>

<span class="sd">    This function transforms each tensor index of the field according to its variance type:</span>

<span class="sd">        - Contravariant indices (denoted +1 in `tensor_signature`) transform using the Jacobian,</span>
<span class="sd">        - Covariant indices (denoted -1) transform using the inverse Jacobian.</span>

<span class="sd">    The transformation is performed via Einstein summation (einsum). The coordinate transformation</span>
<span class="sd">    matrices may be functions of space and should be broadcast-compatible with the grid dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        The input tensor field of shape (..., I₁, ..., I_r), where the last `r` axes</span>
<span class="sd">        represent the tensor indices.</span>
<span class="sd">    tensor_signature : numpy.ndarray</span>
<span class="sd">        Array of shape `(rank,)` with entries:</span>
<span class="sd">            - +1 for contravariant indices (upper indices),</span>
<span class="sd">            - -1 for covariant indices (lower indices).</span>
<span class="sd">    jacobian_field : numpy.ndarray, optional</span>
<span class="sd">        The Jacobian matrix ∂x_old / ∂x_new of shape (..., N, N), used to transform contravariant indices.</span>
<span class="sd">    inverse_jacobian_field : numpy.ndarray, optional</span>
<span class="sd">        The inverse Jacobian ∂x_new / ∂x_old of shape (..., N, N), used to transform covariant indices.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments passed to :py:func:`numpy.einsum` (e.g., optimize=True).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The transformed tensor field in the new coordinate system. Shape is identical to `tensor_field`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If a required transformation matrix is missing for the given tensor signature.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(10, 3)  # Vector field (rank-1)</span>
<span class="sd">    &gt;&gt;&gt; sig = np.array([+1])       # Contravariant</span>
<span class="sd">    &gt;&gt;&gt; J = np.eye(3)[None, ...]   # Identity Jacobian</span>
<span class="sd">    &gt;&gt;&gt; _dense_transform_tensor(T, sig, jacobian=J).shape</span>
<span class="sd">    (10, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">size</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tensor_field</span>  <span class="c1"># Scalar field, no transformation needed</span>

    <span class="c1"># Set up einsum notation</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span>
    <span class="n">caps</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span>

    <span class="n">field_ndim</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span>
    <span class="n">field_indices</span> <span class="o">=</span> <span class="n">letters</span><span class="p">[:</span><span class="n">field_ndim</span><span class="p">]</span>
    <span class="n">tensor_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">letters</span><span class="p">[</span><span class="n">field_ndim</span><span class="p">:</span><span class="n">ndim</span><span class="p">])</span>
    <span class="n">transformed_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tensor_indices</span><span class="p">)</span>
    <span class="n">capital_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">caps</span><span class="p">[</span><span class="n">field_ndim</span><span class="p">:</span><span class="n">ndim</span><span class="p">])</span>

    <span class="n">lhs_terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">field_indices</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tensor_indices</span><span class="p">)]</span>
    <span class="n">operands</span> <span class="o">=</span> <span class="p">[</span><span class="n">tensor_field</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">variance</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_signature</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">variance</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">jacobian_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Jacobian is required to transform contravariant indices.&quot;</span>
                <span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">jacobian_field</span>
        <span class="k">elif</span> <span class="n">variance</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inverse_jacobian_field</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Inverse Jacobian is required to transform covariant indices.&quot;</span>
                <span class="p">)</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">inverse_jacobian_field</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid tensor signature: expected +1 or -1, got </span><span class="si">{</span><span class="n">variance</span><span class="si">}</span><span class="s2"> at index </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">lhs_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">field_indices</span><span class="si">}{</span><span class="n">capital_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}{</span><span class="n">tensor_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">transformed_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">capital_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="c1"># Construct and evaluate einsum</span>
    <span class="n">result_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lhs_terms</span><span class="p">)</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">field_indices</span><span class="si">}{</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">transformed_indices</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">result_expr</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># ------------------------------------------- #</span>
<span class="c1"># User level utilities                        #</span>
<span class="c1"># ------------------------------------------- #</span>
<span class="c1"># These are wrapper methods to ensure that the private methods</span>
<span class="c1"># above are correctly handled in terms of error handling and validation.</span>
<div class="viewcode-block" id="dense_contract_with_metric">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_contract_with_metric.html#differential_geometry.dense_utils.dense_contract_with_metric">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_contract_with_metric</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Contract a tensor index with the provided metric tensor.</span>

<span class="sd">    This function contracts one of the tensor indices of the input tensor field</span>
<span class="sd">    with the supplied metric. If the metric is diagonal (1D or (..., N)), an optimized</span>
<span class="sd">    elementwise contraction is used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        The tensor field whose index signature is to be adjusted.</span>
<span class="sd">        The array should have shape ``(F₁, ..., F_m, I₁, ..., I_r)``, where:</span>

<span class="sd">        - ``(F₁, ..., F_m)`` are the field (spatial or grid) dimensions,</span>
<span class="sd">        - ``(I₁, ..., I_r)`` are the tensor index dimensions, and</span>
<span class="sd">        - `r` is the tensor rank (i.e., the number of tensor indices, inferred from `tensor_signature`).</span>
<span class="sd">    metric_field : numpy.ndarray</span>
<span class="sd">        Metric tensor. Must be either:</span>

<span class="sd">        - Full matrix of shape ``(..., N, N)``, or</span>
<span class="sd">        - Diagonal-only array of shape ``(..., N)``.</span>

<span class="sd">    index : int</span>
<span class="sd">        Index (among the trailing `rank` tensor indices) to contract.</span>
<span class="sd">    rank : int</span>
<span class="sd">        The number of trailing axes in `tensor_field` that represent tensor indices.</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional output array to store the result. If provided, must have the same shape and dtype</span>
<span class="sd">        as the expected output, and will be used for in-place storage.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments forwarded to low-level routines (e.g., ``optimize=True`` for :func:`numpy.einsum`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A new tensor field with the specified index contracted, replacing that axis with the contracted result.</span>
<span class="sd">        The shape of the output reflects broadcasting between `tensor_field` and `metric_field`.</span>


<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If shapes are incompatible or inputs are invalid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Contract a rank-1 tensor field with a full metric (identity):</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(5, 5, 3)  # shape: (grid_x, grid_y, vector_index)</span>
<span class="sd">    &gt;&gt;&gt; g = np.eye(3)[np.newaxis, np.newaxis, :, :] * np.ones((5, 5, 1, 1))  # shape: (5, 5, 3, 3)</span>
<span class="sd">    &gt;&gt;&gt; result = dense_contract_with_metric(T, g, index=0, rank=1)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    (5, 5, 3)</span>

<span class="sd">    Contract with a diagonal metric:</span>

<span class="sd">    &gt;&gt;&gt; g_diag = np.array([1.0, 2.0, 3.0])[np.newaxis, np.newaxis, :] * np.ones((5, 5, 1))  # shape: (5, 5, 3)</span>
<span class="sd">    &gt;&gt;&gt; result = dense_contract_with_metric(T, g_diag, index=0, rank=1)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    (5, 5, 3)</span>

<span class="sd">    Use broadcasting between mismatched shapes:</span>

<span class="sd">    &gt;&gt;&gt; T = np.random.rand(5, 1, 3)                 # shape: (5, 3)</span>
<span class="sd">    &gt;&gt;&gt; g = np.ones((5, 7, 3, 3))                # shape: (5, 7, 3, 3)</span>
<span class="sd">    &gt;&gt;&gt; result = dense_contract_with_metric(T, g, index=0, rank=1)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    (5, 7, 3)</span>

<span class="sd">    &gt;&gt;&gt; g_diag = np.ones((5, 7, 3))              # diagonal version</span>
<span class="sd">    &gt;&gt;&gt; result = dense_contract_with_metric(T, g_diag, index=0, rank=1)</span>
<span class="sd">    &gt;&gt;&gt; result.shape</span>
<span class="sd">    (5, 7, 3)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Internally, this function dispatches to one of two lower-level routines:</span>

<span class="sd">    - :func:`_dense_contract_index_with_metric`: used for full metric tensors of shape ``(..., N, N)``.</span>
<span class="sd">      This uses a batched contraction implemented via `np.einsum` with automatic broadcasting.</span>

<span class="sd">    - :func:`_dense_contract_index_with_diagonal_metric`: used for diagonal metrics with shape ``(..., N)``.</span>
<span class="sd">      This uses elementwise multiplication and is significantly faster and lighter on memory.</span>

<span class="sd">    These helper functions follow NumPy-style broadcasting and allow tensor fields and metric tensors</span>
<span class="sd">    to differ in shape along non-contracted dimensions, as long as they are broadcast-compatible.</span>
<span class="sd">    No shape validation is performed beyond what NumPy itself requires.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.einsum : Batched Einstein summation (used internally).</span>
<span class="sd">    numpy.multiply : Elementwise multiplication (used for diagonal metric contraction).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Rank exceeds number of tensor field dimensions.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index must be within the range [0, rank).&quot;</span><span class="p">)</span>

    <span class="c1"># Determine grid shape and index size</span>
    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">axis_size</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">rank</span> <span class="o">+</span> <span class="n">index</span><span class="p">]</span>

    <span class="c1"># Handle full metric case (..., N, N)</span>
    <span class="k">if</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="p">(</span><span class="n">axis_size</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Full metric tensor shape is not broadcast-compatible with tensor field grid shape:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;grid_shape: </span><span class="si">{</span><span class="n">grid_shape</span><span class="si">}</span><span class="s2">, metric shape: </span><span class="si">{</span><span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_dense_contract_index_with_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">metric_field</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="c1"># Handle diagonal metric case (..., N)</span>
    <span class="k">elif</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">axis_size</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Diagonal metric tensor shape is not broadcast-compatible with tensor field grid shape:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;grid_shape: </span><span class="si">{</span><span class="n">grid_shape</span><span class="si">}</span><span class="s2">, metric shape: </span><span class="si">{</span><span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_dense_contract_index_with_diagonal_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">metric_field</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
        <span class="p">)</span>

    <span class="c1"># Not compatible with either expected form</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Metric field must be either (..., N, N) or (..., N), with N matching the contracted axis size.&quot;</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="dense_raise_index">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_raise_index.html#differential_geometry.dense_utils.dense_raise_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_raise_index</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise a specified index of a tensor field using the inverse metric tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        The tensor field whose index signature is to be adjusted.</span>
<span class="sd">        The array should have shape ``(F₁, ..., F_m, I₁, ..., I_r)``, where:</span>

<span class="sd">        - ``(F₁, ..., F_m)`` are the field (spatial or grid) dimensions,</span>
<span class="sd">        - ``(I₁, ..., I_r)`` are the tensor index dimensions, and</span>
<span class="sd">        - `r` is the tensor rank (i.e., the number of tensor indices, inferred from `tensor_signature`).</span>
<span class="sd">    index : int</span>
<span class="sd">        The index to lower, ranging from ``0`` to ``rank-1``.</span>
<span class="sd">    rank : int</span>
<span class="sd">        The tensor rank (number of tensor indices, not including grid dimensions).</span>
<span class="sd">    inverse_metric_field : numpy.ndarray, optional</span>
<span class="sd">        The inverse metric tensor used to raise covariant indices. This can be either:</span>

<span class="sd">        - A full inverse metric of shape (..., N, N), or</span>
<span class="sd">        - A diagonal inverse metric of shape (..., N).</span>

<span class="sd">        Must match the metric type (diagonal vs full) and be broadcast-compatible with `tensor_field`.</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional output array to store the result. If provided, must have the same shape and dtype</span>
<span class="sd">        as the expected output, and will be used for in-place storage.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A tensor field with the specified index raised. Has the same shape as `tensor_field`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dense_lower_index</span>
<span class="sd">    dense_adjust_tensor_signature</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input shapes or indices are invalid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In spherical coordinates, if you have a covariant vector:</span>

<span class="sd">    .. math::</span>

<span class="sd">        {\bf v} = r {\bf e}^\theta</span>

<span class="sd">    Then the contravariant version is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        v^\theta = g^{\theta \mu} v_\mu = g^{\theta \theta} v_\theta = \frac{1}{r^2} v_{\theta} = \frac{1}{r}.</span>

<span class="sd">    Let&#39;s see this work in practice:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pymetric.differential_geometry.dense_utils import dense_raise_index</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Construct the vector field at a point.</span>
<span class="sd">    &gt;&gt;&gt; # We&#39;ll need the metric (inverse) and the vector field at the point.</span>
<span class="sd">    &gt;&gt;&gt; r,theta = 2,np.pi/4</span>
<span class="sd">    &gt;&gt;&gt; v_cov = np.asarray([0,r,0])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Construct the metric tensor.</span>
<span class="sd">    &gt;&gt;&gt; g_inv = np.diag([1, 1 / r**2, 1 / (r**2 * np.sin(theta)**2)])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Now we can use the inverse metric to raise the tensor index.</span>
<span class="sd">    &gt;&gt;&gt; dense_raise_index(v_cov, index=0, rank=1, inverse_metric_field=g_inv)</span>
<span class="sd">    array([0. , 0.5, 0. ])</span>

<span class="sd">    A 2D example on a spherical grid:</span>

<span class="sd">    .. plot::</span>
<span class="sd">        :include-source: True</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.differential_geometry.dense_utils import dense_raise_index</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Define 2D spherical grid</span>
<span class="sd">        &gt;&gt;&gt; r = np.linspace(1, 2, 100)</span>
<span class="sd">        &gt;&gt;&gt; theta = np.linspace(0.1, np.pi - 0.1, 100)</span>
<span class="sd">        &gt;&gt;&gt; R, THETA = np.meshgrid(r, theta, indexing=&quot;ij&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Define a covariant vector field: v_θ = R</span>
<span class="sd">        &gt;&gt;&gt; v_cov = np.zeros(R.shape + (2,))</span>
<span class="sd">        &gt;&gt;&gt; v_cov[..., 1] = R  # non-zero only in theta direction</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Define the inverse metric: g^{rr} = 1, g^{θθ} = 1 / r^2</span>
<span class="sd">        &gt;&gt;&gt; g_inv = np.zeros(R.shape + (2,))</span>
<span class="sd">        &gt;&gt;&gt; g_inv[..., 0] = 1</span>
<span class="sd">        &gt;&gt;&gt; g_inv[..., 1] = 1 / R**2</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Raise the index</span>
<span class="sd">        &gt;&gt;&gt; v_contra = dense_raise_index(v_cov, index=0, rank=1, inverse_metric_field=g_inv)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Plot the raised θ-component</span>
<span class="sd">        &gt;&gt;&gt; _ = plt.figure(figsize=(6, 4))</span>
<span class="sd">        &gt;&gt;&gt; im = plt.imshow(v_contra[..., 1].T, extent=[1, 2, 0.1, np.pi - 0.1], aspect=&quot;auto&quot;, origin=&quot;lower&quot;)</span>
<span class="sd">        &gt;&gt;&gt; _ = plt.colorbar(im, label=&quot;Raised $v^\theta$&quot;)</span>
<span class="sd">        &gt;&gt;&gt; _ = plt.xlabel(&quot;r&quot;)</span>
<span class="sd">        &gt;&gt;&gt; _ = plt.ylabel(r&quot;$\theta$&quot;)</span>
<span class="sd">        &gt;&gt;&gt; _ = plt.title(r&quot;Contravariant Component $v^\theta = r$&quot;)</span>
<span class="sd">        &gt;&gt;&gt; _ = plt.tight_layout()</span>
<span class="sd">        &gt;&gt;&gt; _ = plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Rank must be less than or equal to the number of tensor_field dimensions.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index must be in the range [0, rank).&quot;</span><span class="p">)</span>

    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">tensor_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">rank</span><span class="p">:]</span>
    <span class="n">index_size</span> <span class="o">=</span> <span class="n">tensor_shape</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Dispatch based on whether the metric is full or diagonal</span>
    <span class="k">if</span> <span class="n">inverse_metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_size</span><span class="p">,</span> <span class="n">index_size</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_dense_contract_index_with_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">inverse_metric_field</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">inverse_metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_size</span><span class="p">,):</span>
        <span class="k">return</span> <span class="n">_dense_contract_index_with_diagonal_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">inverse_metric_field</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Metric shape </span><span class="si">{</span><span class="n">inverse_metric_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> is incompatible with tensor shape </span><span class="si">{</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;and expected index size </span><span class="si">{</span><span class="n">index_size</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="dense_lower_index">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_lower_index.html#differential_geometry.dense_utils.dense_lower_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_lower_index</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lowers a specified index of a tensor field using the metric tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        The tensor field whose index signature is to be adjusted.</span>
<span class="sd">        The array should have shape ``(F₁, ..., F_m, I₁, ..., I_r)``, where:</span>

<span class="sd">        - ``(F₁, ..., F_m)`` are the field (spatial or grid) dimensions,</span>
<span class="sd">        - ``(I₁, ..., I_r)`` are the tensor index dimensions, and</span>
<span class="sd">        - `r` is the tensor rank (i.e., the number of tensor indices, inferred from `tensor_signature`).</span>
<span class="sd">    index : int</span>
<span class="sd">        The index to lower, ranging from ``0`` to ``rank-1``.</span>
<span class="sd">    rank : int</span>
<span class="sd">        The tensor rank (number of tensor indices, not including grid dimensions).</span>
<span class="sd">    metric_field : numpy.ndarray, optional</span>
<span class="sd">        The metric tensor used to lower contravariant indices. This can be either:</span>

<span class="sd">        - A full metric of shape (..., N, N), where N is the size of each tensor slot.</span>
<span class="sd">        - A diagonal metric of shape (..., N), representing only the diagonal components.</span>

<span class="sd">        Must be broadcast-compatible with the grid shape of `tensor_field`.</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional output array to store the result. If provided, must have the same shape and dtype</span>
<span class="sd">        as the expected output, and will be used for in-place storage.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A tensor field with the specified index lowered. Has the same shape as `tensor_field`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    raise_index</span>
<span class="sd">    adjust_tensor_signature</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input shapes or indices are invalid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In spherical coordinates, the metric tensor is diagonal:</span>

<span class="sd">    .. math::</span>

<span class="sd">        g_{\mu\nu} = \mathrm{diag}(1, r^2, r^2 \sin^2\theta)</span>

<span class="sd">    If you have a contravariant vector with components:</span>

<span class="sd">    .. math::</span>

<span class="sd">        v^\mu = [0,\ r,\ 0]</span>

<span class="sd">    then the covariant version (with one index lowered) is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        v_\mu = g_{\mu\nu} v^\nu = [0,\ r^3,\ 0]</span>

<span class="sd">    Let&#39;s see this work in practice:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pymetric.differential_geometry.dense_utils import dense_lower_index</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Construct the contravariant vector field at a point.</span>
<span class="sd">    &gt;&gt;&gt; r, theta = 2.0, np.pi / 4</span>
<span class="sd">    &gt;&gt;&gt; v_contra = np.array([0.0, r, 0.0])  # v^theta = r</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Construct the spherical coordinate metric (diagonal)</span>
<span class="sd">    &gt;&gt;&gt; g_diag = np.array([1.0, r**2, r**2 * np.sin(theta)**2])  # g_{rr}, g_{θθ}, g_{φφ}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Lower the index</span>
<span class="sd">    &gt;&gt;&gt; v_cov = dense_lower_index(v_contra, index=0, rank=1, metric_field=g_diag)</span>
<span class="sd">    &gt;&gt;&gt; v_cov</span>
<span class="sd">    array([0., 8., 0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Rank must be less than or equal to the number of tensor_field dimensions.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index must be in the range [0, rank).&quot;</span><span class="p">)</span>

    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">tensor_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="n">rank</span><span class="p">:]</span>
    <span class="n">index_size</span> <span class="o">=</span> <span class="n">tensor_shape</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="c1"># Dispatch based on whether the metric is full or diagonal</span>
    <span class="k">if</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_size</span><span class="p">,</span> <span class="n">index_size</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_dense_contract_index_with_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">metric_field</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">index_size</span><span class="p">,):</span>
        <span class="k">return</span> <span class="n">_dense_contract_index_with_diagonal_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">metric_field</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Metric shape </span><span class="si">{</span><span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> is incompatible with tensor shape </span><span class="si">{</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;and expected index size </span><span class="si">{</span><span class="n">index_size</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="dense_adjust_tensor_signature">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_adjust_tensor_signature.html#differential_geometry.dense_utils.dense_adjust_tensor_signature">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_adjust_tensor_signature</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">tensor_signature</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adjust multiple indices of a tensor field by raising or lowering them using the metric or inverse metric.</span>

<span class="sd">    This function modifies the variance (covariant vs. contravariant) of selected tensor indices</span>
<span class="sd">    by contracting them with either the metric tensor or its inverse. The transformation can be</span>
<span class="sd">    performed efficiently for both full (2D) and diagonal (1D) metric representations.</span>

<span class="sd">    The adjustment is specified through a signature array, where each element corresponds to the</span>
<span class="sd">    current variance of a tensor index:</span>

<span class="sd">        - ``+1``: Contravariant (upper index) → lowering uses the metric</span>
<span class="sd">        - ``-1``: Covariant (lower index) → raising uses the inverse metric</span>

<span class="sd">    Only the indices listed in `indices` will be modified; others are left untouched.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        The tensor field whose index signature is to be adjusted.</span>
<span class="sd">        The array should have shape ``(F₁, ..., F_m, I₁, ..., I_r)``, where:</span>

<span class="sd">        - ``(F₁, ..., F_m)`` are the field (spatial or grid) dimensions,</span>
<span class="sd">        - ``(I₁, ..., I_r)`` are the tensor index dimensions, and</span>
<span class="sd">        - `r` is the tensor rank (i.e., the number of tensor indices, inferred from `tensor_signature`).</span>
<span class="sd">    indices : list of int</span>
<span class="sd">        List of indices (from 0 to `rank - 1`) specifying which tensor slots to modify.</span>
<span class="sd">        These refer to the positions within the tensor portion of the array (i.e., the last `rank` axes).</span>
<span class="sd">        Indices may appear in any order. If the same index appears multiple times, the corresponding</span>
<span class="sd">        variance transformations will be applied sequentially, potentially resulting in no net change.</span>
<span class="sd">    tensor_signature : numpy.ndarray</span>
<span class="sd">        A 1D array of integers of shape ``(rank,)`` specifying the current variance of each tensor index.</span>
<span class="sd">        Each entry must be either ``+1`` (indicating a contravariant index) or ``-1`` (indicating a covariant index).</span>
<span class="sd">        The order of entries corresponds to the last ``rank`` axes of ``tensor_field``, and defines how each</span>
<span class="sd">        tensor slot is currently positioned with respect to the coordinate basis.</span>
<span class="sd">    metric_field : numpy.ndarray, optional</span>
<span class="sd">        The metric tensor used to lower contravariant indices. This can be either:</span>

<span class="sd">        - A full metric of shape (..., N, N), where N is the size of each tensor slot.</span>
<span class="sd">        - A diagonal metric of shape (..., N), representing only the diagonal components.</span>

<span class="sd">        Must be broadcast-compatible with the grid shape of `tensor_field`.</span>

<span class="sd">    inverse_metric_field : numpy.ndarray, optional</span>
<span class="sd">        The inverse metric tensor used to raise covariant indices. This can be either:</span>

<span class="sd">        - A full inverse metric of shape (..., N, N), or</span>
<span class="sd">        - A diagonal inverse metric of shape (..., N).</span>

<span class="sd">        Must match the metric type (diagonal vs full) and be broadcast-compatible with `tensor_field`.</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional output array to store the result. If provided, must have the same shape and dtype</span>
<span class="sd">        as the expected output, and will be used for in-place storage.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments forwarded to the underlying einsum or broadcasting routines.</span>
<span class="sd">        These may include:</span>

<span class="sd">        - ``out`` : Optional output array to hold the result. If provided, the operation may be performed in-place.</span>
<span class="sd">        - Array creation keywords such as ``dtype`` or ``order`` when a new output array is allocated (e.g., via `np.empty`).</span>
<span class="sd">        - Einsum-specific options such as ``optimize=True`` for path optimization.</span>

<span class="sd">        The accepted keywords depend on whether a diagonal or full metric is used, as different implementations</span>
<span class="sd">        (`np.einsum` vs broadcasting and `np.empty`) are internally dispatched.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The resulting tensor field with modified index variances. Shape is identical to the input.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If input shapes are inconsistent or if necessary metrics are missing.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    raise_index</span>
<span class="sd">    lower_index</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Consider a tensor defined in spherical coordinates :math:`(r,\theta,\phi)` with a rank-2 structure.</span>
<span class="sd">    The metric tensor in these coordinates is diagonal:</span>

<span class="sd">    .. math::</span>

<span class="sd">        g_{ij} = \text{diag}(1, r^2, r^2 \sin^2 \theta)</span>

<span class="sd">    The inverse metric is:</span>

<span class="sd">    .. math::</span>

<span class="sd">        g^{ij} = \text{diag}(1, 1/r^2, 1/(r^2 \sin^2 \theta))</span>

<span class="sd">    We can lower or raise indices of a tensor as follows:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pymetric.differential_geometry.dense_utils import dense_adjust_tensor_signature</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Coordinate values</span>
<span class="sd">    &gt;&gt;&gt; r = 2.0</span>
<span class="sd">    &gt;&gt;&gt; theta = np.pi / 4</span>
<span class="sd">    &gt;&gt;&gt; sin2 = np.sin(theta) ** 2</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Define a rank-2 tensor with a single nonzero component T^{theta,phi}</span>
<span class="sd">    &gt;&gt;&gt; T = np.zeros((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; T[1, 2] = 1.0</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Diagonal metric and inverse metric</span>
<span class="sd">    &gt;&gt;&gt; g = np.array([1.0, r**2, r**2 * sin2])</span>
<span class="sd">    &gt;&gt;&gt; g_inv = np.array([1.0, 1/r**2, 1/(r**2 * sin2)])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Lower both indices (contravariant → covariant)</span>
<span class="sd">    &gt;&gt;&gt; dense_adjust_tensor_signature(</span>
<span class="sd">    ...     tensor_field=T,</span>
<span class="sd">    ...     indices=[0, 1],</span>
<span class="sd">    ...     tensor_signature=np.array([+1, +1]),</span>
<span class="sd">    ...     metric_field=g</span>
<span class="sd">    ... )</span>
<span class="sd">    (array([[0., 0., 0.],</span>
<span class="sd">           [0., 0., 8.],</span>
<span class="sd">           [0., 0., 0.]]), array([-1, -1]))</span>

<span class="sd">    &gt;&gt;&gt; # Raise both indices back (covariant → contravariant)</span>
<span class="sd">    &gt;&gt;&gt; T_lowered = T</span>
<span class="sd">    &gt;&gt;&gt; dense_adjust_tensor_signature(</span>
<span class="sd">    ...     tensor_field=T_lowered,</span>
<span class="sd">    ...     indices=[0, 1],</span>
<span class="sd">    ...     tensor_signature=np.array([-1, -1]),</span>
<span class="sd">    ...     inverse_metric_field=g_inv</span>
<span class="sd">    ... )</span>
<span class="sd">    (array([[0.   , 0.   , 0.   ],</span>
<span class="sd">           [0.   , 0.   , 0.125],</span>
<span class="sd">           [0.   , 0.   , 0.   ]]), array([1, 1]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Perform shape validation. The tensor signature will imply a rank which</span>
    <span class="c1"># must be larger than the field dimensions. We also check that the metric / inverse metric</span>
    <span class="c1"># are correctly shaped given the rank and number of dimensions and that</span>
    <span class="c1"># the indices never exceed the rank.</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tensor must have positive rank.&quot;</span><span class="p">)</span>

    <span class="n">field_ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span>

    <span class="c1"># Check that the field ndim is non-negative and then check the metric and inverse metric.</span>
    <span class="k">if</span> <span class="n">field_ndim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Tensor of rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2"> requires at least </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2"> dimensions in input array.&quot;</span>
        <span class="p">)</span>

    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">field_ndim</span><span class="p">]</span>
    <span class="n">tensor_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">field_ndim</span><span class="p">:]</span>

    <span class="c1"># Perform the metric tensor validation process. We need to check that, whichever one</span>
    <span class="c1"># we got, it gets triaged into the correct call pattern. If we have a type mismatch,</span>
    <span class="c1"># we need to raise an error.</span>
    <span class="n">_metric_type</span><span class="p">,</span> <span class="n">_inv_metric_type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">metric_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">_metric_type</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span>
        <span class="k">elif</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],):</span>
            <span class="n">_metric_type</span> <span class="o">=</span> <span class="s2">&quot;diag&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Metric tensor shape (</span><span class="si">{</span><span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; does not match field grid and tensor index dimensions.&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">inverse_metric_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inverse_metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span>
            <span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">):</span>
            <span class="n">_inv_metric_type</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span>
        <span class="k">elif</span> <span class="n">inverse_metric_field</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],):</span>
            <span class="n">_inv_metric_type</span> <span class="o">=</span> <span class="s2">&quot;diag&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Inverse metric tensor shape does not match field grid and tensor index dimensions.&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Ensure metric and inverse metric agree in type</span>
    <span class="k">if</span> <span class="n">_metric_type</span> <span class="ow">and</span> <span class="n">_inv_metric_type</span> <span class="ow">and</span> <span class="n">_metric_type</span> <span class="o">!=</span> <span class="n">_inv_metric_type</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Metric and inverse metric types (diagonal vs full) must match.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Determine final type if only one metric is provided</span>
    <span class="n">metric_type</span> <span class="o">=</span> <span class="n">_metric_type</span> <span class="ow">or</span> <span class="n">_inv_metric_type</span>
    <span class="k">if</span> <span class="n">metric_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;At least one of `metric_field` or `inverse_metric_field` must be provided.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Validate that all indices are within rank range</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">rank</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;All indices must be in the range [0, </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">). Got: </span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Dispatch</span>
    <span class="k">if</span> <span class="n">metric_type</span> <span class="o">==</span> <span class="s2">&quot;diag&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_dense_adjust_tensor_signature_diagonal_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span>
            <span class="n">indices</span><span class="p">,</span>
            <span class="n">tensor_signature</span><span class="p">,</span>
            <span class="n">metric_field</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
            <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_dense_adjust_tensor_signature</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span>
            <span class="n">indices</span><span class="p">,</span>
            <span class="n">tensor_signature</span><span class="p">,</span>
            <span class="n">metric_field</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
            <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="dense_transform_tensor_field">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_transform_tensor_field.html#differential_geometry.dense_utils.dense_transform_tensor_field">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_transform_tensor_field</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">tensor_signature</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">jacobian</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inverse_jacobian</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a coordinate transformation to a tensor field based on its signature and selected indices.</span>

<span class="sd">    This function transforms selected indices of a tensor field using the Jacobian or its inverse,</span>
<span class="sd">    depending on the variance (contravariant/covariant) of each index as specified by `tensor_signature`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        Tensor field of shape (..., I₁, ..., I_r), where the last `r` axes are tensor indices.</span>
<span class="sd">    indices : List[int]</span>
<span class="sd">        Indices to be transformed (among the last `rank` axes). Each must be in [0, rank).</span>
<span class="sd">    tensor_signature : numpy.ndarray</span>
<span class="sd">        Array of +1 (contravariant) or -1 (covariant) values of shape `(rank,)`.</span>
<span class="sd">    jacobian : numpy.ndarray, optional</span>
<span class="sd">        Jacobian matrix ∂x_old/∂x_new with shape (..., N, N), required for transforming contravariant indices.</span>
<span class="sd">    inverse_jacobian : numpy.ndarray, optional</span>
<span class="sd">        Inverse Jacobian ∂x_new/∂x_old with shape (..., N, N), required for covariant indices.</span>
<span class="sd">    out : numpy.ndarray, optional</span>
<span class="sd">        Optional output array to store the result. If provided, must have the same shape and dtype</span>
<span class="sd">        as the expected output, and will be used for in-place storage.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional arguments passed to the underlying einsum transformation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The transformed tensor field.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If tensor signature or Jacobians are incompatible with input dimensions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    adjust_tensor_signature</span>
<span class="sd">    _transform_tensor_signature</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tensor_field</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">rank</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;All indices must be in the range [0, </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">). Got: </span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Tensor field has </span><span class="si">{</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dims but signature implies rank </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Validate that Jacobians have appropriate shape</span>
    <span class="n">field_ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span>
    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">field_ndim</span><span class="p">]</span>
    <span class="n">tensor_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">field_ndim</span><span class="p">:]</span>

    <span class="n">jacobian_type</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">jacobian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">jacobian</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">jacobian_type</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Jacobian shape must be (..., N, N), matching field grid dimensions.&quot;</span>
            <span class="p">)</span>

    <span class="n">inv_jacobian_type</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">inverse_jacobian</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">inverse_jacobian</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">grid_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tensor_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">inv_jacobian_type</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Inverse Jacobian shape must be (..., N, N), matching field grid dimensions.&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">jacobian_type</span> <span class="ow">and</span> <span class="n">inv_jacobian_type</span> <span class="ow">and</span> <span class="n">jacobian_type</span> <span class="o">!=</span> <span class="n">inv_jacobian_type</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Jacobian and inverse Jacobian must match in structure (both full or both diag).&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">jacobian</span> <span class="ow">or</span> <span class="n">inverse_jacobian</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;At least one of `jacobian` or `inverse_jacobian` must be provided.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Mask signature for selected indices only</span>
    <span class="n">effective_signature</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">effective_signature</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">_dense_transform_tensor</span><span class="p">(</span>
        <span class="n">tensor_field</span><span class="o">=</span><span class="n">tensor_field</span><span class="p">,</span>
        <span class="n">tensor_signature</span><span class="o">=</span><span class="n">effective_signature</span><span class="p">,</span>
        <span class="n">jacobian</span><span class="o">=</span><span class="n">jacobian</span><span class="p">,</span>
        <span class="n">inverse_jacobian</span><span class="o">=</span><span class="n">inverse_jacobian</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="dense_permute_tensor_indices">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_permute_tensor_indices.html#differential_geometry.dense_utils.dense_permute_tensor_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_permute_tensor_indices</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">permutation</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permutes the order of the tensor indices in the last `rank` dimensions of the tensor field.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        Input tensor with shape (..., i₁, ..., i_r), where the last `rank` axes are tensor indices.</span>
<span class="sd">    permutation : list of int</span>
<span class="sd">        Permutation to apply to the tensor indices. Must be of length `rank` and contain a permutation of [0, ..., rank-1].</span>
<span class="sd">    rank : int</span>
<span class="sd">        The rank (number of tensor axes) of the tensor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Tensor field with permuted tensor indices.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If permutation is not valid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; T = np.random.rand(4, 4, 3, 3)</span>
<span class="sd">    &gt;&gt;&gt; permute_tensor_indices(T, [1, 0], rank=2).shape</span>
<span class="sd">    (4, 4, 3, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Invalid permutation: expected a permutation of [0, ..., </span><span class="si">{</span><span class="n">rank</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">field_ndim</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span>
    <span class="n">full_permutation</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">field_ndim</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="n">field_ndim</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">permutation</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">full_permutation</span><span class="p">)</span></div>



<div class="viewcode-block" id="dense_tensor_product">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_tensor_product.html#differential_geometry.dense_utils.dense_tensor_product">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_tensor_product</span><span class="p">(</span>
    <span class="n">tensor_a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">type_a</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">tensor_b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">type_b</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the tensor product of two tensor fields with specified (p, q) types,</span>
<span class="sd">    ensuring that the result has contravariant indices first and covariant indices last.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_a : numpy.ndarray</span>
<span class="sd">        First tensor field of shape (..., i₁, ..., i_p, j₁, ..., j_q).</span>
<span class="sd">    type_a : tuple[int, int]</span>
<span class="sd">        Tuple (p, q) specifying number of contravariant and covariant indices of `tensor_a`.</span>
<span class="sd">    tensor_b : numpy.ndarray</span>
<span class="sd">        Second tensor field of shape (..., k₁, ..., k_r, l₁, ..., l_t).</span>
<span class="sd">    type_b : tuple[int, int]</span>
<span class="sd">        Tuple (r, t) specifying number of contravariant and covariant indices of `tensor_b`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        The tensor product with type (p + r, q + t), shape (..., i₁, ..., i_p, k₁, ..., k_r, j₁, ..., j_q, l₁, ..., l_t).</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If tensor shapes are incompatible or types are invalid.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.rand(4, 3)     # (1, 0) vector</span>
<span class="sd">    &gt;&gt;&gt; B = np.random.rand(4, 3)     # (0, 1) covector</span>
<span class="sd">    &gt;&gt;&gt; tensor_product(A, (1, 0), B, (0, 1)).shape</span>
<span class="sd">    (4, 3, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Parse tensor types</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">type_a</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">type_b</span>

    <span class="c1"># Get raw dimensions</span>
    <span class="n">ndim_a</span> <span class="o">=</span> <span class="n">tensor_a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">ndim_b</span> <span class="o">=</span> <span class="n">tensor_b</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">rank_a</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span>
    <span class="n">rank_b</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">t</span>

    <span class="n">field_shape_a</span> <span class="o">=</span> <span class="n">tensor_a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="n">ndim_a</span> <span class="o">-</span> <span class="n">rank_a</span><span class="p">]</span>
    <span class="n">field_shape_b</span> <span class="o">=</span> <span class="n">tensor_b</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span> <span class="n">ndim_b</span> <span class="o">-</span> <span class="n">rank_b</span><span class="p">]</span>

    <span class="c1"># Validate broadcastability of the field parts</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">broadcast_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">field_shape_a</span><span class="p">,</span> <span class="n">field_shape_b</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Field dimensions not broadcast-compatible: </span><span class="si">{</span><span class="n">field_shape_a</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">field_shape_b</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Build einsum subscripts</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span>
    <span class="n">caps</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span>

    <span class="c1"># Field dims</span>
    <span class="n">fdim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">broadcast_shape</span><span class="p">)</span>
    <span class="n">field_indices</span> <span class="o">=</span> <span class="n">letters</span><span class="p">[:</span><span class="n">fdim</span><span class="p">]</span>

    <span class="c1"># Build index labels</span>
    <span class="n">a_contra</span> <span class="o">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">fdim</span> <span class="p">:</span> <span class="n">fdim</span> <span class="o">+</span> <span class="n">p</span><span class="p">]</span>
    <span class="n">a_co</span> <span class="o">=</span> <span class="n">letters</span><span class="p">[</span><span class="n">fdim</span> <span class="o">+</span> <span class="n">p</span> <span class="p">:</span> <span class="n">fdim</span> <span class="o">+</span> <span class="n">p</span> <span class="o">+</span> <span class="n">q</span><span class="p">]</span>
    <span class="n">b_contra</span> <span class="o">=</span> <span class="n">caps</span><span class="p">[</span><span class="n">fdim</span> <span class="p">:</span> <span class="n">fdim</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
    <span class="n">b_co</span> <span class="o">=</span> <span class="n">caps</span><span class="p">[</span><span class="n">fdim</span> <span class="o">+</span> <span class="n">r</span> <span class="p">:</span> <span class="n">fdim</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="n">t</span><span class="p">]</span>

    <span class="c1"># Full index lists</span>
    <span class="n">a_indices</span> <span class="o">=</span> <span class="n">field_indices</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a_contra</span> <span class="o">+</span> <span class="n">a_co</span><span class="p">)</span>
    <span class="n">b_indices</span> <span class="o">=</span> <span class="n">field_indices</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">b_contra</span> <span class="o">+</span> <span class="n">b_co</span><span class="p">)</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="n">field_indices</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">a_contra</span> <span class="o">+</span> <span class="n">b_contra</span> <span class="o">+</span> <span class="n">a_co</span> <span class="o">+</span> <span class="n">b_co</span><span class="p">)</span>

    <span class="n">einsum_expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">a_indices</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">b_indices</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="n">result_indices</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">einsum_expr</span><span class="p">,</span> <span class="n">tensor_a</span><span class="p">,</span> <span class="n">tensor_b</span><span class="p">)</span></div>



<div class="viewcode-block" id="dense_compute_tensor_trace">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_compute_tensor_trace.html#differential_geometry.dense_utils.dense_compute_tensor_trace">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_compute_tensor_trace</span><span class="p">(</span>
    <span class="n">tensor_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">tensor_signature</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the trace over a pair of tensor indices, adjusting their variances if needed.</span>

<span class="sd">    This function traces over two tensor slots in a tensor field by summing over their</span>
<span class="sd">    diagonal components. If the indices are both covariant or both contravariant, the appropriate</span>
<span class="sd">    metric (or inverse metric) is used to first raise or lower one of them to enable contraction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor_field : numpy.ndarray</span>
<span class="sd">        Tensor field of shape ``(..., I₁, ..., I_r)``, where the last `r` axes represent tensor indices.</span>
<span class="sd">    indices : Tuple[int, int]</span>
<span class="sd">        The pair of indices to trace over. Indices must be distinct and in the range [0, rank).</span>
<span class="sd">    tensor_signature : numpy.ndarray</span>
<span class="sd">        Array of shape `(rank,)` with +1 for contravariant indices and -1 for covariant ones.</span>
<span class="sd">    metric_field : numpy.ndarray, optional</span>
<span class="sd">        Metric tensor to lower contravariant indices. Required if both traced indices are contravariant.</span>
<span class="sd">    inverse_metric_field : numpy.ndarray, optional</span>
<span class="sd">        Inverse metric tensor to raise covariant indices. Required if both traced indices are covariant.</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        Additional keyword arguments passed to the low-level `numpy.trace` call.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        Tensor field with the two specified indices traced over. Output rank is `rank - 2`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If input validation fails or required metrics are not provided.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pymetric.differential_geometry.dense_utils import compute_tensor_trace</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; T = np.eye(3)[None, None, :, :]  # Rank-2 (1,1)-tensor over a 1x1 grid</span>
<span class="sd">    &gt;&gt;&gt; sig = np.array([+1, -1])</span>
<span class="sd">    &gt;&gt;&gt; compute_tensor_trace(T, indices=(0, 1), tensor_signature=sig)</span>
<span class="sd">    array([[3.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate the indices for the contraction of</span>
    <span class="c1"># the trace.</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot trace over the same index twice.&quot;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rank</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;indices </span><span class="si">{</span><span class="n">indices</span><span class="si">}</span><span class="s2"> must lie in the range [0, </span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="c1"># Check variance compatibility</span>
    <span class="n">vi</span><span class="p">,</span> <span class="n">vj</span> <span class="o">=</span> <span class="n">tensor_signature</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tensor_signature</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">vi</span> <span class="o">==</span> <span class="n">vj</span><span class="p">:</span>
        <span class="c1"># Need to raise or lower one index</span>
        <span class="k">if</span> <span class="n">vi</span> <span class="o">==</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">tensor_signature</span> <span class="o">=</span> <span class="n">dense_adjust_tensor_signature</span><span class="p">(</span>
                <span class="n">tensor_field</span><span class="p">,</span>
                <span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">tensor_signature</span><span class="p">,</span>
                <span class="n">metric_field</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
                <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">vi</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">tensor_field</span><span class="p">,</span> <span class="n">tensor_signature</span> <span class="o">=</span> <span class="n">dense_adjust_tensor_signature</span><span class="p">(</span>
                <span class="n">tensor_field</span><span class="p">,</span>
                <span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">tensor_signature</span><span class="p">,</span>
                <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="n">metric_field</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="c1"># else, one is +1 and one is -1 → already suitable for contraction</span>

    <span class="k">return</span> <span class="n">_dense_compute_tensor_trace</span><span class="p">(</span>
        <span class="n">tensor_field</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="dense_compute_volume_element">
<a class="viewcode-back" href="../../_as_gen/differential_geometry.dense_utils.dense_compute_volume_element.html#differential_geometry.dense_utils.dense_compute_volume_element">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dense_compute_volume_element</span><span class="p">(</span>
    <span class="n">metric_field</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">metric_type</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the volume element (√|det(g)|) from a metric tensor field.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    metric_field : numpy.ndarray</span>
<span class="sd">        The metric tensor field. Depending on `metric_type`, expected shape is:</span>

<span class="sd">            - &quot;full&quot;: shape (..., L, L), representing a full rank-2 metric tensor.</span>
<span class="sd">            - &quot;diag&quot;: shape (..., L), representing a diagonal metric tensor.</span>

<span class="sd">    metric_type : str</span>
<span class="sd">        One of {&quot;full&quot;, &quot;diag&quot;}. Specifies whether the metric is full or diagonal.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        A scalar field of shape (...), representing the volume element √|det(g)| at each point.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the input does not match the specified metric type or shape is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">metric_type</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Full metric tensor must have shape (..., L, L) with square last two dimensions.&quot;</span>
            <span class="p">)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">metric_field</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">metric_type</span> <span class="o">==</span> <span class="s2">&quot;diag&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">metric_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Diagonal metric tensor must have shape (..., L).&quot;</span><span class="p">)</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">metric_field</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unknown metric_type &#39;</span><span class="si">{</span><span class="n">metric_type</span><span class="si">}</span><span class="s2">&#39;. Expected &#39;full&#39; or &#39;diag&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">det</span><span class="p">))</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, Eliza Diggins.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>