
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymetric.coordinates.base &#8212; Pisces-Geometry  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pymetric/coordinates/base';</script>
    <link rel="icon" href="../../../_static/pm_favicon.svg"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Pisces-Geometry  documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started.html">
    Quick-start Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started.html">
    Quick-start Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pymetric.coordinates.base</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pymetric.coordinates.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Base classes and metaclass infrastructure for defining coordinate systems inPyMetric.</span>

<span class="sd">This module provides the foundational machinery for all coordinate system definitions. It includes:</span>

<span class="sd">- ``_CoordinateSystemBase``: the abstract base class for coordinate systems, supporting symbolic and numerical operations,</span>
<span class="sd">- ``_CoordinateMeta``: a metaclass that handles automatic symbolic construction and validation of coordinate classes,</span>
<span class="sd">- :py:func:`class_expression`: a decorator to mark symbolic methods that are evaluated on demand.</span>

<span class="sd">Coordinate systems built on this foundation can define custom metric tensors, symbolic expressions, and conversions</span>
<span class="sd">to/from Cartesian coordinates. These systems support tensor calculus operations such as gradients, divergences, and</span>
<span class="sd">Laplacians, all respecting the underlying geometry.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.differential_geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">compute_Dterm</span><span class="p">,</span> <span class="n">compute_Lterm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.utilities.logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">pg_log</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.utilities.symbolic</span><span class="w"> </span><span class="kn">import</span> <span class="n">lambdify_expression</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">._exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">CoordinateClassException</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.mixins</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">CoordinateOperationsMixin</span><span class="p">,</span>
    <span class="n">CoordinateSystemAxesMixin</span><span class="p">,</span>
    <span class="n">CoordinateSystemCoreMixin</span><span class="p">,</span>
    <span class="n">CoordinateSystemIOMixin</span><span class="p">,</span>
    <span class="n">CoordinateSystemMathMixin</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># ============================ #</span>
<span class="c1"># Typing Utilities             #</span>
<span class="c1"># ============================ #</span>
<span class="n">_ExpressionType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Expr</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">MutableDenseMatrix</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">MutableDenseNDimArray</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">ImmutableDenseMatrix</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">ImmutableDenseNDimArray</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># ============================ #</span>
<span class="c1"># Coordinate Base              #</span>
<span class="c1"># ============================ #</span>
<span class="n">DEFAULT_COORDINATE_REGISTRY</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="sd">&quot;&quot;&quot; dict of str, Any: The default registry containing all initialized coordinate system classes.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># noinspection PyTypeChecker</span>
<span class="k">def</span><span class="w"> </span><span class="nf">class_expression</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">classmethod</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to mark a class method as a symbolic expression (&quot;class expression&quot;) in a coordinate system.</span>

<span class="sd">    Class expressions are symbolic methods that define expressions such as metric tensors,</span>
<span class="sd">    Jacobians, or differential geometry terms. When decorated with this function, the method</span>
<span class="sd">    is automatically registered during class construction and evaluated on demand via</span>
<span class="sd">    :meth:`~coordinates.core.CurvilinearCoordinateSystem.get_class_expression`.</span>

<span class="sd">    The decorated method must be a ``@classmethod`` with the following signature:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        def some_expr(cls, *axes_symbols, **parameter_symbols): ...</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, optional</span>
<span class="sd">        A custom name to assign to the expression. If omitted, the method name is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    classmethod</span>
<span class="sd">        The decorated class method with metadata attached for registration and deferred evaluation.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The decorator only works on methods already marked as ``@classmethod``.</span>
<span class="sd">    - Registered expressions are stored on the class and evaluated once when first accessed.</span>
<span class="sd">    - Use :meth:`get_class_expression(name)` to access the expression symbolically.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    .. code-block:: python</span>

<span class="sd">        class MySystem(CoordinateSystemBase):</span>
<span class="sd">            __AXES__ = [&quot;r&quot;, &quot;theta&quot;]</span>
<span class="sd">            __PARAMETERS__ = {}</span>

<span class="sd">            @class_expression()</span>
<span class="sd">            @classmethod</span>
<span class="sd">            def metric_tensor(cls, r, theta):</span>
<span class="sd">                return sp.Matrix([[1, 0], [0, r**2]])</span>

<span class="sd">        expr = MySystem.get_class_expression(&quot;metric_tensor&quot;)</span>
<span class="sd">        print(expr)  # =&gt; Matrix([[1, 0], [0, r**2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The decorator that adds the wrapper around the class expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The @class_expression decorator must be applied to a @classmethod.&quot;</span>
            <span class="p">)</span>

        <span class="n">original_func</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__func__</span>  <span class="c1"># Extract underlying function from classmethod</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">original_func</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Wrapper that preserves class method behavior.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">original_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Rewrap as a classmethod</span>
        <span class="n">wrapped_method</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>

        <span class="c1"># Attach metadata</span>
        <span class="n">wrapped_method</span><span class="o">.</span><span class="n">class_expression</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">wrapped_method</span><span class="o">.</span><span class="n">expression_name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">original_func</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">return</span> <span class="n">wrapped_method</span>

    <span class="k">return</span> <span class="n">decorator</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_CoordinateMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Generate the class object using the basic object</span>
        <span class="c1"># procedure. We then make modifications to this.</span>
        <span class="n">cls_object</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Fetch the class flags from the class object. Based on these values, we then</span>
        <span class="c1"># make decisions about how to process the class during setup.</span>
        <span class="n">_cls_is_abstract</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls_object</span><span class="p">,</span> <span class="s2">&quot;__is_abstract__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">_cls_setup_point</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls_object</span><span class="p">,</span> <span class="s2">&quot;__setup_point__&quot;</span><span class="p">,</span> <span class="s2">&quot;init&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_cls_is_abstract</span><span class="p">:</span>
            <span class="c1"># We do not process this class at all.</span>
            <span class="k">return</span> <span class="n">cls_object</span>

        <span class="c1"># Now validate the class - This is performed even if the initialization is</span>
        <span class="c1"># actually performed at init time because it is a very quick function call.</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="n">mcs</span><span class="o">.</span><span class="n">validate_coordinate_system_class</span><span class="p">(</span><span class="n">cls_object</span><span class="p">)</span>

        <span class="c1"># Add the class to the registry.</span>
        <span class="n">DEFAULT_COORDINATE_REGISTRY</span><span class="p">[</span><span class="n">cls_object</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">cls_object</span>

        <span class="c1"># Check if the class is supposed to be set up immediately or if we</span>
        <span class="c1"># delay.</span>
        <span class="k">if</span> <span class="n">_cls_setup_point</span> <span class="o">==</span> <span class="s2">&quot;import&quot;</span><span class="p">:</span>
            <span class="c1"># noinspection PyUnresolvedReferences</span>
            <span class="n">cls_object</span><span class="o">.</span><span class="n">__setup_class__</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">cls_object</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_coordinate_system_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate a new coordinate system class. This includes determining the number of</span>
<span class="sd">        dimensions and ensuring that bounds and coordinates are all accurate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check the new class for the required attributes that all classes should have.</span>
        <span class="n">__required_elements__</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;__AXES__&quot;</span><span class="p">,</span>
            <span class="s2">&quot;__PARAMETERS__&quot;</span><span class="p">,</span>
            <span class="s2">&quot;__axes_symbols__&quot;</span><span class="p">,</span>
            <span class="s2">&quot;__parameter_symbols__&quot;</span><span class="p">,</span>
            <span class="s2">&quot;__NDIM__&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">_re_</span> <span class="ow">in</span> <span class="n">__required_elements__</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_re_</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">CoordinateClassException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Coordinate system </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not define or inherit an expected &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;class attribute: `</span><span class="si">{</span><span class="n">_re_</span><span class="si">}</span><span class="s2">`.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Ensure that we have specified axes and that they have the correct length.</span>
        <span class="c1"># The AXES_BOUNDS need to be validated to ensure that they have the correct</span>
        <span class="c1"># structure and only specify valid conventions for boundaries.</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__AXES__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CoordinateClassException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coordinate system </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not define a set of axes&quot;</span>
                <span class="s2">&quot;using the `__AXES__` attribute.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine the number of dimensions from __AXES__ and ensure that __AXES_BOUNDS__ is</span>
        <span class="c1"># the same length as axes.</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__NDIM__</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_CoordinateSystemBase</span><span class="p">(</span>
    <span class="n">CoordinateSystemCoreMixin</span><span class="p">,</span>
    <span class="n">CoordinateSystemIOMixin</span><span class="p">,</span>
    <span class="n">CoordinateSystemAxesMixin</span><span class="p">,</span>
    <span class="n">CoordinateOperationsMixin</span><span class="p">,</span>
    <span class="n">CoordinateSystemMathMixin</span><span class="p">,</span>
    <span class="n">ABC</span><span class="p">,</span>
    <span class="n">metaclass</span><span class="o">=</span><span class="n">_CoordinateMeta</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for allPyMetric coordinate system classes. :py:class:`CoordinateSystemBase` provides the backbone</span>
<span class="sd">    for the symbolic / numerical structure of coordinate systems and also acts as a template for developers to use</span>
<span class="sd">    when developing custom coordinate system classes.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    __is_abstract__ : bool</span>
<span class="sd">        Indicates whether the class is abstract (not directly instantiable). For developers subclassing this class, this</span>
<span class="sd">        flag should be set to ``False`` if the coordinate system is actually intended for use. Behind the scenes, this flag</span>
<span class="sd">        is checked by the metaclass to ensure that it does not attempt to validate or create symbols for abstract classes.</span>
<span class="sd">    __setup_point__ : &#39;init&#39; or &#39;import&#39;</span>
<span class="sd">        Determines when the class should perform symbolic processing. If ``import``, then the class will create its symbols</span>
<span class="sd">        and its metric function as soon as the class is loaded (the metaclass performs this). If ``&#39;init&#39;``, then the symbolic</span>
<span class="sd">        processing is delayed until a user instantiates the class for the first time.</span>

<span class="sd">        .. admonition:: Developer Standard</span>

<span class="sd">            In general, there is no reason to use anything other than ``__setup_point__ = &#39;init&#39;``. Using ``&#39;import&#39;`` can</span>
<span class="sd">            significantly slow down the loading process because it requires processing many coordinate systems which may not</span>
<span class="sd">            end up getting used at all.</span>

<span class="sd">    __is_setup__ : bool</span>
<span class="sd">        Tracks whether the class has been set up. **This should not be changed**.</span>
<span class="sd">    __AXES__ : :py:class:`list` of str</span>
<span class="sd">        A list of the coordinate system&#39;s axes. These are then used to create the symbolic versions of the axes which</span>
<span class="sd">        are used in expressions. Subclasses should fill ``__AXES__`` with the intended list of axes in the intended axis</span>
<span class="sd">        order.</span>
<span class="sd">    __PARAMETERS__ : :py:class:`dict` of str, float</span>
<span class="sd">        Dictionary of system parameters with default values. Each entry should be the name of the parameter and each value</span>
<span class="sd">        should correspond to the default value. These are then provided by the user as ``**kwargs`` during ``__init__``.</span>
<span class="sd">    __axes_symbols__ : :py:class:`list` of :py:class:`~sympy.core.symbol.Symbol`</span>
<span class="sd">        Symbolic representations of each coordinate axis. **Do not alter**.</span>
<span class="sd">    __parameter_symbols__ : :py:class:`dict` of str, :py:class:`~sympy.core.symbol.Symbol`</span>
<span class="sd">        Symbolic representations of parameters in the system. **Do not alter**.</span>
<span class="sd">    __class_expressions__ : dict</span>
<span class="sd">        Dictionary of symbolic expressions associated with the system. **Do not alter**.</span>
<span class="sd">    __NDIM__ : int</span>
<span class="sd">        Number of dimensions in the coordinate system. **Do not alter**.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># =============================== #</span>
    <span class="c1"># CLASS FLAGS / CONFIG            #</span>
    <span class="c1"># =============================== #</span>
    <span class="c1"># CoordinateSystem flags are used to indicate to the metaclass whether</span>
    <span class="c1"># certain procedures should be executed on the class.</span>
    <span class="n">__is_abstract__</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="p">(</span>
        <span class="kc">True</span>  <span class="c1"># Marks this class as abstract - no symbolic processing (unusable)</span>
    <span class="p">)</span>
    <span class="n">__setup_point__</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
        <span class="s2">&quot;init&quot;</span><span class="p">,</span> <span class="s2">&quot;import&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;init&quot;</span>  <span class="c1"># Determines when symbolic processing should occur.</span>
    <span class="n">__is_setup__</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Used to check if the class has already been set up.</span>
    <span class="n">__DEFAULT_REGISTRY__</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="n">DEFAULT_COORDINATE_REGISTRY</span>

    <span class="c1"># @@ CLASS ATTRIBUTES @@ #</span>
    <span class="c1"># The CoordinateSystem class attributes provide some of the core attributes</span>
    <span class="c1"># for all coordinate systems and should be adjusted in all subclasses to initialize</span>
    <span class="c1"># the correct axes, dimensionality, etc.</span>
    <span class="n">__AXES__</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;list of str: The axes (coordinate variables) in this coordinate system.</span>
<span class="sd">    This is one of the class-level attributes which is specified in all coordinate systems to determine</span>
<span class="sd">    the names and symbols for the axes. The length of this attribute also determines how many dimensions</span>
<span class="sd">    the coordinate system has.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__PARAMETERS__</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; dict of str, Any: The parameters for this coordinate system and their default values.</span>

<span class="sd">    Each of the parameters in :py:attr:`~pisces.geometry.base.CoordinateSystem.PARAMETERS` may be provided as</span>
<span class="sd">    a ``kwarg`` when creating a new instance of this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__AXES_DIMENSIONS__</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Physical dimension associated with **each** entry in :attr:`__AXES__`.</span>

<span class="sd">    This list gives the **base‐quantity** (length, angle, time, …) that every</span>
<span class="sd">    coordinate carries so that downstream utilities—distance metrics, unit-aware</span>
<span class="sd">    gradients, field constructors, etc.—can reason about unit conversions</span>
<span class="sd">    automatically.</span>

<span class="sd">    Requirements</span>
<span class="sd">    ------------</span>
<span class="sd">    * **Length &amp; order must exactly match** :pyattr:`__AXES__`.</span>
<span class="sd">    * Use ``dimensionless`` or ``None`` if a coordinate has no physical units</span>
<span class="sd">      (e.g. a pure index or normalized radius).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__AXES_LATEX__</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;LaTeX representations of the coordinate axes in this coordinate system.</span>

<span class="sd">    This class flag is entirely optional when implementing new coordinate systems. If</span>
<span class="sd">    it is not set, then the axes names are used as the latex representations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># @@ CLASS BUILDING PROCEDURES @@ #</span>
    <span class="c1"># During either import or init, the class needs to build its symbolic attributes in order to</span>
    <span class="c1"># be usable. The class attributes and relevant class methods are defined in this section</span>
    <span class="c1"># of the class object.</span>
    <span class="n">__axes_symbols__</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
        <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># The symbolic representations of each axis.</span>
    <span class="n">__parameter_symbols__</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="nb">str</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># The symbolic representation of each of the parameters.</span>
    <span class="n">__class_expressions__</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="nb">str</span><span class="p">,</span> <span class="n">Any</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># The expressions that are generated for this class.</span>
    <span class="n">__NDIM__</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># The number of dimensions that this coordinate system has.</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__setup_symbols__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create symbolic representations of coordinate axes and parameters.</span>

<span class="sd">        Populates:</span>
<span class="sd">        - `__axes_symbols__`: sympy Symbols for each coordinate axis.</span>
<span class="sd">        - `__parameter_symbols__`: sympy Symbols for each parameter.</span>

<span class="sd">        This method is called automatically during symbolic setup.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For each of the parameters and for each of the axes, generate a</span>
        <span class="c1"># symbol and store in the correct class variable.</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__axes_symbols__</span> <span class="o">=</span> <span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="n">_ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">_ax</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">]</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__parameter_symbols__</span> <span class="o">=</span> <span class="p">{</span><span class="n">_pn</span><span class="p">:</span> <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">(</span><span class="n">_pn</span><span class="p">)</span> <span class="k">for</span> <span class="n">_pn</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__PARAMETERS__</span><span class="p">}</span>
        <span class="n">pg_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Configured symbols for </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">__axes_symbols__</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameter_symbols__</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__construct_class_expressions__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Register all class-level symbolic expressions defined with @class_expression.</span>

<span class="sd">        Scans the method resolution order (MRO) of the class and identifies class methods</span>
<span class="sd">        tagged as symbolic expressions.</span>

<span class="sd">        Adds them to the `__class_expressions__` dictionary. The expressions are evaluated</span>
<span class="sd">        on demand when requested via `get_class_expression()`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This only registers the expression. Evaluation is deferred until the first access.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># begin the iteration through the class __mro__ to find objects</span>
        <span class="c1"># in the entire inheritance structure.</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">):</span>  <span class="c1"># reversed to ensure subclass -&gt; baseclass</span>
            <span class="c1"># Check if we need to search this element of the __mro__. We only exit if we find</span>
            <span class="c1"># `object` because it&#39;s not going to have any worthwhile symbolics.</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="nb">object</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Check this element of the __mro__ for any relevant elements that</span>
            <span class="c1"># we might want to attach to this class.</span>
            <span class="k">for</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Check if we have any interest in processing these methods. If the method is already</span>
                <span class="c1"># seen, then we skip it. Additionally, if the class expression is missing the correct</span>
                <span class="c1"># attributes, we skip it.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;class_expression&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">base</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="vm">__func__</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;class_expression&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">base</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">))</span>
                    <span class="k">continue</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">base</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">))</span>

                <span class="c1"># At this point, any remaining methods are relevant class expressions which should</span>
                <span class="c1"># be registered. Everything is loaded on demand, so we just add the method to the</span>
                <span class="c1"># expression dictionary and then (when loading) check it to see if it&#39;s loaded or not.</span>
                <span class="n">pg_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Registering </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
                <span class="n">expression_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;expression_name&quot;</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__construct_explicit_class_expressions__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct the symbolic metric and inverse metric tensors along with any other critical</span>
<span class="sd">        symbolic attributes for operations.</span>

<span class="sd">        This method calls:</span>
<span class="sd">        - `__construct_metric_tensor_symbol__`</span>
<span class="sd">        - `__construct_inverse_metric_tensor_symbol__`</span>

<span class="sd">        It stores the results in:</span>
<span class="sd">        - `__class_metric_tensor__`</span>
<span class="sd">        - `__class_inverse_metric_tensor__`</span>
<span class="sd">        - `__metric_determinant_expression__`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is typically overridden in `_OrthogonalCoordinateSystemBase` to avoid computing the inverse directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Derive the metric, inverse metric, and the metric density. We call to the</span>
        <span class="c1"># __construct_metric_tensor_symbol__ and then take the inverse and the determinant of</span>
        <span class="c1"># the matrices.</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span>
            <span class="s2">&quot;metric_tensor&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__construct_metric_tensor_symbol__</span><span class="p">(</span>
            <span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">__axes_symbols__</span><span class="p">,</span> <span class="o">**</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameter_symbols__</span>
        <span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span>
            <span class="s2">&quot;metric_tensor&quot;</span>
        <span class="p">]</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_tensor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Any additional core expressions can be added here. The ones above can also be modified as</span>
        <span class="c1"># needed.</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__setup_class__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Orchestrates the symbolic setup for a coordinate system class.</span>

<span class="sd">        This is the main entry point used during class construction. It performs the following steps:</span>

<span class="sd">        1. Initializes coordinate and parameter symbols.</span>
<span class="sd">        2. Builds explicit class symbols (things like the metric and metric density)</span>
<span class="sd">        3. Registers class expressions.</span>
<span class="sd">        4. Sets up internal flags to avoid re-processing.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        CoordinateClassException</span>
<span class="sd">            If any part of the symbolic setup fails (e.g., axes, metric, or expressions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate the necessity of this procedure. If __is_abstract__, then this should never be reached and</span>
        <span class="c1"># if __is_set_up__, then we don&#39;t actually need to run it.</span>
        <span class="n">pg_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Setting up coordinate system class: </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__is_abstract__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;CoordinateSystem class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is abstract and cannot be instantiated or constructed.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__is_setup__</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Set up checks have passed. Now we need to proceed to constructing the axes symbols and</span>
        <span class="c1"># the parameter symbols and then constructing the symbolic attributes.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__setup_symbols__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CoordinateClassException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Failed to setup the coordinate symbols for coordinate system class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> due to&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; an error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># Construct the explicitly declared class expressions. These are class expressions which are</span>
        <span class="c1"># still registered in `__class_expressions__` but are constructed explicitly as part of class</span>
        <span class="c1"># setup. Additional entries can be declared in the `cls.__setup_class_symbolic_attributes__` method.</span>
        <span class="c1"># Generally, this is used for things like the metric and inverse metric.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__construct_explicit_class_expressions__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CoordinateClassException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Failed to setup the metric tensor for coordinate system class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> due to&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; an error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># Identify the class expressions and register them in __class_expressions__.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__construct_class_expressions__</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CoordinateClassException</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Failed to setup derived class expressions for coordinate system class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> due to&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; an error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

    <span class="c1"># =============================== #</span>
    <span class="c1"># INITIALIZATION                  #</span>
    <span class="c1"># =============================== #</span>
    <span class="c1"># Many method play into the initialization procedure. To ensure extensibility,</span>
    <span class="c1"># these are broken down into sub-methods which can be altered when subclassing the</span>
    <span class="c1"># base class.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Start by creating a carbon-copy of the default parameters.</span>
        <span class="n">_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__PARAMETERS__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># For each of the provided kwargs, we need to check that the kwarg is</span>
        <span class="c1"># in the _parameters dictionary and then set the value.</span>
        <span class="k">for</span> <span class="n">_parameter_name</span><span class="p">,</span> <span class="n">_parameter_value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">_parameter_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_parameters</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameter `</span><span class="si">{</span><span class="n">_parameter_name</span><span class="si">}</span><span class="s2">` is not a recognized parameter of the </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> coordinate system.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># The parameter name is valid, we just need to set the value.</span>
            <span class="n">_parameters</span><span class="p">[</span><span class="n">_parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_parameter_value</span>

        <span class="k">return</span> <span class="n">_parameters</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_explicit_expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set up any special symbolic expressions or numerical instances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Setup the metric, inverse_metric, and the metric density at the instance level.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="s2">&quot;metric_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substitute_expression</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_tensor&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substitute_expression</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="s2">&quot;metric_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substitute_expression</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_density&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Setup the numerical metric and other parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_tensor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_expression</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="s2">&quot;metric_tensor&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">[</span>
            <span class="s2">&quot;inverse_metric_tensor&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_expression</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_density&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_expression</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="s2">&quot;metric_density&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a coordinate system instance with specific parameter values.</span>

<span class="sd">        This constructor sets up the symbolic and numerical infrastructure for the coordinate system</span>
<span class="sd">        by performing the following steps:</span>

<span class="sd">        1. If the class has not already been set up, trigger symbolic construction of metric tensors,</span>
<span class="sd">           symbols, and expressions.</span>
<span class="sd">        2. Validate and store user-provided parameter values, overriding class defaults.</span>
<span class="sd">        3. Substitute parameter values into symbolic expressions to produce instance-specific forms.</span>
<span class="sd">        4. Lambdify key expressions (metric tensor, inverse metric, metric density) for numerical evaluation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Keyword arguments specifying values for coordinate system parameters. Each key should match</span>
<span class="sd">            a parameter name defined in ``__PARAMETERS__``. Any unspecified parameters will use the class-defined</span>
<span class="sd">            default values.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If a provided parameter name is not defined in the coordinate system.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># -- Class Initialization -- #</span>
        <span class="c1"># For coordinate systems with setup flags for &#39;init&#39;, it is necessary to process</span>
        <span class="c1"># symbolics at this point if the class is not initialized.</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__setup_class__</span><span class="p">()</span>

        <span class="c1"># -- Parameter Creation -- #</span>
        <span class="c1"># The coordinate system takes a set of kwargs (potentially empty) which specify</span>
        <span class="c1"># the parameters of the coordinate system. Each should be adapted into a self.__parameters__ dictionary.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setup_parameters</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># -- Base Symbol Manipulations -- #</span>
        <span class="c1"># Once the class is set up, we need to simplify the metric and other class</span>
        <span class="c1"># level symbols to construct the instance level symbols.</span>
        <span class="c1"># noinspection PyTypeChecker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">_ExpressionType</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_explicit_expressions</span><span class="p">()</span>

    <span class="c1"># =============================== #</span>
    <span class="c1"># CORE FUNCTIONALITY              #</span>
    <span class="c1"># =============================== #</span>
    <span class="c1"># @@ DUNDER METHODS @@ #</span>
    <span class="c1"># These should not be altered.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> - Parameters=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span><span class="si">}</span><span class="s2">&gt; &quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of axes in the coordinate system.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; cs = MyCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; print(len(cs))</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a hash value for the CoordinateSystem instance.</span>

<span class="sd">        The hash is based on the class name and keyword arguments (``__parameters__``).</span>
<span class="sd">        This ensures that two instances with the same class and initialization parameters produce the same hash.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The hash value of the instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the axis name at the specified index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the axis to retrieve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The name of the axis at the given index.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            If the index is out of range.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; cs = MyCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; axis_name = cs[0]</span>
<span class="sd">        &gt;&gt;&gt; print(axis_name)</span>
<span class="sd">        &#39;r&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether a given axis name is part of the coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis_name : str</span>
<span class="sd">            The axis name to check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the axis name is present; False otherwise.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; cs = MyCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; &#39;r&#39; in cs</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">axis_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks equality between two coordinate system instances.</span>

<span class="sd">        Returns True if:</span>
<span class="sd">          1. They are instances of the same class.</span>
<span class="sd">          2. They have the same axes (in the same order).</span>
<span class="sd">          3. They have the same parameter keys and values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            The object to compare with this coordinate system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if they are considered equal, False otherwise.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; cs1 = MyCoordinateSystem(a=3)</span>
<span class="sd">        &gt;&gt;&gt; cs2 = MyCoordinateSystem(a=3)</span>
<span class="sd">        &gt;&gt;&gt; print(cs1 == cs2)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Compare axes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">axes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Compare parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a shallow copy of the coordinate system.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _CoordinateSystemBase</span>
<span class="sd">            A new instance of the same class, initialized with the same parameters.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        &gt;&gt;&gt; import copy</span>
<span class="sd">        &gt;&gt;&gt; cs1 = MyCoordinateSystem(a=3)</span>
<span class="sd">        &gt;&gt;&gt; cs2 = copy.copy(cs1)</span>
<span class="sd">        &gt;&gt;&gt; print(cs1 == cs2)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Shallow copy: re-init with same parameters</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_obj</span>

    <span class="c1"># @@ PROPERTIES @@ #</span>
    <span class="c1"># These should not be altered in subclasses.</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of dimensions spanned by this coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__NDIM__</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The axes (strings) present in this coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">[:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The parameters of this coordinate system. Note that modifications made to the returned dictionary</span>
<span class="sd">        are not reflected in the class itself. To change a parameter value, the class must be re-instantiated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metric_tensor_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ExpressionType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The symbolic metric tensor for this coordinate system instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_tensor&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_metric_tensor_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ExpressionType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The symbolic inverse metric tensor for this coordinate system instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metric_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the callable function for the metric tensor of the coordinate system.</span>

<span class="sd">        The metric tensor :math:`g_{ij}` defines the inner product structure of the coordinate system.</span>
<span class="sd">        It is used for measuring distances, computing derivatives, and raising/lowering indices.</span>
<span class="sd">        This function returns the precomputed metric tensor as a callable function, which can be</span>
<span class="sd">        evaluated at specific coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable</span>
<span class="sd">            A function that computes the metric tensor :math:`g_{ij}` when evaluated at specific coordinates.</span>
<span class="sd">            The returned function takes numerical coordinate values as inputs and outputs a NumPy array</span>
<span class="sd">            of shape ``(ndim, ndim)``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            cs = MyCoordinateSystem()</span>
<span class="sd">            g_ij = cs.metric_tensor(x=1, y=2, z=3)  # Evaluates the metric at (1,2,3)</span>
<span class="sd">            print(g_ij.shape)  # Output: (ndim, ndim)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_tensor&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inverse_metric_tensor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the callable function for the inverse metric tensor of the coordinate system.</span>

<span class="sd">        The inverse metric tensor :math:`g^{ij}` is the inverse of :math:`g_{ij}` and is used to raise indices,</span>
<span class="sd">        compute dual bases, and perform coordinate transformations. This function returns a callable</span>
<span class="sd">        representation of :math:`g^{ij}`, allowing evaluation at specific coordinate points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable</span>
<span class="sd">            A function that computes the inverse metric tensor :math:`g^{ij}` when evaluated at specific coordinates.</span>
<span class="sd">            The returned function takes numerical coordinate values as inputs and outputs a NumPy array</span>
<span class="sd">            of shape ``(ndim, ndim)``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            cs = MyCoordinateSystem()</span>
<span class="sd">            g_inv = cs.inverse_metric_tensor(x=1, y=2, z=3)  # Evaluates g^{ij} at (1,2,3)</span>
<span class="sd">            print(g_inv.shape)  # Output: (ndim, ndim)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">[</span><span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">axes_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The symbols representing each of the coordinate axes in this coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__axes_symbols__</span><span class="p">[:]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">axes_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the symbolic physical dimensions associated with each axis.</span>

<span class="sd">        This is typically used for inferring units or performing dimensional analysis.</span>
<span class="sd">        The list is expected to match the coordinate system’s `__AXES__` order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of sympy.Basic</span>
<span class="sd">            The symbolic dimension of each axis (e.g., `L`, `1`, etc.).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `__AXES_DIMENSIONS__` is not defined for the coordinate system class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;__AXES_DIMENSIONS__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not define __AXES_DIMENSIONS__. &quot;</span>
            <span class="s2">&quot;This must be implemented on the class level to support unit resolution.&quot;</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parameter_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the symbolic representations of the coordinate system parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict of str, ~sympy.core.symbol.Symbol</span>
<span class="sd">            A dictionary mapping parameter names to their corresponding SymPy symbols.</span>
<span class="sd">            These symbols are used in all symbolic expressions defined by the coordinate system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The returned dictionary is a copy, so modifying it will not affect the internal state.</span>
<span class="sd">        - These symbols are created during class setup and correspond to keys in `self.parameters`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameter_symbols__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># @@ COORDINATE METHODS @@ #</span>
    <span class="c1"># These methods dictate the behavior of the coordinate system including how</span>
    <span class="c1"># coordinate conversions behave and how the coordinate system handles differential</span>
    <span class="c1"># operations.</span>
    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__construct_metric_tensor_symbol__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the metric tensor for the coordinate system.</span>

<span class="sd">        The metric tensor defines the way distances and angles are measured in the given coordinate system.</span>
<span class="sd">        It is used extensively in differential geometry and tensor calculus, particularly in transformations</span>
<span class="sd">        between coordinate systems.</span>

<span class="sd">        This method must be implemented by subclasses to specify how the metric tensor is computed.</span>
<span class="sd">        The returned matrix should contain symbolic expressions that define the metric components.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : tuple of sympy.Symbol</span>
<span class="sd">            The symbolic representations of each coordinate axis.</span>
<span class="sd">        **kwargs : dict of sympy.Symbol</span>
<span class="sd">            The symbolic representations of the coordinate system parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sp.Matrix</span>
<span class="sd">            A symbolic ``NDIM x NDIM`` matrix representing the metric tensor.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is abstract and must be overridden in derived classes.</span>
<span class="sd">        - The metric tensor is used to compute distances, gradients, and other differential operations.</span>
<span class="sd">        - In orthogonal coordinate systems, the metric tensor is diagonal.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        In a cylindrical coordinate system (r, θ, z), the metric tensor is:</span>

<span class="sd">        .. math::</span>
<span class="sd">            g_{ij} =</span>
<span class="sd">            \\begin{bmatrix}</span>
<span class="sd">            1 &amp; 0 &amp; 0 \\\\</span>
<span class="sd">            0 &amp; r^2 &amp; 0 \\\\</span>
<span class="sd">            0 &amp; 0 &amp; 1</span>
<span class="sd">            \\end{bmatrix}</span>

<span class="sd">        For a custom coordinate system, this function should return an equivalent symbolic representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@class_expression</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Dterm&quot;</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__compute_Dterm__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the D-term :math:`(1/\rho)\partial_\mu \rho` for use in</span>
<span class="sd">        computing the divergence numerically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_metric_density</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_density&quot;</span><span class="p">]</span>
        <span class="n">_axes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__axes_symbols__</span>

        <span class="k">return</span> <span class="n">compute_Dterm</span><span class="p">(</span><span class="n">_metric_density</span><span class="p">,</span> <span class="n">_axes</span><span class="p">)</span>

    <span class="nd">@class_expression</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Lterm&quot;</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__compute_Lterm__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the D-term :math:`(1/\rho)\partial_\mu \rho` for use in</span>
<span class="sd">        computing the divergence numerically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_metric_density</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;metric_density&quot;</span><span class="p">]</span>
        <span class="n">_inverse_metric_tensor</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">]</span>
        <span class="n">_axes</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__axes_symbols__</span>

        <span class="k">return</span> <span class="n">compute_Lterm</span><span class="p">(</span><span class="n">_inverse_metric_tensor</span><span class="p">,</span> <span class="n">_metric_density</span><span class="p">,</span> <span class="n">_axes</span><span class="p">)</span>

    <span class="c1"># @@ EXPRESSION METHODS @@ #</span>
    <span class="c1"># These methods allow the user to interact with derived, symbolic, and numeric expressions.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">substitute_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="n">_ExpressionType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ExpressionType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces symbolic parameters with numerical values in an expression.</span>

<span class="sd">        This method takes a symbolic expression that may include parameter symbols and</span>
<span class="sd">        substitutes them with the numerical values assigned at instantiation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression : str or sympy expression</span>
<span class="sd">            The symbolic expression to substitute parameter values into.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sympy expression</span>
<span class="sd">            The expression with parameters replaced by their numeric values.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Only parameters defined in ``self.__parameters__`` are substituted.</span>
<span class="sd">        - If an expression does not contain any parameters, it remains unchanged.</span>
<span class="sd">        - This method is useful for obtaining instance-specific symbolic representations.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            from sympy import Symbol</span>
<span class="sd">            expr = Symbol(&#39;a&#39;) * Symbol(&#39;x&#39;)</span>
<span class="sd">            coords = MyCoordinateSystem(a=3)</span>
<span class="sd">            print(coords.substitute_expression(expr))</span>
<span class="sd">            3*x</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Substitute in each of the parameter values.</span>
        <span class="n">_params</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">sympify</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">_params</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lambdify_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">Basic</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a symbolic expression into a callable function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression : :py:class:`str` or sp.Basic</span>
<span class="sd">            The symbolic expression to lambdify.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable</span>
<span class="sd">            A callable numerical function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lambdify_expression</span><span class="p">(</span>
            <span class="n">expression</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__axes_symbols__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_class_expression</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expression_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ExpressionType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a derived expression for this coordinate system by name. The returned expression will include</span>
<span class="sd">        symbolic representations for all the axes as well as the parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression_name : str</span>
<span class="sd">            The name of the symbolic expression to retrieve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The requested symbolic expression.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the requested expression name does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate that the expression actually exists. If it does not, return an error indicating</span>
        <span class="c1"># that the expression isn&#39;t known.</span>
        <span class="c1"># Check for the metric first</span>
        <span class="k">if</span> <span class="n">expression_name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">:</span>
            <span class="n">_class_expr</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Coordinate system </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> doesn&#39;t have an expression &#39;</span><span class="si">{</span><span class="n">expression_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If the expression hasn&#39;t been loaded at the class level yet, we need to execute that</span>
        <span class="c1"># code to ensure that it does get loaded.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_class_expr</span><span class="p">,</span> <span class="nb">classmethod</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">pg_log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Retrieving symbolic expression `</span><span class="si">{</span><span class="n">expression_name</span><span class="si">}</span><span class="s2">` for class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
                <span class="c1"># Extract the class method and evaluate it to get the symbolic expression.</span>
                <span class="n">_class_expr_function</span> <span class="o">=</span> <span class="n">_class_expr</span><span class="o">.</span><span class="vm">__func__</span>  <span class="c1"># The underlying callable.</span>
                <span class="n">_class_expr</span> <span class="o">=</span> <span class="n">_class_expr_function</span><span class="p">(</span>
                    <span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">__axes_symbols__</span><span class="p">,</span> <span class="o">**</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameter_symbols__</span>
                <span class="p">)</span>

                <span class="c1"># Now simplify the expression.</span>
                <span class="n">_class_expr</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">_class_expr</span><span class="p">)</span>

                <span class="c1"># Now register in the expression dictionary.</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_class_expr</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CoordinateClassException</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to evaluate class expression </span><span class="si">{</span><span class="n">expression_name</span><span class="si">}</span><span class="s2"> (linked to </span><span class="si">{</span><span class="n">_class_expr</span><span class="o">.</span><span class="vm">__func__</span><span class="si">}</span><span class="s2">) due to&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; an error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="c1"># Now that the expression is certainly loaded, we can simply return the class-level expression.</span>
        <span class="k">return</span> <span class="n">_class_expr</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_class_expressions</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List the available coordinate system expressions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            The list of available class-level expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_class_expression</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">expression_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if the coordinate system has a specific expression registered to it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression_name: str</span>
<span class="sd">            The name of the symbolic expression to check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the symbolic expression is registered at the class level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">expression_name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__class_expressions__</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ExpressionType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves an instance-specific symbolic expression.</span>

<span class="sd">        Unlike :py:meth:`get_class_expression`, this method returns an expression where</span>
<span class="sd">        parameter values have been substituted. The returned expression retains symbolic</span>
<span class="sd">        representations of coordinate axes but replaces any parameter symbols with their</span>
<span class="sd">        numerical values assigned at instantiation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression_name : str</span>
<span class="sd">            The name of the symbolic expression to retrieve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The symbolic expression with parameters substituted.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the expression is not found at either the instance or class level.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method allows retrieving instance-specific symbolic expressions where numerical</span>
<span class="sd">          parameter values have been applied.</span>
<span class="sd">        - If an expression has not been previously computed for the instance, it is derived</span>
<span class="sd">          from the class-level expression and stored in ``self.__expressions__``.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            class CylindricalCoordinateSystem(CoordinateSystemBase):</span>
<span class="sd">                __AXES__ = [&#39;r&#39;, &#39;theta&#39;, &#39;z&#39;]</span>
<span class="sd">                __PARAMETERS__ = {&#39;scale&#39;: 2}</span>

<span class="sd">                @staticmethod</span>
<span class="sd">                def __construct_metric_tensor_symbol__(*args, **kwargs):</span>
<span class="sd">                    return sp.Matrix([[1, 0, 0], [0, args[0]**2, 0], [0, 0, 1]])</span>

<span class="sd">            coords = CylindricalCoordinateSystem(scale=3)</span>
<span class="sd">            expr = coords.get_expression(&#39;metric_tensor&#39;)</span>
<span class="sd">            print(expr)</span>
<span class="sd">            Matrix([</span>
<span class="sd">                [1, 0, 0],</span>
<span class="sd">                [0, r**2, 0],</span>
<span class="sd">                [0, 0, 1]</span>
<span class="sd">            ])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Look for the expression in the instance directory first.</span>
        <span class="k">if</span> <span class="n">expression_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span>

        <span class="c1"># We couldn&#39;t find it in the instance directory, now we try to fetch it</span>
        <span class="c1"># and perform a substitution.</span>
        <span class="k">if</span> <span class="n">expression_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="p">:</span>
            <span class="n">_substituted_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">substitute_expression</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_class_expression</span><span class="p">(</span><span class="n">expression_name</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_substituted_expression</span>
            <span class="k">return</span> <span class="n">_substituted_expression</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Coordinate system </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> doesn&#39;t have an expression &#39;</span><span class="si">{</span><span class="n">expression_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_expression</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">expression_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">expression</span><span class="p">:</span> <span class="n">_ExpressionType</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a symbolic expression at the instance level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression_name : str</span>
<span class="sd">            The name of the symbolic expression to register.</span>
<span class="sd">        expression : sympy expression</span>
<span class="sd">            The symbolic expression to register.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, overwrite an existing expression with the same name. Defaults to False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the expression name already exists and `overwrite` is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">expression_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expression &#39;</span><span class="si">{</span><span class="n">expression_name</span><span class="si">}</span><span class="s2">&#39; already exists. Use `overwrite=True` to replace it.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">expression</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">list_expressions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List the available instance-level expressions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            The list of available class-level expressions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class_expressions__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__expressions__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">has_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a symbolic expression is registered at the instance level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression_name: str</span>
<span class="sd">            The name of the symbolic expression to check.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            ``True`` if the symbolic expression is registered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">expression_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_expressions</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_numeric_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expression_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve a numerically evaluable version of a coordinate system expression given the expression name.</span>

<span class="sd">        This method will search through the numerical expressions already generated in the instance and return the</span>
<span class="sd">        numerical version if it finds it. It will also search through all the symbolic expressions and try to perform</span>
<span class="sd">        a conversion to numerical.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expression_name : str</span>
<span class="sd">            The name of the symbolic expression to retrieve or convert.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable</span>
<span class="sd">            A numeric (callable) version of the symbolic expression.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If the symbolic expression is not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">expression_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">:</span>
            <span class="n">symbolic_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_expression</span><span class="p">(</span><span class="n">expression_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lambdify_expression</span><span class="p">(</span>
                <span class="n">symbolic_expression</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__numerical_expressions__</span><span class="p">[</span><span class="n">expression_name</span><span class="p">]</span>

    <span class="c1"># @@ CONVERSION @@ #</span>
    <span class="c1"># Perform conversions to / from cartesian coordinates.</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_native_to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_convert_cartesian_to_native</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, Eliza Diggins.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>