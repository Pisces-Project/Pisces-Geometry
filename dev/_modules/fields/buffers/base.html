
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>fields.buffers.base &#8212; Pisces-Geometry  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/fields/buffers/base';</script>
    <link rel="icon" href="../../../_static/pm_favicon.svg"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Pisces-Geometry  documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started.html">
    Quick-start Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started.html">
    Quick-start Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api.html">
    API
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">fields.buffers.base</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for fields.buffers.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Buffer base classes and buffer resolution support.</span>

<span class="sd">This module defines the core :py:class:`BufferBase` class, which all buffer types must subclass,</span>
<span class="sd">and the metaclass :class:`_BufferMeta`, which manages registration into the</span>
<span class="sd">default buffer registry and enforces interface correctness.</span>

<span class="sd">The buffer system abstracts different data storage backends (NumPy, unyt, HDF5, etc.)</span>
<span class="sd">behind a common interface so that field operations can delegate storage concerns. Novel buffer</span>
<span class="sd">classes can be implemented with relative ease vis-a-vis subclasses of :py:class:`BufferBase`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">unyt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ArrayLike</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.fields.mixins._generic</span><span class="w"> </span><span class="kn">import</span> <span class="n">NumpyArithmeticMixin</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.registry</span><span class="w"> </span><span class="kn">import</span> <span class="n">__DEFAULT_BUFFER_REGISTRY__</span><span class="p">,</span> <span class="n">BufferRegistry</span>


<span class="c1"># ========================================= #</span>
<span class="c1"># Buffer Meta Class                         #</span>
<span class="c1"># ========================================= #</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_BufferMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Metaclass for all Pisces buffer classes.</span>

<span class="sd">    This metaclass automatically registers concrete buffer classes with the</span>
<span class="sd">    global `__DEFAULT_BUFFER_REGISTRY__` if they are not abstract and define</span>
<span class="sd">    the `__can_resolve__` attribute.</span>

<span class="sd">    Expected class attributes:</span>
<span class="sd">    ---------------------------</span>
<span class="sd">    - __is_abc__ : bool</span>
<span class="sd">        Whether the class is abstract. If True, registration is skipped.</span>

<span class="sd">    - __can_resolve__ : List[Type] or None</span>
<span class="sd">        A list of array-like types (e.g. `np.ndarray`, `unyt_array`) that this buffer can wrap.</span>
<span class="sd">        Must be defined on all concrete buffer classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Create the generic class object with a call to super().</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Extract the class flags and use them to determine the triaging</span>
        <span class="c1"># behavior.</span>
        <span class="n">is_abstract</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__is_abc__&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_abstract</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span>

        <span class="c1"># Validate the __can_resolve__ attribute. This requires managing</span>
        <span class="c1"># the various possibly typing conventions.</span>
        <span class="n">can_resolve</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;__can_resolve__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">can_resolve</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Concrete buffer subclass &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; must define &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;`__can_resolve__` (a type or iterable of types).&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Accept single type or iterable of types</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">can_resolve</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">can_resolve</span> <span class="o">=</span> <span class="p">(</span><span class="n">can_resolve</span><span class="p">,)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">can_resolve</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.__can_resolve__&#39; must be a type or an iterable of types, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got object of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">can_resolve</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Ensure every entry is itself a &#39;type&#39;</span>
        <span class="n">bad_entries</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">can_resolve</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">bad_entries</span><span class="p">:</span>
            <span class="n">bad_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">bad_entries</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;All entries in &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">.__can_resolve__&#39; must be types; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;found invalid entries: </span><span class="si">{</span><span class="n">bad_str</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Store back the normalised tuple so the rest of the code can rely on it</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__can_resolve__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">can_resolve</span><span class="p">)</span>

        <span class="n">__DEFAULT_BUFFER_REGISTRY__</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span>


<span class="c1"># ========================================= #</span>
<span class="c1"># Abstract Base Class (BufferBase)          #</span>
<span class="c1"># ========================================= #</span>
<div class="viewcode-block" id="BufferBase">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.html#fields.buffers.base.BufferBase">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BufferBase</span><span class="p">(</span><span class="n">NumpyArithmeticMixin</span><span class="p">,</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_BufferMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for Pisces Geometry-compatible field buffers.</span>

<span class="sd">    This interface abstracts data storage details so that field operations can be</span>
<span class="sd">    performed uniformly regardless of whether the underlying data is NumPy, unyt, HDF5, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># === Class Attributes === #</span>
    <span class="c1"># These attributes configure behavior and registration rules for buffer subclasses.</span>
    <span class="c1"># All **concrete** buffer classes MUST define these attributes explicitly.</span>
    <span class="c1">#</span>
    <span class="c1"># Abstract classes may omit them by setting __is_abc__ = True.</span>
    <span class="n">__is_abc__</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Marks the class as abstract (not to be registered).</span>
<span class="sd">    Set to `False` on all concrete subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__can_resolve__</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list of data types (e.g., [np.ndarray, unyt_array]) that this buffer</span>
<span class="sd">    can wrap via the `coerce()` method.</span>

<span class="sd">    This is required for automatic buffer resolution.</span>
<span class="sd">    Must be defined on concrete subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__core_array_types__</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Type(s) that the buffer expects to wrap in its constructor (`__init__`).</span>

<span class="sd">    Used by `__validate_array_object__()` to ensure the input array object is valid.</span>
<span class="sd">    Typically set to `np.ndarray`, `unyt_array`, or `h5py.Dataset`.</span>
<span class="sd">    If `None`, no validation is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__representation_types__</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The type(s) that can be represented with this buffer class.</span>

<span class="sd">    Currently only used when performing tests. Should still be implemented</span>
<span class="sd">    in all subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__resolution_priority__</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optional integer priority used during buffer resolution.</span>

<span class="sd">    Lower numbers are prioritized first when resolving unknown array-like inputs.</span>
<span class="sd">    Used by buffer registries that support resolution ordering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The priority of the buffer class in numpy operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__array_function_dispatch__</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># Internally defined methods.</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_dim</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">),</span>
        <span class="c1"># Internally defined properties.</span>
        <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="o">**</span><span class="n">__</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
        <span class="c1"># Simple redirect transformations.</span>
        <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">,</span> <span class="p">[</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">,</span> <span class="p">[</span><span class="n">reps</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">),</span>
    <span class="p">}</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    `__array_function_dispatch__` is a dictionary which can optionally map</span>
<span class="sd">    NumPy callables to internal implementations to allow overriding of default behavior.</span>

<span class="sd">    By default, when a NumPy function (non ufunc) is called on a Buffer, the buffer</span>
<span class="sd">    is stripped and the operation occurs on the underlying representation. If a callable</span>
<span class="sd">    is specified here, then `__array_function__()` will catch the redirect and</span>
<span class="sd">    triage accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># === Initialization === #</span>
    <span class="c1"># The initialization procedure should be meta stable</span>
    <span class="c1"># in the sense that it always behaves the same way: __init__</span>
    <span class="c1"># requires a pre-coerced type and simply checks for type compliance.</span>
    <span class="c1"># Other methods can be used for more adaptive behavior.</span>
<div class="viewcode-block" id="BufferBase.__init__">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.__init__.html#fields.buffers.base.BufferBase.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_object</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize a buffer from a validated array-like object.</span>

<span class="sd">        This constructor assumes that the input is already fully compatible with the</span>
<span class="sd">        expected core array type for this buffer class (e.g., :py:class:`numpy.ndarray`, :py:class:`unyt.unyt_array`, etc.).</span>
<span class="sd">        No validation or coercion of the data is performed beyond checking its type.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This method does **not** attempt to coerce or sanitize the input array.</span>
<span class="sd">            If you pass an incompatible or incorrect array-like object, a ``TypeError``</span>
<span class="sd">            will be raised. For flexible or user-facing buffer construction, use</span>
<span class="sd">            :meth:`from_array` or :meth:`coerce` instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array_object : ArrayLike</span>
<span class="sd">            A pre-validated, backend-specific array object that will be wrapped</span>
<span class="sd">            by this buffer. Must be an instance of the class’s ``__core_array_types__``,</span>
<span class="sd">            if that attribute is defined.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the array does not match the expected core type(s).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        BufferBase.from_array : Preferred interface for safe buffer construction.</span>
<span class="sd">        BufferBase.coerce : Coerces arbitrary array-like objects into valid buffers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">array_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__validate_array_object__</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__validate_array_object__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate that the wrapped array object is of the expected core type.</span>

<span class="sd">        This method checks that the buffer&#39;s internal array (``__array_object__``)</span>
<span class="sd">        matches the type or types declared in ``__core_array_types__``. If this condition</span>
<span class="sd">        fails, a `TypeError` is raised.</span>

<span class="sd">        This method may be extended in subclasses to include stricter or domain-specific</span>
<span class="sd">        validation logic.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the internal array object does not match any type in ``__core_array_types__``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">core_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">__core_array_types__</span>

        <span class="c1"># No validation requested → simply return.</span>
        <span class="k">if</span> <span class="n">core_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Accept a single type or an iterable of types.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">core_types</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">core_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">core_types</span><span class="p">,)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">,</span> <span class="n">core_types</span><span class="p">):</span>
            <span class="n">expected_names</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">core_types</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> expects array of type </span><span class="si">{</span><span class="n">expected_names</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Use &#39;.from_array()&#39; or &#39;.coerce()&#39; if conversion is possible.&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="BufferBase.from_array">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.from_array.html#fields.buffers.base.BufferBase.from_array">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_array</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to construct a new buffer instance from an array-like object.</span>

<span class="sd">        This method is the canonical entry point for converting arbitrary array-like</span>
<span class="sd">        inputs into a buffer of this type. It behaves similarly to a cast operation,</span>
<span class="sd">        and will coerce the input as needed to match the expected backend format</span>
<span class="sd">        (e.g., :class:`~numpy.ndarray`, class:`~unyt.unyt_array`, etc.).</span>

<span class="sd">        The method should be overridden in subclasses to handle type conversion,</span>
<span class="sd">        unit attachment, memory layout, or any other backend-specific behavior.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj : array-like</span>
<span class="sd">            Input data to be wrapped. This can be any object that is compatible with</span>
<span class="sd">            the backend&#39;s array casting rules—such as lists, tuples,</span>
<span class="sd">            NumPy arrays, unyt arrays, or backend-native types (e.g., HDF5 datasets).</span>
<span class="sd">            The input will be coerced into a backend-compatible array before being</span>
<span class="sd">            wrapped in a buffer instance. If coercion fails, a `TypeError` will be raised.</span>
<span class="sd">        dtype : data-type, optional</span>
<span class="sd">            Desired data type of the resulting array. If not specified, the type is</span>
<span class="sd">            inferred from `obj`.</span>
<span class="sd">        *args, **kwargs :</span>
<span class="sd">            Additional arguments to customize the construction. These may include:</span>

<span class="sd">            - `units` for unit-aware buffers</span>
<span class="sd">            - `order`, `copy`, or `device` for backend-specific configuration</span>
<span class="sd">            - Any arguments accepted by the backend constructor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A new buffer instance wrapping the coerced array.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the input cannot be coerced into a valid array for this backend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


    <span class="c1"># === Resolution Logic === #</span>
<div class="viewcode-block" id="BufferBase.can_handle">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.can_handle.html#fields.buffers.base.BufferBase.can_handle">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">can_handle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``True`` if *obj* can be wrapped by this buffer class.</span>

<span class="sd">        The test is simply ``isinstance(obj, t)`` for at least one *t* in</span>
<span class="sd">        ``__can_resolve__``.  Subclasses should set ``__can_resolve__`` to either:</span>

<span class="sd">        - a single type  (e.g. ``np.ndarray``), or</span>
<span class="sd">        - an iterable/tuple of types (e.g. ``(np.ndarray, np.ma.MaskedArray)``).</span>

<span class="sd">        If a subclass leaves ``__can_resolve__`` as ``NotImplemented`` the</span>
<span class="sd">        method always returns ``False`` so the registry can skip it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">can</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__can_resolve__</span>

        <span class="k">if</span> <span class="n">can</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Accept both a single type and an iterable of types.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">can</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">can</span> <span class="o">=</span> <span class="p">(</span><span class="n">can</span><span class="p">,)</span>

        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">can</span><span class="p">))</span></div>


<div class="viewcode-block" id="BufferBase.can_handle_list">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.can_handle_list.html#fields.buffers.base.BufferBase.can_handle_list">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">can_handle_list</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of type names that this buffer can wrap.</span>

<span class="sd">        This method provides a human-readable list of supported types defined in</span>
<span class="sd">        ``__can_resolve__``. It is typically used for debugging, diagnostics,</span>
<span class="sd">        or generating documentation for supported backends.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            The names of the supported types (e.g., ``[&#39;ndarray&#39;, &#39;unyt_array&#39;]``).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If ``__can_resolve__`` is not defined or not iterable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__can_resolve__</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__can_resolve__</span><span class="p">]</span></div>


    <span class="c1"># === Required Constructors === #</span>
<div class="viewcode-block" id="BufferBase.zeros">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.zeros.html#fields.buffers.base.BufferBase.zeros">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zeros</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer filled with zeros.</span>

<span class="sd">        This method constructs a new backend-specific array of the given shape,</span>
<span class="sd">        filled with zeros, and wraps it in a buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The desired shape of the buffer, including both grid and element dimensions.</span>

<span class="sd">        *args :</span>
<span class="sd">            Positional arguments passed through to the array constructor (backend-specific).</span>

<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments passed to the array constructor. May include:</span>

<span class="sd">            - ``dtype``: Data type of the array (e.g., ``float32``, ``int64``)</span>
<span class="sd">            - ``units``: Units of the array (if supported)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer instance wrapping a zero-initialized array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BufferBase.empty">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.empty.html#fields.buffers.base.BufferBase.empty">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer with a window into unaltered memory.</span>

<span class="sd">        This method constructs a new backend-specific array of the given shape, and wraps it in a buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The desired shape of the buffer, including both grid and element dimensions.</span>

<span class="sd">        *args :</span>
<span class="sd">            Positional arguments passed through to the array constructor (backend-specific).</span>

<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments passed to the array constructor. May include:</span>

<span class="sd">            - ``dtype``: Data type of the array (e.g., ``float32``, ``int64``)</span>
<span class="sd">            - ``units``: Units of the array (if supported)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer instance wrapping an uninitialized array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BufferBase.ones">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.ones.html#fields.buffers.base.BufferBase.ones">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ones</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer filled with ones.</span>

<span class="sd">        Constructs a backend-compatible array filled with ones and wraps it</span>
<span class="sd">        in a buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The desired shape of the buffer, including both grid and element dimensions.</span>

<span class="sd">        *args :</span>
<span class="sd">            Positional arguments forwarded to the array constructor.</span>

<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments passed to the array constructor. May include:</span>

<span class="sd">            - ``dtype``: Data type of the array (e.g., ``float32``, ``int64``)</span>
<span class="sd">            - ``units``: Units of the array (if supported)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer instance wrapping a one-filled array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BufferBase.full">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.full.html#fields.buffers.base.BufferBase.full">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer filled with a constant value.</span>

<span class="sd">        This method builds a backend-specific array of the given shape and fills it</span>
<span class="sd">        with the provided `fill_value`. The resulting array is wrapped and returned</span>
<span class="sd">        as a buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            The desired shape of the buffer (grid + element dimensions).</span>

<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments passed to the backend constructor.</span>

<span class="sd">        fill_value : float, default 0.0</span>
<span class="sd">            The constant value to use for every element in the array.</span>

<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments passed to the array constructor. May include:</span>

<span class="sd">            - ``dtype``: Data type of the array (e.g., ``float32``, ``int64``)</span>
<span class="sd">            - ``units``: Units of the array (if supported)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer instance wrapping a constant-filled array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="BufferBase.zeros_like">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.zeros_like.html#fields.buffers.base.BufferBase.zeros_like">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zeros_like</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer filled with zeros and matching the shape of another buffer.</span>

<span class="sd">        This method delegates to the class&#39;s `zeros` constructor, using the shape of</span>
<span class="sd">        the provided buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : BufferBase</span>
<span class="sd">            The buffer whose shape will be used.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `zeros`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `zeros`. Common options include:</span>
<span class="sd">            - `dtype` : data type of the buffer</span>
<span class="sd">            - `units` : physical units (for unit-aware buffers)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer filled with zeros and the same shape as `other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.ones_like">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.ones_like.html#fields.buffers.base.BufferBase.ones_like">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ones_like</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer filled with ones and matching the shape of another buffer.</span>

<span class="sd">        This method delegates to the class&#39;s `ones` constructor, using the shape of</span>
<span class="sd">        the provided buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : BufferBase</span>
<span class="sd">            The buffer whose shape will be used.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `ones`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `ones`. Common options include:</span>
<span class="sd">            - `dtype` : data type of the buffer</span>
<span class="sd">            - `units` : physical units (for unit-aware buffers)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer filled with ones and the same shape as `other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.full_like">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.full_like.html#fields.buffers.base.BufferBase.full_like">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_like</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer filled with a constant value and matching the shape of another buffer.</span>

<span class="sd">        This method delegates to the class&#39;s `full` constructor, using the shape of</span>
<span class="sd">        the provided buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : BufferBase</span>
<span class="sd">            The buffer whose shape will be used.</span>
<span class="sd">        fill_value : scalar or quantity, default 0.0</span>
<span class="sd">            The constant value to fill the buffer with.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `full`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `full`. Common options include:</span>
<span class="sd">            - `dtype` : data type of the buffer</span>
<span class="sd">            - `units` : physical units (for unit-aware buffers)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer filled with the specified value and the same shape as `other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.empty_like">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.empty_like.html#fields.buffers.base.BufferBase.empty_like">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">empty_like</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new buffer allocation matching the shape of another buffer.</span>

<span class="sd">        This method delegates to the class&#39;s `empty` constructor, using the shape of</span>
<span class="sd">        the provided buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : BufferBase</span>
<span class="sd">            The buffer whose shape will be used.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `empty`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `empty`. Common options include:</span>
<span class="sd">            - `dtype` : data type of the buffer</span>
<span class="sd">            - `units` : physical units (for unit-aware buffers)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            An unallocated buffer like `other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1"># === NumPy-Like Interface === #</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward semantics for numpy operations on arrays.</span>

<span class="sd">        The heuristic of buffer numpy interaction is that we perform the operations</span>
<span class="sd">        between the `RepresentationType`s of each of the input buffers. Our returned value</span>
<span class="sd">        is determined by the `RepresentationType`s of each of the input buffers.</span>

<span class="sd">        If `out` is specified, then an attempt is made to place the result into the relevant</span>
<span class="sd">        buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert all of the inputs into their corresponding representation type. This</span>
        <span class="c1"># will break any lazy-loading behavior in the inputs and convert everything to</span>
        <span class="c1"># numpy compatible types.</span>
        <span class="n">core_inputs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">x</span><span class="o">.</span><span class="n">as_repr</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">inputs</span>
        <span class="p">]</span>

        <span class="c1"># Handle `out`: We fetch the out kwarg, check if it is a buffer type, and then</span>
        <span class="c1"># attempt to place the result into the buffer by specifying out=self.__array_object__.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Normalize to a tuple for uniform processing</span>
            <span class="n">is_tuple</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="n">out_tuple</span> <span class="o">=</span> <span class="n">out</span> <span class="k">if</span> <span class="n">is_tuple</span> <span class="k">else</span> <span class="p">(</span><span class="n">out</span><span class="p">,)</span>

            <span class="c1"># Unwrap buffers</span>
            <span class="n">unwrapped_out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">o</span><span class="o">.</span><span class="n">as_core</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="k">else</span> <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out_tuple</span>
            <span class="p">)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrapped_out</span> <span class="k">if</span> <span class="n">is_tuple</span> <span class="k">else</span> <span class="n">unwrapped_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Apply the ufunc</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">core_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="c1"># Pass result through based on the typing.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">out_tuple</span>
            <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">out_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># out was not specified, we simply return the unwrapped behavior.</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="o">*</span><span class="n">core_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override NumPy high-level functions for BufferBase.</span>

<span class="sd">        The heuristic for this behavior is to simply delegate operations to</span>
<span class="sd">        the buffer representation unless there is a specific override in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for custom forwarding implementations via</span>
        <span class="c1"># the __array_functions_dispatch__.</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">):</span>
            <span class="c1"># Fetch the dispatch and check for the override of</span>
            <span class="c1"># this function.</span>
            <span class="n">redirect_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;__array_function_dispatch__&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">redirect_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># We have a redirection, we now delegate to that.</span>
                <span class="k">return</span> <span class="n">redirect_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># No valid dispatch found. We now strip the args down and</span>
        <span class="c1"># pass through without and further alterations.</span>
        <span class="n">unwrapped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">a</span><span class="o">.</span><span class="n">as_repr</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span>
        <span class="p">)</span>
        <span class="n">unwrapped_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">_k</span><span class="p">:</span> <span class="n">_v</span><span class="o">.</span><span class="n">as_core</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span> <span class="k">else</span> <span class="n">_v</span>
            <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">unwrapped_args</span><span class="p">,</span> <span class="o">**</span><span class="n">unwrapped_kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, dtype=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the length of the buffer along its first axis.</span>

<span class="sd">        This is equivalent to `len(buffer.as_core())`, and will raise an error</span>
<span class="sd">        if the buffer has zero dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The size of the first dimension.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If the buffer is scalar (zero-dimensional).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an iterator over the outermost dimension of the buffer.</span>

<span class="sd">        This allows iteration like `for row in buffer`, where each row is returned</span>
<span class="sd">        as a slice of the buffer. Slices are returned as NumPy arrays or `unyt_array`,</span>
<span class="sd">        depending on the underlying backend.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Iterator[Any]</span>
<span class="sd">            An iterator over the first dimension of the wrapped array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for equality with another buffer or array-like object.</span>

<span class="sd">        This uses NumPy-style broadcasting and comparison. If `other` is not a buffer,</span>
<span class="sd">        it will be coerced to an array for comparison. This performs an *element-wise*</span>
<span class="sd">        comparison and returns a boolean scalar only if the entire contents are equal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Any</span>
<span class="sd">            Another buffer or array-like object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if the contents are equal (element-wise). False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_core</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span>

    <span class="c1"># === Public Properties === #</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape of the underlying array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Physical units attached to the buffer data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unyt.unit_registry.Unit</span>
<span class="sd">            The physical units associated with this buffer’s array values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@units</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Class </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not support units.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of elements.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of dimensions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="o">.</span><span class="n">ndim</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_units</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the buffer carries unit metadata.</span>

<span class="sd">        This returns `True` if the buffer has an attached physical unit</span>
<span class="sd">        (i.e., `self.units` is not `None`), and `False` otherwise.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            `True` if the buffer has units, `False` if it is unitless.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Data type of the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">c</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for `as_core()`.</span>

<span class="sd">        This returns the raw backend-specific array (e.g., `np.ndarray`, `unyt_array`, or HDF5 dataset),</span>
<span class="sd">        without applying any conversions or wrapping. Useful for advanced users who want direct access.</span>

<span class="sd">        Equivalent to: `self.as_core()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayLike</span>
<span class="sd">            The backend-native data structure stored in this buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for `as_array()`.</span>

<span class="sd">        This returns the buffer data as a plain `numpy.ndarray`, stripping any units or backend context.</span>

<span class="sd">        Equivalent to: `self.as_array()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The numerical contents of the buffer as a standard array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shorthand for `as_unyt_array()`.</span>

<span class="sd">        This returns the buffer data as a `unyt_array`, preserving any attached physical units.</span>

<span class="sd">        Equivalent to: `self.as_unyt_array()`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unyt.unyt_array</span>
<span class="sd">            Unit-tagged array of the buffer&#39;s data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_unyt_array</span><span class="p">()</span>

<div class="viewcode-block" id="BufferBase.as_array">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.as_array.html#fields.buffers.base.BufferBase.as_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the buffer as a NumPy array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array__</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.as_unyt_array">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.as_unyt_array.html#fields.buffers.base.BufferBase.as_unyt_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_unyt_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the buffer contents into a `unyt_array` with attached units.</span>

<span class="sd">        This method returns the contents of the buffer as a `unyt.unyt_array`,</span>
<span class="sd">        using the physical units defined by the buffer (via the `units` property).</span>
<span class="sd">        This is particularly useful when working with buffers that store physical</span>
<span class="sd">        quantities and need to interoperate with unit-aware calculations.</span>

<span class="sd">        If the buffer has no defined units (`self.units` is `None`), the array</span>
<span class="sd">        is returned as a dimensionless `unyt_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unyt.unyt_array</span>
<span class="sd">            A unit-aware array representing the contents of this buffer.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        BufferBase.units : The unit system attached to the buffer.</span>
<span class="sd">        BufferBase.as_array : Returns the underlying array as a NumPy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="k">return</span> <span class="n">unyt</span><span class="o">.</span><span class="n">unyt_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">(),</span> <span class="n">units</span><span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.as_core">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.as_core.html#fields.buffers.base.BufferBase.as_core">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_core</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the raw backend array object stored in this buffer.</span>

<span class="sd">        This method provides direct access to the internal array-like object</span>
<span class="sd">        (e.g., :py:class:`numpy.ndarray`, :py:class:`unyt.unyt_array`, or :py:class:`h5py.Dataset`) without any conversion</span>
<span class="sd">        or wrapping. It is useful for advanced users who need to access backend-specific</span>
<span class="sd">        methods or metadata not exposed through the generic buffer interface.</span>

<span class="sd">        Unlike :meth:`as_array`, this method returns the native format of the</span>
<span class="sd">        underlying backend, preserving units or lazy behavior if applicable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayLike</span>
<span class="sd">            The unmodified internal array object stored in the buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_object__</span></div>


<div class="viewcode-block" id="BufferBase.as_repr">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.as_repr.html#fields.buffers.base.BufferBase.as_repr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a NumPy-compatible array for use in NumPy operations.</span>

<span class="sd">        This method is used internally to provide a consistent interface for applying</span>
<span class="sd">        NumPy ufuncs and broadcasting logic across different buffer backends. It returns</span>
<span class="sd">        an array-like object that is suitable for NumPy operations such as `np.sin()`,</span>
<span class="sd">        `np.add()`, or reductions like `np.sum()`.</span>

<span class="sd">        By default, this returns the result of :meth:`as_array`, which typically coerces</span>
<span class="sd">        the internal buffer into a standard `numpy.ndarray`. Subclasses may override this</span>
<span class="sd">        method to return more specialized representations (e.g., a `unyt_array` that</span>
<span class="sd">        preserves units, or a lazily sliced `h5py.Dataset`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayLike</span>
<span class="sd">            A NumPy-operable array object, such as `numpy.ndarray`, `unyt_array`, or a</span>
<span class="sd">            backend-compatible equivalent.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        BufferBase.__array_ufunc__ : How NumPy dispatches operations on buffers.</span>
<span class="sd">        BufferBase.as_array : Returns the NumPy array representation used here by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span></div>


    <span class="c1"># ------------------------------ #</span>
    <span class="c1"># Standard Numpy Transformations #</span>
    <span class="c1"># ------------------------------ #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_numpy_transform_on_repr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">fargs</span><span class="p">,</span> <span class="n">fkwargs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a NumPy-compatible transformation to the buffer&#39;s representation.</span>

<span class="sd">        This method is used to wrap high-level NumPy functions or methods (e.g., `np.reshape`,</span>
<span class="sd">        `np.copy`, `np.squeeze`) that operate on the buffer&#39;s `as_repr()` array, which may be</span>
<span class="sd">        a NumPy array or a unit-tagged `unyt_array`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : Callable</span>
<span class="sd">            The NumPy-compatible function or method to apply.</span>
<span class="sd">        fargs : tuple</span>
<span class="sd">            Positional arguments for the function (not for `from_array`).</span>
<span class="sd">        fkwargs : dict</span>
<span class="sd">            Keyword arguments for the function (not for `from_array`).</span>
<span class="sd">        *args :</span>
<span class="sd">            Positional arguments passed to `.from_array()` after transformation.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments passed to `.from_array()` after transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A new buffer wrapping the transformed representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">repr_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_repr</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span>
            <span class="n">func</span><span class="p">(</span><span class="n">repr_view</span><span class="p">,</span> <span class="o">*</span><span class="n">fargs</span><span class="p">,</span> <span class="o">**</span><span class="n">fkwargs</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_apply_numpy_transform_on_core</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">fargs</span><span class="p">,</span> <span class="n">fkwargs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a transformation to the raw backend array (`as_core()`).</span>

<span class="sd">        This method applies the given NumPy-compatible function directly to the</span>
<span class="sd">        buffer’s raw storage (e.g., `np.ndarray`, `unyt_array`, `h5py.Dataset`),</span>
<span class="sd">        and wraps the result in a new buffer instance.</span>

<span class="sd">        This is useful when you want to preserve the underlying structure and avoid</span>
<span class="sd">        unnecessary coercion to a representation type (e.g., for memory efficiency or</span>
<span class="sd">        backend-specific manipulations).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : Callable</span>
<span class="sd">            The function or method to apply to the core array.</span>
<span class="sd">        fargs : tuple</span>
<span class="sd">            Positional arguments for the function (not for `from_array`).</span>
<span class="sd">        fkwargs : dict</span>
<span class="sd">            Keyword arguments for the function (not for `from_array`).</span>
<span class="sd">        *args :</span>
<span class="sd">            Positional arguments passed to `.from_array()` after transformation.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Keyword arguments passed to `.from_array()` after transformation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A new buffer wrapping the transformed core array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">core</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_core</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">core</span><span class="p">,</span> <span class="o">*</span><span class="n">fargs</span><span class="p">,</span> <span class="o">**</span><span class="n">fkwargs</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="BufferBase.copy">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.copy.html#fields.buffers.base.BufferBase.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a deep copy of this buffer.</span>

<span class="sd">        This creates a new buffer instance containing a copy of the underlying array data.</span>
<span class="sd">        Any units or backend metadata are preserved, and the copy is fully detached from the original.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to :meth:`from_array`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to :meth:`from_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A deep copy of the current buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">,</span> <span class="p">[],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.astype">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.astype.html#fields.buffers.base.BufferBase.astype">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this buffer with a different data type.</span>

<span class="sd">        This performs a type conversion using the underlying array and returns</span>
<span class="sd">        a new buffer of the same class with the updated `dtype`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data-type</span>
<span class="sd">            The target data type for the returned array.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `from_array`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `astype()` and `from_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A new buffer instance with the specified data type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_repr</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.reshape">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.reshape.html#fields.buffers.base.BufferBase.reshape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a reshaped copy of this buffer.</span>

<span class="sd">        This reshapes the buffer into a new shape and returns a new buffer instance.</span>
<span class="sd">        The reshaping is done using the NumPy-compatible view returned by `as_repr()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple of int</span>
<span class="sd">            Target shape for the new buffer.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `from_array`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `from_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A new buffer with reshaped data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">,</span> <span class="p">[</span><span class="n">shape</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.transpose">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.transpose.html#fields.buffers.base.BufferBase.transpose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns this buffer with axes transposed. See :func:`numpy.transpose`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : tuple or list of ints, optional</span>
<span class="sd">            If specified, it must be a tuple or list which contains a permutation</span>
<span class="sd">            of [0, 1, ..., N-1] where N is the number of axes of `self`. Negative</span>
<span class="sd">            indices can also be used to specify axes. The i-th axis of the returned</span>
<span class="sd">            array will correspond to the axis numbered ``axes[i]`` of the input.</span>
<span class="sd">            If not specified, defaults to ``range(self.ndim)[::-1]``, which reverses</span>
<span class="sd">            the order of the axes.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `from_array`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `from_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A new transposed buffer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">,</span> <span class="p">[</span><span class="n">axes</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.flatten">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.flatten.html#fields.buffers.base.BufferBase.flatten">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a flattened 1D view of this buffer.</span>

<span class="sd">        This flattens the buffer using the specified memory layout and returns a new buffer instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {&#39;C&#39;,&#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>

<span class="sd">            The elements of `a` are read using this index order. &#39;C&#39; means</span>
<span class="sd">            to index the elements in row-major, C-style order,</span>
<span class="sd">            with the last axis index changing fastest, back to the first</span>
<span class="sd">            axis index changing slowest.  &#39;F&#39; means to index the elements</span>
<span class="sd">            in column-major, Fortran-style order, with the</span>
<span class="sd">            first index changing fastest, and the last index changing</span>
<span class="sd">            slowest. Note that the &#39;C&#39; and &#39;F&#39; options take no account of</span>
<span class="sd">            the memory layout of the underlying array, and only refer to</span>
<span class="sd">            the order of axis indexing.  &#39;A&#39; means to read the elements in</span>
<span class="sd">            Fortran-like index order if `a` is Fortran *contiguous* in</span>
<span class="sd">            memory, C-like order otherwise.  &#39;K&#39; means to read the</span>
<span class="sd">            elements in the order they occur in memory, except for</span>
<span class="sd">            reversing the data when strides are negative.  By default, &#39;C&#39;</span>
<span class="sd">            index order is used.</span>

<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `from_array`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `from_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A contiguous 1-D array of the same subtype as `self`,</span>
<span class="sd">            with shape ``(self.size,)``.</span>
<span class="sd">            Note that matrices are special cased for backward compatibility,</span>
<span class="sd">            if `self` is a matrix, then y is a 1-D ndarray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">as_repr</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.squeeze">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.squeeze.html#fields.buffers.base.BufferBase.squeeze">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove axes of length one from `self`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : None or int or tuple of ints, optional</span>
<span class="sd">            Selects a subset of the entries of length one in the</span>
<span class="sd">            shape. If an axis is selected with shape entry greater than</span>
<span class="sd">            one, an error is raised.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `from_array`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `from_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            The input buffer, but with all or a subset of the</span>
<span class="sd">            dimensions of length 1 removed. This is always `self` itself</span>
<span class="sd">            or a view into `self`. Note that if all axes are squeezed,</span>
<span class="sd">            the result is a 0d array and not a scalar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">,</span> <span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.expand_dims">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.expand_dims.html#fields.buffers.base.BufferBase.expand_dims">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">expand_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the shape of an array.</span>

<span class="sd">        Insert a new axis that will appear at the `axis` position in the expanded</span>
<span class="sd">        array shape.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int or tuple of ints</span>
<span class="sd">            Position in the expanded axes where the new axis (or axes) is placed.</span>
<span class="sd">        *args :</span>
<span class="sd">            Additional positional arguments forwarded to `from_array`.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `from_array`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            A buffer with the expanded shape.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">,</span> <span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.broadcast_to">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.broadcast_to.html#fields.buffers.base.BufferBase.broadcast_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">broadcast_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Broadcast an array to a new shape.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : tuple or int</span>
<span class="sd">            The shape of the desired output array. A single integer ``i`` is interpreted</span>
<span class="sd">            as ``(i,)``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        broadcast : BufferBase</span>
<span class="sd">            A readonly view on the original array with the given shape. It is</span>
<span class="sd">            typically not contiguous. Furthermore, more than one element of a</span>
<span class="sd">            broadcasted array may refer to a single memory location.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the array is not compatible with the new shape according to NumPy&#39;s</span>
<span class="sd">            broadcasting rules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_numpy_transform_on_repr</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="p">[</span><span class="n">shape</span><span class="p">],</span> <span class="p">{},</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>


    <span class="c1"># ------------------------------ #</span>
    <span class="c1"># Unit Handling                  #</span>
    <span class="c1"># ------------------------------ #</span>
    <span class="c1"># These method supplement those above to help with</span>
    <span class="c1"># unit handling.</span>

    <span class="c1"># === Inplace unit manipulation === #</span>
<div class="viewcode-block" id="BufferBase.convert_to_units">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.convert_to_units.html#fields.buffers.base.BufferBase.convert_to_units">[docs]</a>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_to_units</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">unyt</span><span class="o">.</span><span class="n">Unit</span><span class="p">],</span> <span class="n">equivalence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this buffer&#39;s data to the specified physical units (in-place).</span>

<span class="sd">        This operation replaces the buffer&#39;s internal data with a unit-converted</span>
<span class="sd">        equivalent. It modifies the object directly.</span>

<span class="sd">        Not all buffer classes support in-place unit assignment. Subclasses that</span>
<span class="sd">        do not should override this method to raise an appropriate error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        units : str or unyt.Unit</span>
<span class="sd">            Target units to convert the data to.</span>
<span class="sd">        equivalence : str, optional</span>
<span class="sd">            Unit equivalence to apply during conversion (e.g., &quot;mass_energy&quot;).</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to the equivalence logic.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UnitConversionError</span>
<span class="sd">            If the conversion is not dimensionally consistent.</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the subclass does not support in-place unit modification.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the buffer&#39;s units are `None`, this method assigns the new units directly</span>
<span class="sd">        without modifying data. Otherwise, it performs a physical conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Cannot set units for buffer of class </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.convert_to_base">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.convert_to_base.html#fields.buffers.base.BufferBase.convert_to_base">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_to_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit_system</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">equivalence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this buffer in-place to base units for the given unit system.</span>

<span class="sd">        The base units are those defined by `unyt` for the specified unit system.</span>
<span class="sd">        This is equivalent to calling `convert_to_units` with `.get_base_equivalent()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit_system : str, optional</span>
<span class="sd">            Unit system to use for base units (e.g., &quot;mks&quot;, &quot;cgs&quot;). If not provided,</span>
<span class="sd">            defaults to MKS.</span>
<span class="sd">        equivalence : str, optional</span>
<span class="sd">            Equivalence scheme to use during the conversion (if applicable).</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to the equivalence.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UnitConversionError</span>
<span class="sd">            If the conversion is not dimensionally valid.</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If the buffer does not support unit conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_to_units</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">get_base_equivalent</span><span class="p">(</span><span class="n">unit_system</span><span class="p">),</span>
            <span class="n">equivalence</span><span class="o">=</span><span class="n">equivalence</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># === Casting Unit Manipulation === #</span>
<div class="viewcode-block" id="BufferBase.in_units">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.in_units.html#fields.buffers.base.BufferBase.in_units">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_units</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">units</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">equivalence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer_registry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">as_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">equiv_kw</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new copy of this buffer cast to the specified physical units.</span>

<span class="sd">        This method is non-destructive and returns either a new buffer or a</span>
<span class="sd">        raw unit-tagged `unyt_array`. It is the preferred way to convert units</span>
<span class="sd">        for downstream usage or manipulation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        units : str or unyt.Unit</span>
<span class="sd">            Target physical units to cast to.</span>
<span class="sd">        equivalence : str, optional</span>
<span class="sd">            Name of a supported `unyt` equivalence scheme (e.g., &quot;mass_energy&quot;).</span>
<span class="sd">        buffer_class : type, optional</span>
<span class="sd">            If provided, explicitly wrap result in this buffer class.</span>
<span class="sd">        buffer_registry : BufferRegistry, optional</span>
<span class="sd">            If resolving from array, use this registry.</span>
<span class="sd">        as_array : bool, default False</span>
<span class="sd">            If True, return a `unyt_array` instead of re-wrapping as a buffer.</span>
<span class="sd">        equiv_kw : dict, optional</span>
<span class="sd">            Keyword arguments for the equivalence function.</span>
<span class="sd">        *args, **kwargs :</span>
<span class="sd">            Passed to the buffer constructor if wrapping is performed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unyt_array or BufferBase</span>
<span class="sd">            Either a raw unit-tagged array or a new buffer with the requested units.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        UnitConversionError</span>
<span class="sd">            If the units are incompatible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cast to unyt array.</span>
        <span class="n">uarr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_unyt_array</span><span class="p">()</span>

        <span class="c1"># Cast to the correct units.</span>
        <span class="n">equiv_kw</span> <span class="o">=</span> <span class="n">equiv_kw</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="n">converted</span> <span class="o">=</span> <span class="n">uarr</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">equivalence</span><span class="o">=</span><span class="n">equivalence</span><span class="p">,</span> <span class="o">**</span><span class="n">equiv_kw</span><span class="p">)</span>

        <span class="c1"># Figure out the returning system.</span>
        <span class="k">if</span> <span class="n">as_array</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">converted</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">buffer_from_array</span><span class="p">(</span>
                <span class="n">converted</span><span class="p">,</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                <span class="n">buffer_class</span><span class="o">=</span><span class="n">buffer_class</span><span class="p">,</span>
                <span class="n">buffer_registry</span><span class="o">=</span><span class="n">buffer_registry</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.to">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.to.html#fields.buffers.base.BufferBase.to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">units</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">equivalence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer_class</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer_registry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">as_array</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new buffer (or array) with values cast to the specified units.</span>

<span class="sd">        This is a shorthand for `.in_units(...)`, and fully equivalent in functionality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        units : str or unyt.Unit</span>
<span class="sd">            Desired output units.</span>
<span class="sd">        equivalence : str, optional</span>
<span class="sd">            Optional equivalence name for converting between dimensionally different types.</span>
<span class="sd">        buffer_class : type, optional</span>
<span class="sd">            Explicit buffer type for re-wrapping.</span>
<span class="sd">        buffer_registry : BufferRegistry, optional</span>
<span class="sd">            Optional registry to use for resolution.</span>
<span class="sd">        as_array : bool, default False</span>
<span class="sd">            If True, return raw `unyt_array` instead of a buffer.</span>
<span class="sd">        *args, **kwargs :</span>
<span class="sd">            Forwarded to `.in_units`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase or unyt_array</span>
<span class="sd">            Buffer (or array) in the new units.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        in_units : Underlying method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_units</span><span class="p">(</span>
            <span class="n">units</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">equivalence</span><span class="o">=</span><span class="n">equivalence</span><span class="p">,</span>
            <span class="n">buffer_class</span><span class="o">=</span><span class="n">buffer_class</span><span class="p">,</span>
            <span class="n">buffer_registry</span><span class="o">=</span><span class="n">buffer_registry</span><span class="p">,</span>
            <span class="n">as_array</span><span class="o">=</span><span class="n">as_array</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="BufferBase.to_value">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.to_value.html#fields.buffers.base.BufferBase.to_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">units</span><span class="p">,</span>
        <span class="n">equivalence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a NumPy array of values converted to the specified physical units.</span>

<span class="sd">        This is equivalent to calling `.in_units(..., as_array=True).value`. It strips</span>
<span class="sd">        unit information and returns a plain NumPy array for interoperability.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        units : str or unyt.Unit</span>
<span class="sd">            Target units for conversion.</span>
<span class="sd">        equivalence : str, optional</span>
<span class="sd">            Equivalence name (e.g., &quot;mass_energy&quot;).</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional arguments passed to `unyt.to`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Data in the specified units, stripped of unit tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_unyt_array</span><span class="p">()</span><span class="o">.</span><span class="n">to_value</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">equivalence</span><span class="o">=</span><span class="n">equivalence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1"># === Registry Integration === #</span>
<div class="viewcode-block" id="BufferBase.resolve">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.BufferBase.resolve.html#fields.buffers.base.BufferBase.resolve">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">array_like</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">buffer_registry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;BufferRegistry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolve and instantiate a buffer subclass for an arbitrary array-like input.</span>

<span class="sd">        This method delegates to :func:`buffer_from_array`, which attempts to find</span>
<span class="sd">        a compatible buffer backend and coerce the input into it. The registry</span>
<span class="sd">        dispatch system is used unless explicitly overridden.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array_like : Any</span>
<span class="sd">            An array-like object to be wrapped as a buffer. Supported types vary depending</span>
<span class="sd">            on the registered buffer classes (e.g., `np.ndarray`, `unyt_array`, `h5py.Dataset`).</span>

<span class="sd">        buffer_registry : _BufferRegistry, optional</span>
<span class="sd">            A custom buffer registry to use for dispatch. If None (default), the global</span>
<span class="sd">            `__DEFAULT_BUFFER_REGISTRY__` will be used.</span>

<span class="sd">        *args, **kwargs : dict</span>
<span class="sd">            Additional arguments passed to the :func:`buffer_from_array` method of the resolved buffer class.</span>
<span class="sd">            These may include unit annotations, dtype specifications, HDF5 parameters, etc.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BufferBase</span>
<span class="sd">            An instance of the appropriate buffer subclass, wrapping the adapted array data.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If no compatible buffer class is found in the registry for the given object type.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        buffer_from_array : General-purpose resolution utility.</span>
<span class="sd">        BufferBase.from_array : Class-based coercion.</span>
<span class="sd">        BufferBase.coerce : Direct array conversion method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">buffer_from_array</span><span class="p">(</span>
            <span class="n">array_like</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">buffer_registry</span><span class="o">=</span><span class="n">buffer_registry</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="buffer_from_array">
<a class="viewcode-back" href="../../../_as_gen/fields.buffers.base.buffer_from_array.html#fields.buffers.base.buffer_from_array">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">buffer_from_array</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">buffer_class</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="s2">&quot;BufferBase&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">buffer_registry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;BufferRegistry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BufferBase&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a buffer from a raw array-like object.</span>

<span class="sd">    This function performs the **buffer resolution** process (see :ref:`buffers`)</span>
<span class="sd">    to determine a suitable buffer to wrap the provided object.</span>

<span class="sd">    It is the recommended high-level interface for constructing buffers when</span>
<span class="sd">    the underlying storage format is not known in advance (e.g., NumPy, unyt, HDF5).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : array-like</span>
<span class="sd">        Input data to wrap (e.g., :py:class:`list`, :py:class:`~numpy.ndarray`,</span>
<span class="sd">        :py:class:`~unyt.array.unyt_array`, :py:class:`~h5py.Dataset`, etc.).</span>

<span class="sd">        By default, the type of `obj` will be used in conjunction</span>
<span class="sd">        with `registry` to determine which buffer class is</span>
<span class="sd">        used to wrap the array. If `buffer_class` is explicitly provided,</span>
<span class="sd">        then an attempt will be made to wrap the array</span>
<span class="sd">        with that class instead (regardless of the registry).</span>
<span class="sd">    buffer_registry : ~fields.buffers.registry.BufferRegistry, optional</span>
<span class="sd">        A custom buffer registry to use for automatic resolution.</span>
<span class="sd">        If None (default), uses the global ``__DEFAULT_BUFFER_REGISTRY__``.</span>
<span class="sd">    buffer_class : :py:class:`~fields.buffers.base.BufferBase`, optional</span>
<span class="sd">        An explicit buffer class to use instead of registry resolution.</span>
<span class="sd">        If specified, the function bypasses registry lookup and directly</span>
<span class="sd">        calls :meth:`~BufferBase.from_array`.</span>
<span class="sd">    *args, **kwargs :</span>
<span class="sd">        Additional arguments forwarded to the :meth:`~BufferBase.from_array` method.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ~fields.buffers.base.BufferBase</span>
<span class="sd">        A fully constructed buffer instance wrapping the input data.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If no compatible buffer type is found in the registry (when ``buffer_class`` is not specified),</span>
<span class="sd">        or if the input is not valid for the explicitly provided ``buffer_class``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    By default, the correct buffer class is resolved vis-a-vis the registry. As such,</span>
<span class="sd">    if you simply support an array-like input, a valid buffer will be constructed:</span>

<span class="sd">    - A :py:class:`list`, :py:class:`tuple`, etc. will be interpreted as an array:</span>

<span class="sd">      &gt;&gt;&gt; from pymetric.fields.buffers.core import ArrayBuffer, UnytArrayBuffer</span>
<span class="sd">      &gt;&gt;&gt; buffer_from_array([1, 2, 3])</span>
<span class="sd">      ArrayBuffer(shape=(3,), dtype=int64)</span>

<span class="sd">    - A :py:class:`~unyt.array.unyt_array` will be interpreted as an :py:class:`~fields.buffers.core.UnytArrayBuffer`:</span>

<span class="sd">      &gt;&gt;&gt; from unyt import unyt_array</span>
<span class="sd">      &gt;&gt;&gt; from pymetric.fields.buffers.core import ArrayBuffer, UnytArrayBuffer</span>
<span class="sd">      &gt;&gt;&gt; buffer_from_array(unyt_array([1, 2, 3],units=&#39;keV&#39;))</span>
<span class="sd">      UnytArrayBuffer(shape=(3,), dtype=int64)</span>

<span class="sd">    You can also **enforce** a particular buffer class by specifying the ``buffer_class``:</span>

<span class="sd">    &gt;&gt;&gt; from pymetric.fields.buffers.core import ArrayBuffer, UnytArrayBuffer</span>
<span class="sd">    &gt;&gt;&gt; u = buffer_from_array([1, 2, 3],buffer_class=UnytArrayBuffer)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Let&#39;s look at the type and the units</span>
<span class="sd">    &gt;&gt;&gt; print(type(u), u.units)</span>
<span class="sd">    &lt;class &#39;pymetric.fields.buffers.core.UnytArrayBuffer&#39;&gt; dimensionless</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # The units can be specified in kwargs:</span>
<span class="sd">    &gt;&gt;&gt; u = buffer_from_array([1, 2, 3],buffer_class=UnytArrayBuffer, units=&#39;keV&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(type(u), u.units)</span>
<span class="sd">    &lt;class &#39;pymetric.fields.buffers.core.UnytArrayBuffer&#39;&gt; keV</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If `buffer_class` is provided, the registry is ignored.</span>
<span class="sd">    - If `buffer_class` is not provided, resolution proceeds via the registry,</span>
<span class="sd">      honoring the ``__resolution_priority__`` values of registered buffer classes.</span>
<span class="sd">    - This method is especially useful in backend-agnostic workflows, field</span>
<span class="sd">      initialization logic, or serialization pipelines.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :py:meth:`~fields.buffers.base.BufferBase.from_array`: Class-specific buffer creation method.</span>
<span class="sd">    ~fields.buffers.registry.BufferRegistry.resolve : Resolve from a specific buffer registry.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">buffer_class</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">buffer_class</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">buffer_registry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.fields.buffers.registry</span><span class="w"> </span><span class="kn">import</span> <span class="n">__DEFAULT_BUFFER_REGISTRY__</span>

        <span class="n">buffer_registry</span> <span class="o">=</span> <span class="n">__DEFAULT_BUFFER_REGISTRY__</span>
    <span class="k">return</span> <span class="n">buffer_registry</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, Eliza Diggins.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>