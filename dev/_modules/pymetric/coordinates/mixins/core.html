
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymetric.coordinates.mixins.core &#8212; Pisces-Geometry  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pymetric/coordinates/mixins/core';</script>
    <link rel="icon" href="../../../../_static/pm_favicon.svg"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Pisces-Geometry  documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../getting_started.html">
    Quick-start Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api.html">
    API
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../getting_started.html">
    Quick-start Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../api.html">
    API
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pymetric.coordinates.mixins.core</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pymetric.coordinates.mixins.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core mixin classes inherited by all coordinate system subclasses.</span>

<span class="sd">This module provides the coordinate system support for IO operations as well as</span>
<span class="sd">interactions with coordinate axes, managing and manipulating coordinate order, and</span>
<span class="sd">other supplemental methods.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sympy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sp</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.utilities.arrays</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize_index</span>

<span class="c1"># ================================== #</span>
<span class="c1"># TYPING SUPPORT                     #</span>
<span class="c1"># ================================== #</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">unyt</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.coordinates.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">_CoordinateSystemBase</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.coordinates.mixins._typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
        <span class="n">_SupportsCoordinateSystemBase</span><span class="p">,</span>
        <span class="n">_SupportsCoordinateSystemCore</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">_ExpressionType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Symbol</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Expr</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">Matrix</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">MutableDenseMatrix</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">MutableDenseNDimArray</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">ImmutableDenseMatrix</span><span class="p">,</span>
    <span class="n">sp</span><span class="o">.</span><span class="n">ImmutableDenseNDimArray</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">_SupCoordSystemBase</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;_SupCoordSystemBase&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;_SupportsCoordinateSystemBase&quot;</span>
<span class="p">)</span>
<span class="n">_SupCoordSystemCore</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span>
    <span class="s2">&quot;_SupCoordSystemCore&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;_SupportsCoordinateSystemCore&quot;</span>
<span class="p">)</span>


<span class="c1"># ================================== #</span>
<span class="c1"># Mixin Classes                      #</span>
<span class="c1"># ================================== #</span>
<span class="c1"># These classes form the core mixins of the base coordinate system class.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CoordinateSystemCoreMixin</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">_SupCoordSystemBase</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Core methods for coordinate systems wrapped in a Mixin for</span>
<span class="sd">    readability.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># -------------------------- #</span>
    <span class="c1"># Basic Utility Functions    #</span>
    <span class="c1"># -------------------------- #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemBase</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints a detailed description of the coordinate system, including its axes, parameters, and expressions.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            cs = MyCoordinateSystem(a=3, b=4)</span>
<span class="sd">            cs.describe()</span>
<span class="sd">            Coordinate System: MyCoordinateSystem</span>
<span class="sd">            Axes: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</span>
<span class="sd">            Parameters: {&#39;a&#39;: 3, &#39;b&#39;: 4}</span>
<span class="sd">            Available Expressions: [&#39;jacobian&#39;, &#39;metric_tensor&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coordinate System: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available Expressions: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">list_expressions</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># ------------------------------- #</span>
    <span class="c1"># Coordinate Conversion Utilities #</span>
    <span class="c1"># ------------------------------- #</span>
    <span class="c1"># These methods provide access to the API for</span>
    <span class="c1"># coordinate conversion.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_same_dimension</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemBase</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">_SupCoordSystemBase</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Coordinate systems must have the same number of dimensions.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemBase</span><span class="p">,</span> <span class="o">*</span><span class="n">coords</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert native coordinates to Cartesian coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *coords : float or array-like</span>
<span class="sd">            Coordinates in this system&#39;s native basis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of np.ndarray</span>
<span class="sd">            Cartesian coordinates (x, y, z) or lower-dimensional equivalent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_native_to_cartesian</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">from_cartesian</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemBase</span><span class="p">,</span> <span class="o">*</span><span class="n">coords</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert Cartesian coordinates to native coordinates in this system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *coords : float or array-like</span>
<span class="sd">            Cartesian coordinates (x, y, z) or similar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of np.ndarray</span>
<span class="sd">            Native coordinates for this coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_cartesian_to_native</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemBase</span><span class="p">,</span>
        <span class="n">target_system</span><span class="p">:</span> <span class="s2">&quot;_CoordinateSystemBase&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="n">native_coords</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert coordinates from this system to another coordinate system via Cartesian intermediate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_system : _CoordinateSystemBase</span>
<span class="sd">            The target coordinate system to convert to.</span>
<span class="sd">        *native_coords : float or array-like</span>
<span class="sd">            Coordinates in this system&#39;s native basis.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple of np.ndarray</span>
<span class="sd">            Coordinates expressed in the target coordinate system.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            from pymetric.coordinates import SphericalCoordinateSystem, CylindricalCoordinateSystem</span>

<span class="sd">            sph = SphericalCoordinateSystem()</span>
<span class="sd">            cyl = CylindricalCoordinateSystem()</span>
<span class="sd">            rho, phi, z = sph.convert_to(cyl, 1.0, np.pi/2, 0.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_same_dimension</span><span class="p">(</span><span class="n">target_system</span><span class="p">)</span>
        <span class="n">cartesian_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="o">*</span><span class="n">native_coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">target_system</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="o">*</span><span class="n">cartesian_coords</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_conversion_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemBase</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;_CoordinateSystemBase&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a coordinate transformation function that maps native coordinates</span>
<span class="sd">        from this coordinate system to the target coordinate system.</span>

<span class="sd">        The returned function can be used to convert any valid input (scalars or arrays)</span>
<span class="sd">        in the native coordinate system of `self` into the native coordinate system of `other`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : _CoordinateSystemBase</span>
<span class="sd">            The target coordinate system to transform into.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable</span>
<span class="sd">            A function that takes native coordinates of `self` and returns native coordinates of `other`.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            sph = SphericalCoordinateSystem()</span>
<span class="sd">            cyl = CylindricalCoordinateSystem()</span>

<span class="sd">            transform = sph.get_conversion_transform(cyl)</span>
<span class="sd">            rho, phi, z = transform(1.0, np.pi / 2, 0.0)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This conversion is performed via Cartesian coordinates:</span>
<span class="sd">        native (self) -&gt; Cartesian -&gt; native (other).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate that the coordinate systems are of the</span>
        <span class="c1"># same overall dimension.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_same_dimension</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># Construct the function to pass over.</span>
        <span class="c1"># noinspection PyMissingOrEmptyDocstring</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="o">*</span><span class="n">native_coords</span><span class="p">):</span>
            <span class="n">cartesian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cartesian</span><span class="p">(</span><span class="o">*</span><span class="n">native_coords</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">from_cartesian</span><span class="p">(</span><span class="o">*</span><span class="n">cartesian</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transform</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CoordinateSystemIOMixin</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">_SupCoordSystemCore</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for :py:class:`coordinates.core.CurvilinearCoordinateSystem` that provides</span>
<span class="sd">    serialization support for saving and loading coordinate systems to and from HDF5.</span>

<span class="sd">    This mixin implements convenient methods for persisting coordinate system instances,</span>
<span class="sd">    including all user-specified parameters, to HDF5 files. It supports both flat and</span>
<span class="sd">    group-based storage within the file, and includes registry-aware deserialization</span>
<span class="sd">    to recover the correct class type.</span>

<span class="sd">    Key Capabilities</span>
<span class="sd">    ----------------</span>

<span class="sd">    - Save a coordinate system instance to disk with :meth:`to_hdf5`.</span>
<span class="sd">    - Restore a coordinate system instance from disk with :meth:`from_hdf5`.</span>
<span class="sd">    - Automatically serialize parameters, including support for JSON-encoded complex values.</span>
<span class="sd">    - Supports hierarchical group-based storage in HDF5 files.</span>
<span class="sd">    - Uses a registry to resolve class names to actual coordinate system types on load.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_hdf5</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">group_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save this coordinate system to HDF5.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            The path to the output HDF5 file.</span>
<span class="sd">        group_name : str, optional</span>
<span class="sd">            The name of the group in which to store the grid data. If None, data is stored at the root level.</span>
<span class="sd">        overwrite : bool, default=False</span>
<span class="sd">            Whether to overwrite existing data. If False, raises an error when attempting to overwrite.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

        <span class="c1"># Ensure that the filename is a Path object and then check for existence and overwrite violations.</span>
        <span class="c1"># These are only relevant at this stage if a particular group has not yet been specified.</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="c1"># Check if there are overwrite issues and then delete it if it is</span>
            <span class="c1"># relevant to do so.</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">group_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># We can&#39;t overwrite and there is data. Raise an error.</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;File &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39; already exists and overwrite=False. &quot;</span>
                    <span class="s2">&quot;To store data in a specific group, provide `group_name`.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">group_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># We are writing to the core dir and overwrite is true.</span>
                <span class="c1"># delete the entire file and rebuild it.</span>
                <span class="n">filename</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
                <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">):</span>
                    <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The file didn&#39;t already exist, we simply create it and then</span>
            <span class="c1"># let it close again so that we can reopen it in the next phase.</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="c1"># Now that the file has been opened at least once and looks clean, we can</span>
        <span class="c1"># proceed with the actual write process. This will involve first checking</span>
        <span class="c1"># if there are overwrite violations when ``group_name`` is actually specified. Then</span>
        <span class="c1"># we can proceed with actually writing the data.</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Start checking for overwrite violations and the group information.</span>
            <span class="k">if</span> <span class="n">group_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If the group exists, handle overwrite flag</span>
                <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">f</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
                        <span class="n">group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Group &#39;</span><span class="si">{</span><span class="n">group_name</span><span class="si">}</span><span class="s2">&#39; already exists in &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39; and overwrite=False.&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>

            <span class="c1"># Now start writing the core data to the disk. The coordinate system</span>
            <span class="c1"># MUST have the class name and then any optional parameters.</span>
            <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;class_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

            <span class="c1"># Save each kwarg individually as an attribute</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__PARAMETERS__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  <span class="c1"># serialize complex data</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_hdf5</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">group_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">registry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save this coordinate system to HDF5.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            The path to the output HDF5 file.</span>
<span class="sd">        group_name : str, optional</span>
<span class="sd">            The name of the group in which to store the grid data. If None, data is stored at the root level.</span>
<span class="sd">        registry : dict, optional</span>
<span class="sd">            Dictionary mapping class names to coordinate system classes. If None, uses the class&#39;s default registry.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">json</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>

        <span class="c1"># Fill in the registry assignment.</span>
        <span class="k">if</span> <span class="n">registry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">registry</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__DEFAULT_REGISTRY__</span>

        <span class="c1"># Ensure that we have a connection to the file and that we can</span>
        <span class="c1"># actually open it in hdf5.</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">filename</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;File &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39; does not exist.&quot;</span><span class="p">)</span>

        <span class="c1"># Now open the hdf5 file and look for the group name.</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># Identify the data storage group.</span>
            <span class="k">if</span> <span class="n">group_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">group</span> <span class="o">=</span> <span class="n">f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">group</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Group &#39;</span><span class="si">{</span><span class="n">group_name</span><span class="si">}</span><span class="s2">&#39; does not exist in &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># Now load the class name from the group.</span>
            <span class="n">__class_name__</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;class_name&quot;</span><span class="p">]</span>

            <span class="c1"># Load kwargs, deserializing complex data as needed</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;class_name&quot;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span>
                            <span class="n">value</span>
                        <span class="p">)</span>  <span class="c1"># try to parse complex JSON data</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">):</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># simple data types remain as is</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">_cls</span> <span class="o">=</span> <span class="n">registry</span><span class="p">[</span><span class="n">__class_name__</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Failed to find the coordinate system class </span><span class="si">{</span><span class="n">__class_name__</span><span class="si">}</span><span class="s2">. Ensure you have imported any&quot;</span>
                <span class="s2">&quot; relevant coordinate system modules.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">_cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CoordinateSystemAxesMixin</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">_SupCoordSystemCore</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for :py:class:`coordinates.core.CurvilinearCoordinateSystem` which provides</span>
<span class="sd">    support for axis manipulation and logic in coordinate systems.</span>

<span class="sd">    This class defines a comprehensive suite of methods for manipulating and validating</span>
<span class="sd">    axis names, indices, masks, permutations, and orderings in the context of a coordinate system.</span>
<span class="sd">    It is designed to be mixed into coordinate system base classes in the Pisces Geometry library.</span>

<span class="sd">    Key Capabilities</span>
<span class="sd">    ----------------</span>

<span class="sd">    - Convert between axis names and numeric indices.</span>
<span class="sd">    - Build and interpret boolean axis masks.</span>
<span class="sd">    - Validate and normalize axis inputs (with optional order enforcement).</span>
<span class="sd">    - Compute permutations and reorderings for axes and associated data.</span>
<span class="sd">    - Insert or complete axis-aligned iterables using fixed axes.</span>
<span class="sd">    - Provide LaTeX representations of axes for display purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># -------------------------------- #</span>
    <span class="c1"># Basic Axes Utilities             #</span>
    <span class="c1"># -------------------------------- #</span>
    <span class="c1"># These basic utilities are really just simple wrappers</span>
    <span class="c1"># around logic that could be easily implemented independently.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">convert_indices_to_axes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axes_indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert axis index or indices to their corresponding axis name(s).</span>

<span class="sd">        This method maps a single axis index or a sequence of axis indices to the</span>
<span class="sd">        canonical axis name(s) as defined in the coordinate system&#39;s ``__AXES__`` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes_indices : int or Sequence[int]</span>
<span class="sd">            An axis index or list/tuple of axis indices.</span>
<span class="sd">            Negative indices are supported and interpreted as in standard Python indexing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or list of str</span>
<span class="sd">            The axis name(s) corresponding to the provided index or indices.</span>
<span class="sd">            Returns a string for a single index and a list of strings for a sequence.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            If any index is out of bounds for the dimensionality of the coordinate system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method is useful for converting internal numeric axis representations</span>
<span class="sd">        (e.g., from grid shape or tensor slots) into symbolic or user-facing axis names</span>
<span class="sd">        (like &quot;r&quot;, &quot;theta&quot;, &quot;z&quot;, etc.).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        This method allows for various index to axes conversions. Notably, if</span>
<span class="sd">        the input is scalar, the output will also be scalar and if the input is</span>
<span class="sd">        an iterable, then so too will the output. For example, if ``0`` is put in,</span>
<span class="sd">        the result will look like:</span>

<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; u = SphericalCoordinateSystem()</span>

<span class="sd">        &gt;&gt;&gt; u.convert_indices_to_axes(0)</span>
<span class="sd">        &#39;r&#39;</span>

<span class="sd">        Likewise, providing ``[0,2]`` yields</span>

<span class="sd">        &gt;&gt;&gt; u.convert_indices_to_axes([0,2])</span>
<span class="sd">        [&#39;r&#39;, &#39;phi&#39;]</span>

<span class="sd">        Scalar axes can also be provided inside of iterables to ensure consistent</span>
<span class="sd">        typing:</span>

<span class="sd">        &gt;&gt;&gt; u.convert_indices_to_axes([0])</span>
<span class="sd">        [&#39;r&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Enforce the typing on the axes indices so</span>
        <span class="c1"># that they are a uniform iterable type.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axes_indices</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="n">axes_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes_indices</span><span class="p">]</span>
            <span class="n">_as_scalar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes_indices</span><span class="p">)</span>
            <span class="n">_as_scalar</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Normalize the indices.</span>
        <span class="n">axes_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">axes_indices</span><span class="p">]</span>

        <span class="c1"># Now perform the indexing procedure.</span>
        <span class="k">if</span> <span class="n">_as_scalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">[</span><span class="n">axes_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">[</span><span class="n">axes_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">axes_index</span> <span class="ow">in</span> <span class="n">axes_indices</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert_axes_to_indices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert axis name(s) to their corresponding index or indices.</span>

<span class="sd">        This method maps a single axis name or a sequence of axis names to their</span>
<span class="sd">        numeric index as defined by the order of the coordinate system’s ``__AXES__``</span>
<span class="sd">        attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : str or Sequence[str]</span>
<span class="sd">            A single axis name or a list/tuple of axis names to convert.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or list of int</span>
<span class="sd">            The index/indices corresponding to the given axis name(s). Returns an</span>
<span class="sd">            integer for a single axis and a list of integers for multiple axes.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any axis name is not found in the coordinate system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method provides the inverse of :meth:`convert_indices_to_axes`, allowing</span>
<span class="sd">        user-facing axis names (like &quot;r&quot;, &quot;theta&quot;, &quot;phi&quot;) to be mapped to their internal</span>
<span class="sd">        numeric indices (e.g. 0, 1, 2). This is commonly used when aligning field data,</span>
<span class="sd">        slicing tensors, or resolving axis permutations for broadcasting and contraction.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Axis names may be passed individually or as sequences. Scalar inputs yield scalar</span>
<span class="sd">        outputs, and sequences yield lists:</span>

<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; u = SphericalCoordinateSystem()</span>

<span class="sd">        &gt;&gt;&gt; u.convert_axes_to_indices(&quot;r&quot;)</span>
<span class="sd">        0</span>

<span class="sd">        &gt;&gt;&gt; u.convert_axes_to_indices([&quot;r&quot;, &quot;phi&quot;])</span>
<span class="sd">        [0, 2]</span>

<span class="sd">        &gt;&gt;&gt; u.convert_axes_to_indices([&quot;theta&quot;])</span>
<span class="sd">        [1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Enforce the typing on the axes indices so</span>
        <span class="c1"># that they are a uniform iterable type.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>
            <span class="n">_as_scalar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">_as_scalar</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="si">}</span><span class="s2"> for `axes`.&quot;</span><span class="p">)</span>

        <span class="c1"># Check that all axes are in the __AXES__.</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid axes: </span><span class="si">{</span><span class="p">[</span><span class="n">ax</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">ax</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">axes</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">ax</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Now perform the indexing procedure.</span>
        <span class="k">if</span> <span class="n">_as_scalar</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_axes_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a boolean mask array indicating which axes are in ``axes``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes: list of str or int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">        A boolean mask array indicating which axes are in ``axes``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set up the indices for the axes.</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">_axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_axes_to_indices</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Fill the mask values.</span>
        <span class="n">_mask</span><span class="p">[</span><span class="n">_axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">_mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_axes_from_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a boolean axis mask into a list of axis names.</span>

<span class="sd">        This method reverses the effect of :meth:`build_axes_mask` by returning</span>
<span class="sd">        the axis names corresponding to ``True`` values in the provided mask.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : np.ndarray</span>
<span class="sd">            A boolean array of length ``ndim`` where each ``True`` value indicates</span>
<span class="sd">            that the corresponding axis is selected. Must match the length of</span>
<span class="sd">            ``self.__AXES__``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            The names of the axes that are selected in the mask.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the mask does not have the same length as the number of coordinate axes.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is the inverse of :meth:`build_axes_mask`:</span>

<span class="sd">        &gt;&gt;&gt; mask = cs.build_axes_mask([&quot;r&quot;, &quot;phi&quot;])</span>
<span class="sd">        &gt;&gt;&gt; cs.get_axes_from_mask(mask)</span>
<span class="sd">        [&#39;r&#39;, &#39;phi&#39;]</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; mask = np.array([True, False, True])</span>
<span class="sd">        &gt;&gt;&gt; cs.get_axes_from_mask(mask)</span>
<span class="sd">        [&#39;r&#39;, &#39;phi&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Mask length </span><span class="si">{</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> does not match number of axes (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES__</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">)[</span><span class="n">mask</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_mask_from_axes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean mask of shape ``(ndim,)`` with *True* on the</span>
<span class="sd">        positions corresponding to ``axes``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : str or Sequence[str]</span>
<span class="sd">            An axis name or iterable of axis names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Boolean mask selecting those axes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; cs.get_mask_from_axes(&quot;phi&quot;)</span>
<span class="sd">        array([False, False,  True])</span>
<span class="sd">        &gt;&gt;&gt; cs.get_mask_from_axes([&quot;r&quot;, &quot;theta&quot;])</span>
<span class="sd">        array([ True,  True, False])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Normalise to list of canonical names then reuse existing helper</span>
        <span class="n">axes_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_axes_mask</span><span class="p">(</span><span class="n">axes_list</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_mask_from_indices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Boolean mask that is *True* at the supplied numeric indices.</span>

<span class="sd">        Negative indices are handled exactly like standard Python indexing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : int or Sequence[int]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Mask of length ``ndim``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            If any index is out of range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">idx_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="c1"># Normalise negatives / validate range</span>
        <span class="n">idx_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">normalize_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx_list</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">idx_list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_indices_from_mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a boolean mask of length ``ndim`` back to numeric indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mask : numpy.ndarray</span>
<span class="sd">            Boolean selector for axes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int or list[int]</span>
<span class="sd">            * An ``int`` if exactly one element is *True*.</span>
<span class="sd">            * A ``list`` of ints if multiple elements are *True*.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the mask length does not equal ``ndim``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Mask length </span><span class="si">{</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> != ndim (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">idx</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># -------------------------------- #</span>
    <span class="c1"># Permutations and Order           #</span>
    <span class="c1"># -------------------------------- #</span>
    <span class="c1"># These methods help with permuting objects and</span>
    <span class="c1"># ordering objects according to axes.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">axes_complement</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all axes in the coordinate system that are not present in `axes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : list of str</span>
<span class="sd">            Subset of axes to exclude.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            Canonically ordered axes not included in `axes`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; cs.axes</span>
<span class="sd">        [&#39;r&#39;, &#39;theta&#39;, &#39;phi&#39;]</span>
<span class="sd">        &gt;&gt;&gt; cs.axes_complement([&quot;theta&quot;])</span>
<span class="sd">        [&#39;r&#39;, &#39;phi&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether the given axis name(s) exist in this coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : str or list of str</span>
<span class="sd">            One or more axis names to validate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool or list of bool</span>
<span class="sd">            True/False for single input; list of bools for multiple inputs.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; cs.is_axis(&quot;theta&quot;)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; cs.is_axis([&quot;r&quot;, &quot;x&quot;])</span>
<span class="sd">        [True, False]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">axis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_axes_subset</span><span class="p">(</span><span class="n">axes_a</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">axes_b</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if `axes_a` is a subset of `axes_b`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes_a : Sequence[str]</span>
<span class="sd">            The axes to check as a potential subset.</span>
<span class="sd">        axes_b : Sequence[str]</span>
<span class="sd">            The reference axes that should include all of `axes_a`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if every axis in `axes_a` is in `axes_b`, else False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; cs.is_subset([&quot;r&quot;, &quot;theta&quot;], [&quot;r&quot;, &quot;theta&quot;, &quot;phi&quot;])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; cs.is_subset([&quot;phi&quot;, &quot;z&quot;], [&quot;r&quot;, &quot;theta&quot;, &quot;phi&quot;])</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes_b</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_axes_superset</span><span class="p">(</span><span class="n">axes_a</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">axes_b</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if `axes_a` is a superset of `axes_b`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes_a : Sequence[str]</span>
<span class="sd">            The axes to check as a potential superset.</span>
<span class="sd">        axes_b : Sequence[str]</span>
<span class="sd">            The reference axes that should be contained within `axes_a`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if every axis in `axes_b` is in `axes_a`, else False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; cs.is_superset([&quot;r&quot;, &quot;theta&quot;, &quot;phi&quot;], [&quot;theta&quot;])</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; cs.is_superset([&quot;theta&quot;], [&quot;r&quot;, &quot;phi&quot;])</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">axes_a</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes_b</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_free_fixed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">fixed_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split a list of coordinate axes into fixed and free components.</span>

<span class="sd">        This utility verifies that all fixed axes are:</span>
<span class="sd">        - present in the coordinate system</span>
<span class="sd">        - included in the axes list being considered</span>

<span class="sd">        It then returns a list of free axes (i.e., axes not fixed) and the fixed axis dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : list of str, optional</span>
<span class="sd">            The axes to consider. If not provided, uses all coordinate system axes.</span>
<span class="sd">        fixed_axes : dict of {str: Any}, optional</span>
<span class="sd">            A mapping of fixed axis names to values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (list of str, dict of str → Any)</span>
<span class="sd">            A tuple of (free_axes, fixed_axes) where:</span>
<span class="sd">            - `free_axes` is a list of axes in `axes` that are not fixed.</span>
<span class="sd">            - `fixed_axes` is the same dictionary (possibly empty), but validated.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any fixed axis is not in the coordinate system.</span>
<span class="sd">            If any fixed axis is not in the provided axes list.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; cs.get_free_fixed(axes=[&quot;r&quot;, &quot;theta&quot;, &quot;phi&quot;], fixed_axes={&quot;theta&quot;: 0.0})</span>
<span class="sd">        ([&#39;r&#39;, &#39;phi&#39;], {&#39;theta&#39;: 0.0})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default to all axes in the coordinate system</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolve_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
        <span class="n">fixed_axes</span> <span class="o">=</span> <span class="n">fixed_axes</span> <span class="ow">or</span> <span class="p">{}</span>

        <span class="c1"># Validate that all fixed axes are in the coordinate system</span>
        <span class="n">unknown_fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">fixed_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">unknown_fixed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Fixed axes not in coordinate system: </span><span class="si">{</span><span class="n">unknown_fixed</span><span class="si">}</span><span class="s2">. Valid axes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Validate that all fixed axes are in the provided axes list</span>
        <span class="n">not_in_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">fixed_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">not_in_axes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Fixed axes </span><span class="si">{</span><span class="n">not_in_axes</span><span class="si">}</span><span class="s2"> are not included in the target axes: </span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Compute the list of free axes</span>
        <span class="n">free_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fixed_axes</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">free_axes</span><span class="p">,</span> <span class="n">fixed_axes</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_axes_permutation</span><span class="p">(</span>
        <span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">dst_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the permutation needed to reorder `src_axes` into `dst_axes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            The current ordering of axes.</span>
<span class="sd">        dst_axes : list of str</span>
<span class="sd">            The desired target ordering.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of int</span>
<span class="sd">            Indices describing how to reorder `src_axes` to match `dst_axes`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the two lists are not permutations of each other.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; cs.get_axes_permutation([&quot;theta&quot;, &quot;r&quot;], [&quot;r&quot;, &quot;theta&quot;])</span>
<span class="sd">        [1, 0]</span>

<span class="sd">        If an element is not in one or the other sets, then an error</span>
<span class="sd">        occurs.</span>

<span class="sd">        &gt;&gt;&gt; cs.get_axes_permutation([&quot;theta&quot;, &quot;r&quot;, &#39;phi&#39;], [&quot;r&quot;, &quot;theta&quot;]) # doctest: +ELLIPSIS +SKIP</span>
<span class="sd">        ValueError: `src_axes` and `dst_axes` must be permutations of each other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">src_axes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dst_axes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`src_axes` and `dst_axes` must be permutations of each other.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">src_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dst_axes</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_canonical_axes_permutation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the permutation needed to reorder `axes` into the canonical order defined by the coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : list of str</span>
<span class="sd">            A list of axis names to permute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of int</span>
<span class="sd">            Indices describing how to reorder `axes` to match the canonical order (`self.axes`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_axes_permutation</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_axes_order</span><span class="p">(</span><span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">dst_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the reordering indices that will reorder `src_axes` into the order of `dst_axes`.</span>

<span class="sd">        This function returns a list of indices that can be used to rearrange `src_axes` so that its</span>
<span class="sd">        elements appear in the same order as in `dst_axes`, skipping any elements of `dst_axes` that are</span>
<span class="sd">        not present in `src_axes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            The current ordering of a subset of axes (e.g., axes labeling a tensor).</span>
<span class="sd">        dst_axes : list of str</span>
<span class="sd">            The desired target ordering (typically canonical order).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of int</span>
<span class="sd">            A permutation `P` such that `[src_axes[i] for i in P]` gives the axes in `dst_axes` order.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any element of `src_axes` is not found in `dst_axes`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; get_axes_order([&quot;phi&quot;, &quot;r&quot;], [&quot;r&quot;, &quot;theta&quot;, &quot;phi&quot;])</span>
<span class="sd">        [1, 0]  # &quot;r&quot; comes before &quot;phi&quot; in dst_axes</span>

<span class="sd">        &gt;&gt;&gt; get_axes_order([&quot;x&quot;, &quot;y&quot;], [&quot;y&quot;, &quot;z&quot;, &quot;x&quot;])</span>
<span class="sd">        [1, 0]  # reorder to [&quot;y&quot;, &quot;x&quot;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">src_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">src_axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">src_set</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dst_axes</span><span class="p">)):</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="n">src_set</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dst_axes</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Some source axes are not present in destination: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">src_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dst_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">src_axes</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">order_axes</span><span class="p">(</span><span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">dst_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder `src_axes` into the order defined by `dst_axes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            A subset of axis names to reorder.</span>
<span class="sd">        dst_axes : list of str</span>
<span class="sd">            The desired axis ordering to match (typically canonical axes).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            Reordered version of `src_axes` to match the order in `dst_axes`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any element in `src_axes` is not present in `dst_axes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">src_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dst_axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown axis name(s): </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. Must be present in destination order: </span><span class="si">{</span><span class="n">dst_axes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dst_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">src_axes</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_axes_order</span><span class="p">(</span>
        <span class="n">iterable</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">dst_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder a sequence of values from `src_axes` order to `dst_axes` order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable : list</span>
<span class="sd">            Items corresponding to axes in `src_axes` order.</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            Axis names corresponding to the order of `iterable`.</span>
<span class="sd">        dst_axes : list of str</span>
<span class="sd">            Desired axis ordering to match.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list:</span>
<span class="sd">            Reordered iterable in the `dst_axes` order.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the lengths don&#39;t match or any axes are unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_axes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length mismatch: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span><span class="si">}</span><span class="s2"> items vs </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">src_axes</span><span class="p">)</span><span class="si">}</span><span class="s2"> axes.&quot;</span>
            <span class="p">)</span>

        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">src_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dst_axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown axis name(s): </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">. Must be present in destination order: </span><span class="si">{</span><span class="n">dst_axes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">ordered_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">dst_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">src_axes</span><span class="p">]</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">src_axes</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">ordered_axes</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_canonical_axes_order</span><span class="p">(</span><span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the permutation indices to reorder `src_axes` into sorted alphabetical order.</span>

<span class="sd">        This function is useful for contexts where canonical order is alphabetical,</span>
<span class="sd">        or where symbolic systems (without a defined canonical axis list) use string sorting as a fallback.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            A list of axis names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of int</span>
<span class="sd">            A permutation `P` such that `[src_axes[i] for i in P]` gives `sorted(src_axes)`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; get_canonical_axes_order([&quot;theta&quot;, &quot;r&quot;, &quot;phi&quot;])</span>
<span class="sd">        [2, 1, 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">src_axes</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">src_axes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">order_axes_canonical</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder a list of axis names into the canonical order of this coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            A subset of axis names to reorder.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            Reordered list of axis names, matching the order in `self.axes`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any element in `src_axes` is not present in `self.axes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">order_axes</span><span class="p">(</span><span class="n">src_axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">in_canonical_order</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">iterable</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reorder a sequence of values from `src_axes` order to canonical axis order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable : list</span>
<span class="sd">            Items corresponding to axes in `src_axes` order.</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            Axis names corresponding to the order of `iterable`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Reordered iterable in the canonical axis order (`self.axes`).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the lengths don&#39;t match or any axes are unknown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_axes_order</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">src_axes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">resolve_axes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">require_subset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">require_order</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize and validate a user-supplied list of axis names.</span>

<span class="sd">        This utility resolves the canonical ordering and performs consistency checks</span>
<span class="sd">        such as subset membership, uniqueness, and order compliance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : list of str or None</span>
<span class="sd">            The axis names to validate. If None, returns the full list of canonical axes (`self.axes`).</span>
<span class="sd">        require_subset : bool, default=True</span>
<span class="sd">            If True, all entries in `axes` must be present in `self.axes`.</span>
<span class="sd">        require_order : bool, default=False</span>
<span class="sd">            If True, `axes` must appear in the same order as they do in `self.axes`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of str</span>
<span class="sd">            A concrete list of axis names, validated and normalized.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If duplicate, unknown, or misordered axes are found.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; cs.resolve_axes([&quot;phi&quot;, &quot;r&quot;])</span>
<span class="sd">        [&#39;phi&#39;, &#39;r&#39;]</span>

<span class="sd">        &gt;&gt;&gt; cs.resolve_axes([&quot;phi&quot;, &quot;r&quot;], require_order=True)  # doctest: +SKIP</span>
<span class="sd">        ValueError: Axes must appear in canonical order r → theta → phi; received [&#39;phi&#39;, &#39;r&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default: use full canonical axes</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Normalize to mutable list</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="c1"># Check for duplicates</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
            <span class="n">dup</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">axes</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate axis/axes in input: </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dup</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Check for unknown axes</span>
        <span class="k">if</span> <span class="n">require_subset</span><span class="p">:</span>
            <span class="n">unknown</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unknown</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unknown axis/axes </span><span class="si">{</span><span class="n">unknown</span><span class="si">!r}</span><span class="s2"> – valid axes are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Check order matches canonical</span>
        <span class="k">if</span> <span class="n">require_order</span><span class="p">:</span>
            <span class="n">canonical_index</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">canonical_index</span> <span class="o">!=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">canonical_index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Axes must appear in canonical order &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; → &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span><span class="si">}</span><span class="s2">; received </span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">axes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">insert_fixed_axes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span>
        <span class="n">iterable</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">src_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">fixed_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert fixed axis values into an iterable of values according to canonical axis order.</span>

<span class="sd">        This is used to construct a complete value list (e.g., coordinate components) from:</span>
<span class="sd">        - a partial set of values aligned with `src_axes`, and</span>
<span class="sd">        - a dictionary of fixed scalar values for other axes (`fixed_axes`).</span>

<span class="sd">        The result is a new list with one value per coordinate system axis, aligned to `self.axes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable : list</span>
<span class="sd">            Values corresponding to `src_axes`.</span>
<span class="sd">        src_axes : list of str</span>
<span class="sd">            Axis names corresponding to the entries in `iterable`.</span>
<span class="sd">        fixed_axes : dict of {str: Any}, optional</span>
<span class="sd">            A dictionary of fixed axis values to insert into the output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Values reordered and filled to match `self.axes`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `src_axes` and `fixed_axes` overlap.</span>
<span class="sd">            If any axis in `src_axes` or `fixed_axes` is not part of the coordinate system.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">        &gt;&gt;&gt; cs.axes</span>
<span class="sd">        [&#39;r&#39;, &#39;theta&#39;, &#39;phi&#39;]</span>
<span class="sd">        &gt;&gt;&gt; cs.insert_fixed_axes([&quot;R&quot;,&quot;PHI&quot;], [&#39;r&#39;, &#39;phi&#39;], fixed_axes={&#39;theta&#39;: &quot;THETA&quot;})</span>
<span class="sd">        [&#39;R&#39;, &#39;THETA&#39;, &#39;PHI&#39;]</span>

<span class="sd">        This will also reorder entries that are not in canonical order:</span>

<span class="sd">        &gt;&gt;&gt; cs.insert_fixed_axes([&quot;PHI&quot;,&quot;R&quot;], [&#39;phi&#39;, &#39;r&#39;], fixed_axes={&#39;theta&#39;: &quot;THETA&quot;})</span>
<span class="sd">        [&#39;R&#39;, &#39;THETA&#39;, &#39;PHI&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fixed_axes</span> <span class="o">=</span> <span class="n">fixed_axes</span> <span class="ow">or</span> <span class="p">{}</span>

        <span class="c1"># Check for illegal overlaps</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">src_axes</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">fixed_axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`src_axes` and `fixed_axes` must not overlap: </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check for unknown axes</span>
        <span class="n">unknown_src</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">src_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="n">unknown_fixed</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">fixed_axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">unknown_src</span> <span class="ow">or</span> <span class="n">unknown_fixed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown axes: </span><span class="si">{</span><span class="n">unknown_src</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">unknown_fixed</span><span class="si">}</span><span class="s2">. Must be a subset of: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Build the mapping</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">src_axes</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span>
        <span class="n">mapping</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fixed_axes</span><span class="p">)</span>

        <span class="c1"># Fill values in canonical order</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="k">if</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">]</span>

    <span class="c1"># -------------------------------- #</span>
    <span class="c1"># Latex                            #</span>
    <span class="c1"># -------------------------------- #</span>
    <span class="c1"># This connects axes to latex.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_axes_latex</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the LaTeX representation(s) of one or more axis names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : str or Sequence[str]</span>
<span class="sd">            A single axis name or a list/tuple of axis names.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str or list of str</span>
<span class="sd">            The LaTeX representation(s) of the provided axis/axes. Returns a single string</span>
<span class="sd">            if a scalar input is given, and a list of strings if a sequence is provided.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - If ``__AXES_LATEX__`` is not defined for the coordinate system, this falls back</span>
<span class="sd">          to wrapping each axis in ``$...$``.</span>
<span class="sd">        - Axis names must be valid entries in ``__AXES__``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">axes_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>
            <span class="n">is_scalar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
            <span class="n">is_scalar</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__AXES_LATEX__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">latex_list</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;$</span><span class="si">{</span><span class="n">ax</span><span class="si">}</span><span class="s2">$&quot;</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes_list</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">latex_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__AXES_LATEX__</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes_list</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Axis </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> does not have a defined LaTeX representation.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">return</span> <span class="n">latex_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">is_scalar</span> <span class="k">else</span> <span class="n">latex_list</span>

    <span class="c1"># -------------------------------- #</span>
    <span class="c1"># Units                            #</span>
    <span class="c1"># -------------------------------- #</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_axes_units</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupCoordSystemCore</span><span class="p">,</span> <span class="n">unit_system</span><span class="p">:</span> <span class="s2">&quot;unyt.UnitSystem&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;unyt.Unit&quot;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolve the physical units for each axis in a given unit system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit_system : unyt.UnitSystem</span>
<span class="sd">            The unit system used to resolve the symbolic axis dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of unyt.Unit</span>
<span class="sd">            The resolved unit for each axis, in canonical order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">unit_system</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes_dimensions</span><span class="p">]</span>
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, Eliza Diggins.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>