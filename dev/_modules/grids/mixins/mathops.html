
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>grids.mixins.mathops &#8212; PyMetric  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/grids/mixins/mathops';</script>
    <link rel="icon" href="../../../_static/pm_favicon.svg"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">PyMetric  documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_quickstart/index.html">
    PyMetric Quickstart Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api_base.html">
    API
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_quickstart/index.html">
    PyMetric Quickstart Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Example Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    PyMetric User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api_base.html">
    API
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">grids.mixins.mathops</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for grids.mixins.mathops</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Grid operator mixins for differential geometry and field computations.</span>

<span class="sd">This module provides mixin classes that add high-level mathematical operations</span>
<span class="sd">to grid classes. These operations include gradient, divergence, Laplacian, and</span>
<span class="sd">tensor contractions, and are implemented as thin wrappers over lower-level</span>
<span class="sd">kernels from the :mod:`differential_geometry` package.</span>

<span class="sd">The mixins handle tasks such as:</span>

<span class="sd">- Automatically computing coordinate-based expressions from the grid’s coordinate system.</span>
<span class="sd">- Performing operations in memory-efficient chunks using the grid’s chunking interface.</span>
<span class="sd">- Broadcasting input fields and auxiliary buffers to the appropriate grid shape.</span>
<span class="sd">- Managing metric and volume element dependencies implicitly.</span>

<span class="sd">These mixins are intended to be inherited by structured grid classes (e.g., :class:`~grids.core.UniformGrid`)</span>
<span class="sd">to provide a clean and consistent API for field-based differential operators.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ArrayLike</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.differential_geometry.dense_ops</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">dense_gradient_contravariant_diag</span><span class="p">,</span>
    <span class="n">dense_gradient_contravariant_full</span><span class="p">,</span>
    <span class="n">dense_gradient_covariant</span><span class="p">,</span>
    <span class="n">dense_scalar_laplacian_diag</span><span class="p">,</span>
    <span class="n">dense_scalar_laplacian_full</span><span class="p">,</span>
    <span class="n">dense_vector_divergence_contravariant</span><span class="p">,</span>
    <span class="n">dense_vector_divergence_covariant_diag</span><span class="p">,</span>
    <span class="n">dense_vector_divergence_covariant_full</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># noinspection PyProtectedMember</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.differential_geometry.dense_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">_dense_adjust_tensor_signature</span><span class="p">,</span>
    <span class="n">_dense_adjust_tensor_signature_diagonal_metric</span><span class="p">,</span>
    <span class="n">_dense_contract_index_with_diagonal_metric</span><span class="p">,</span>
    <span class="n">_dense_contract_index_with_metric</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.differential_geometry.general_ops</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">dense_element_wise_partial_derivatives</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># =================================== #</span>
<span class="c1"># Type Annotations                    #</span>
<span class="c1"># =================================== #</span>
<span class="c1"># These type annotations are used for compatibility</span>
<span class="c1"># with static type checkers like mypy.</span>
<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># noinspection PyUnresolvedReferences</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pymetric.grids.mixins._typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">_SupportsDenseGridMathOps</span>

<span class="n">_SupDGMO</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_SupDGMO&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;_SupportsDenseGridMathOps&quot;</span><span class="p">)</span>


<span class="c1"># ================================ #</span>
<span class="c1"># Dense MathOperations Mixin       #</span>
<span class="c1"># ================================ #</span>
<span class="c1"># This class provides support for differential geometry on tensor</span>
<span class="c1"># fields with dense representations.</span>
<div class="viewcode-block" id="DenseMathOpsMixin">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.html#grids.mixins.mathops.DenseMathOpsMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DenseMathOpsMixin</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">_SupDGMO</span><span class="p">]):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin class for dense differential geometry operations on structured grids.</span>

<span class="sd">    This class provides high-level numerical implementations of common differential</span>
<span class="sd">    geometry operators—such as gradients, divergence, and Laplacians—on fields defined over</span>
<span class="sd">    structured grids with curvilinear coordinate systems.</span>

<span class="sd">    It serves as a convenience interface to the low-level functions in</span>
<span class="sd">    :mod:`differential_geometry`, managing:</span>

<span class="sd">    - Axis labeling and broadcasting between tensor fields and grid domains.</span>
<span class="sd">    - Automatic handling of coordinate expressions like metric tensors and volume terms.</span>
<span class="sd">    - Support for lazy-loading or memory-intensive buffers through optional chunked execution.</span>
<span class="sd">    - Compatibility with ghost zones and progress bars.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: This can probably be unified... Priority: low</span>

    <span class="c1"># ======================================= #</span>
    <span class="c1"># Utility Functions                       #</span>
    <span class="c1"># ======================================= #</span>
    <span class="c1"># These are utility methods that can be called during the</span>
    <span class="c1"># execution sequence for operational clarity.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_output_buffer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">output_element_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allocate or validate an output buffer for grid-based tensor computations.</span>

<span class="sd">        This method either validates a provided `out` buffer or allocates a new one using</span>
<span class="sd">        the grid’s `empty()` method. It is intended for internal use in operations such as</span>
<span class="sd">        gradient, divergence, and Laplacian calculations, where output shape and alignment</span>
<span class="sd">        with logical axes are critical.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : Sequence[str]</span>
<span class="sd">            Logical axes over which the field is defined (e.g. ``[&quot;x&quot;, &quot;y&quot;]``). These define</span>
<span class="sd">            the grid space that the output buffer must align with.</span>
<span class="sd">        out : np.ndarray, optional</span>
<span class="sd">            Optional pre-allocated output array. If provided, its shape is checked for</span>
<span class="sd">            compatibility with the grid shape along `axes` and with the specified</span>
<span class="sd">            `output_element_shape`.</span>
<span class="sd">        output_element_shape : Tuple[int], optional</span>
<span class="sd">            Shape of each individual field element. For scalar fields, this is `()`. For vector</span>
<span class="sd">            or tensor fields, this may be `(ndim,)`, `(ndim, ndim)`, etc. If `out` is not provided,</span>
<span class="sd">            this will be used to construct the new output buffer.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to `self.empty()` when allocating a new buffer.</span>
<span class="sd">            Common options include:</span>
<span class="sd">            - `dtype`: Data type of the new array.</span>
<span class="sd">            - `order`: Memory layout order (&#39;C&#39; or &#39;F&#39;).</span>
<span class="sd">            - `include_ghosts`: Whether to include ghost zones.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ArrayLike</span>
<span class="sd">            A NumPy-compatible array that can be written to by the calling operation.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `out` is provided but does not match the required shape.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This method is typically used at the beginning of a differential operator to ensure</span>
<span class="sd">          the output buffer is valid for writing results.</span>
<span class="sd">        - It supports both scalar and tensor-valued field outputs and is compatible with</span>
<span class="sd">          broadcasting and ghost zone inclusion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_field_shape</span><span class="p">(</span>
                <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">field_shape</span><span class="o">=</span><span class="n">output_element_shape</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">element_shape</span><span class="o">=</span><span class="n">output_element_shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_input_output_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span> <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Standardize the field axes and the output axes.</span>
        <span class="c1"># convert them both to indices.</span>
        <span class="n">field_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize_axes</span><span class="p">(</span><span class="n">field_axes</span><span class="p">)</span>
        <span class="n">output_axes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">standardize_axes</span><span class="p">(</span><span class="n">output_axes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">output_axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">field_axes</span>
        <span class="p">)</span>
        <span class="n">fidx</span><span class="p">,</span> <span class="n">oidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">convert_axes_to_indices</span><span class="p">(</span>
            <span class="n">field_axes</span>
        <span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">convert_axes_to_indices</span><span class="p">(</span><span class="n">output_axes</span><span class="p">)</span>

        <span class="c1"># Ensure axes are a subset of the output.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">is_axes_subset</span><span class="p">(</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axes </span><span class="si">{</span><span class="n">field_axes</span><span class="si">}</span><span class="s2"> are not a subset of </span><span class="si">{</span><span class="n">output_axes</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="p">,</span> <span class="n">fidx</span><span class="p">,</span> <span class="n">oidx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_compute_fixed_axes_and_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span> <span class="n">free_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the fixed axes and corresponding fill values for a set of free axes.</span>

<span class="sd">        This utility method identifies all axes not included in `free_axes` (i.e., the complement</span>
<span class="sd">        of the coordinate system&#39;s axes) and returns a dictionary mapping those fixed axes</span>
<span class="sd">        to their default fill values. This is useful when computing expressions that depend on</span>
<span class="sd">        a subset of the coordinate system&#39;s axes (e.g., chunked computations with broadcasting).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        free_axes : Sequence[str]</span>
<span class="sd">            The list of logical axes over which the operation is being performed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fixed_axes : Sequence[str]</span>
<span class="sd">            Axes not in `free_axes`. These are assumed to be fixed during computation.</span>
<span class="sd">        fixed_values : dict</span>
<span class="sd">            Dictionary mapping each fixed axis to its default value as specified in</span>
<span class="sd">            `self.fill_values`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fixed_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">axes_complement</span><span class="p">(</span><span class="n">free_axes</span><span class="p">)</span>
        <span class="n">fixed_values</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_values</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fixed_axes</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span>

    <span class="c1"># noinspection PyDefaultArgument</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_make_expression_chunk_fetcher</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">expr_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">fixed_axes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a chunk-aware getter function for a grid expression.</span>

<span class="sd">        If `value` is None, computes the expression on-the-fly for each chunk using the coordinate system.</span>
<span class="sd">        Otherwise, slices into the precomputed array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr_name : str</span>
<span class="sd">            Name of the expression to compute (e.g., &#39;inverse_metric_tensor&#39;).</span>
<span class="sd">        fixed_axes : dict</span>
<span class="sd">            Dictionary of fixed axes for the coordinate evaluation.</span>
<span class="sd">        value : Optional[np.ndarray]</span>
<span class="sd">            Precomputed field array to use if provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Callable</span>
<span class="sd">            A function (chunk_slices, coordinates) -&gt; array for this chunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Capture `expr_name` and `fixed_axes` at function definition time using default args</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">_e</span><span class="o">=</span><span class="n">expr_name</span><span class="p">,</span> <span class="n">_f</span><span class="o">=</span><span class="n">fixed_axes</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">compute_expression_from_coordinates</span><span class="p">(</span>
                        <span class="n">_e</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">fixed_axes</span><span class="o">=</span><span class="n">_f</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Return a simple slicing function</span>
            <span class="k">return</span> <span class="k">lambda</span> <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">value</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span>

    <span class="c1"># ======================================= #</span>
    <span class="c1"># General Math Ops                        #</span>
    <span class="c1"># ======================================= #</span>
<div class="viewcode-block" id="DenseMathOpsMixin.compute_function_on_grid">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.compute_function_on_grid.html#grids.mixins.mathops.DenseMathOpsMixin.compute_function_on_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_function_on_grid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">result_shape</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">func_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;axes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;axes&quot;</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a coordinate-based function over the grid domain.</span>

<span class="sd">        This method computes the values of a user-supplied callable `func` at each point on the grid</span>
<span class="sd">        spanned by `output_axes`, using the physical (coordinate system-defined) coordinates at those points.</span>
<span class="sd">        It supports both global (in-memory) and streaming (chunked) evaluation strategies.</span>

<span class="sd">        This is useful for constructing scalar, vector, or tensor fields defined analytically in terms</span>
<span class="sd">        of coordinates, and can be applied efficiently even for large grids.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            A Python function that returns values defined over physical coordinates. Its signature must match</span>
<span class="sd">            the coordinate mode:</span>

<span class="sd">            - If ``func_type=&quot;axes&quot;`` (default), the function takes only the coordinates of `output_axes`</span>
<span class="sd">              (in canonical coordinate order).</span>
<span class="sd">            - If ``func_type=&quot;all&quot;``, the function must take all coordinate axes of the system in canonical order.</span>

<span class="sd">            The return value should be an array with shape `result_shape` per grid point.</span>

<span class="sd">        result_shape : sequence of int, optional</span>
<span class="sd">            The shape of the result at each grid point (e.g., `()` for scalar fields, `(3,)` for 3-vectors).</span>
<span class="sd">            Defaults to `()` if unspecified.</span>

<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to show a progress bar during chunked evaluation.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Extra keyword arguments passed to `tqdm` when `pbar=True`.</span>
<span class="sd">        func_type : {&quot;axes&quot;, &quot;all&quot;}, optional</span>
<span class="sd">                    Specifies whether `func` accepts all coordinate axes or only those listed in `output_axes`.</span>
<span class="sd">                    By default, ``&quot;axes&quot;``.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keyword arguments forwarded to `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray</span>
<span class="sd">            A NumPy array with shape `(grid_shape over output_axes) + result_shape`, containing the</span>
<span class="sd">            evaluated function values at each grid point.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method evaluates the function:</span>

<span class="sd">        .. math::</span>

<span class="sd">            f(x^1, x^2, ..., x^n)</span>

<span class="sd">        where :math:`x^i` are the physical coordinates (e.g., `r`, `\theta`, `z`, etc.) defined</span>
<span class="sd">        by the coordinate system.</span>

<span class="sd">        If `in_chunks=True`, the grid is traversed in blocks (including 1-cell ghost zones), and the function</span>
<span class="sd">        is evaluated independently on each block. This enables out-of-core and lazy buffer evaluations.</span>

<span class="sd">        This method is commonly used to:</span>

<span class="sd">        - Construct analytic scalar/vector/tensor fields on structured grids</span>
<span class="sd">        - Convert closed-form physics models into discrete field data</span>
<span class="sd">        - Generate test fields for numerical method validation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Handle fixed and free axes --- #</span>
        <span class="n">output_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize_axes</span><span class="p">(</span><span class="n">output_axes</span><span class="p">)</span>
        <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fixed_axes_and_values</span><span class="p">(</span>
            <span class="n">free_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="c1"># We do have some additional leg work to determine the element shape in this case.</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">result_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">output_element_shape</span><span class="o">=</span><span class="n">result_shape</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="s2">&quot;f8&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># --- Handle the eval function --- #</span>
        <span class="c1"># We need to handle the function because it might be</span>
        <span class="c1"># a function of the axes and not the full coordinate set,</span>
        <span class="c1"># but we want it to be a function of the full coordinate</span>
        <span class="c1"># set when passed through.</span>
        <span class="k">if</span> <span class="n">func_type</span> <span class="o">==</span> <span class="s2">&quot;axes&quot;</span><span class="p">:</span>
            <span class="c1"># Canonical list of coordinate names in this system</span>
            <span class="n">all_axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">__AXES__</span>

            <span class="c1"># Determine the indices of the output axes in the full system</span>
            <span class="n">output_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_axes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">output_axes</span><span class="p">]</span>

            <span class="c1"># Define a new function that accepts *all_axes but internally calls func(*args_subset)</span>
            <span class="c1"># noinspection PyMissingOrEmptyDocstring</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">full_func</span><span class="p">(</span><span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">):</span>
                <span class="c1"># Subselect only the arguments that correspond to output_axes</span>
                <span class="n">args_subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">output_indices</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args_subset</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>

            <span class="n">eval_func</span> <span class="o">=</span> <span class="n">full_func</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eval_func</span> <span class="o">=</span> <span class="n">func</span>

        <span class="c1"># --- Perform the computation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Operation performed in chunks.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="c1"># Cycle through chunks.</span>
            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Compute coordinates. Cut down to the correct set of coordinates and</span>
                <span class="c1"># slices for the input field axes.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">out</span><span class="p">[</span>
                    <span class="p">(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">compute_function_from_coordinates</span><span class="p">(</span>
                    <span class="n">eval_func</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">compute_function_from_coordinates</span><span class="p">(</span>
                <span class="n">eval_func</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span>
            <span class="p">)</span>

        <span class="c1"># Return the output buffer.</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="c1"># ======================================= #</span>
    <span class="c1"># General Dense Ops                       #</span>
    <span class="c1"># ======================================= #</span>
    <span class="c1"># recasting of functions from differential geometry&#39;s</span>
    <span class="c1"># general_ops module.</span>
<div class="viewcode-block" id="DenseMathOpsMixin.dense_element_wise_partial_derivatives">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_element_wise_partial_derivatives.html#grids.mixins.mathops.DenseMathOpsMixin.dense_element_wise_partial_derivatives">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_element_wise_partial_derivatives</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the element-wise partial derivatives of an array-valued field over the grid.</span>

<span class="sd">        This method computes the partial derivatives along each of the :attr:`~grids.base.GridBase.ndim` axes of the grid</span>
<span class="sd">        for each element of an array-valued input field. Thus,</span>

<span class="sd">        .. math::</span>

<span class="sd">            T_{ijk\ldots} \to T_{ijk\ldots;\mu} = \partial_\mu T_{ijk\ldots}.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            Under the hood, this method wraps :func:`~differential_geometry.general_ops.dense_element_wise_partial_derivatives`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : array-like</span>
<span class="sd">            The array-valued field on which to compute the partial derivatives. This should be an array-like object</span>
<span class="sd">            with a compliant shape (see `Notes` below).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when ``in_chunks=True``.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.general_ops.dense_element_wise_partial_derivatives`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            The computed partial derivatives. he returned array has shape:</span>
<span class="sd">            ``(...grid_shape over `output_axes`, ...element_shape of `field`, ndim)``</span>
<span class="sd">            The final axis contains the partial derivatives with respect to each coordinate axis</span>
<span class="sd">            in the grid’s coordinate system.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Broadcasting and Array Shapes**:</span>

<span class="sd">        The input ``field`` must have a very precise shape to be valid for this operation. If the underlying grid</span>
<span class="sd">        (**including ghost zones**) has shape ``grid_shape = (G_1,...,G_ndim)``, then the spatial dimensions of the field must</span>
<span class="sd">        match exactly ``grid_shape[axes]``. Any remaining dimensions of the ``field`` are treated as elements of the field.</span>

<span class="sd">        Thus, if a ``(G1,G3,F1,F2,F3)`` field is passed with ``field_axes = [&#39;x&#39;,&#39;z&#39;]`` (in cartesian coordinates), then</span>
<span class="sd">        the resulting output array will have shape ``(G1,G3,F1,F2,F3,3)`` and ``out[...,1] == 0`` because the field does not</span>
<span class="sd">        contain any variability over the ``y`` variable.</span>

<span class="sd">        If ``output_axes`` is specified, then that resulting grid will be broadcast to any additional grid axes necessary.</span>

<span class="sd">        When ``out`` is specified, it must match (exactly) the expected output buffer shape or an error will arise.</span>

<span class="sd">        **Chunking Semantics**:</span>

<span class="sd">        When ``in_chunks=True``, chunking is enabled for this operation. In that case, the ``out`` buffer is filled</span>
<span class="sd">        iteratively by performing computations on each chunk of the grid over the specified `output_axes`. When the</span>
<span class="sd">        computation is performed, each chunk is extracted with an additional 1-cell halo to ensure that :func:`numpy.gradient`</span>
<span class="sd">        attains its maximal accuracy on each chunk.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Chunking is (generally) only useful when ``out`` and ``field`` are array-like lazy-loaded buffers like</span>
<span class="sd">            HDF5 datasets. In those cases, the maximum memory load is only that required to load each individual chunk.</span>
<span class="sd">            If the ``out`` buffer is not specified, it is allocated fully anyways, making chunking somewhat redundant.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_covariant_gradient: Covariant gradient of a tensor field.</span>
<span class="sd">        dense_contravariant_gradient: Contravariant gradient of a tensor field.</span>
<span class="sd">        ~differential_geometry.general_ops.dense_element_wise_partial_derivatives: Low-level callable version.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Derivatives of a scalar field**:</span>

<span class="sd">        The easiest example is the derivative of a generic scalar field.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem2D</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = CartesianCoordinateSystem2D()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1],[1,1]],[500,500],chunk_size=[50,50],ghost_zones=[[2,2],[2,2]],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;)</span>
<span class="sd">            &gt;&gt;&gt; Z = np.sin((X**2+Y**2))</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives = grid.dense_element_wise_partial_derivatives(Z,[&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(1,3,sharey=True,sharex=True,figsize=(7,3))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0].imshow(Z.T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1].imshow(derivatives[...,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[2].imshow(derivatives[...,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        **Derivatives of an array field**:</span>

<span class="sd">        Similarly, this can be applied to array fields of any sort.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem2D</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = CartesianCoordinateSystem2D()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1],[1,1]],[500,500],chunk_size=[50,50],ghost_zones=[[2,2],[2,2]],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;)</span>
<span class="sd">            &gt;&gt;&gt; Z = np.stack([np.sin((X**2+Y**2)),np.sin(5*(X**2+Y**2))],axis=-1) # (504,504,2)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives = grid.dense_element_wise_partial_derivatives(Z,[&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(2,3,sharey=True,sharex=True,figsize=(7,6))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,0].imshow(Z[...,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,1].imshow(derivatives[...,0,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,2].imshow(derivatives[...,0,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,0].imshow(Z[...,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,1].imshow(derivatives[...,1,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-5,vmax=5,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,2].imshow(derivatives[...,1,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-5,vmax=5,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        **Expanding to output axes**:</span>

<span class="sd">        In some cases, you might have a field :math:`T_{ijk\ldots}(x,y)` and you may need</span>
<span class="sd">        :math:`\partial_\mu T_{ijk\ldots}(x,y,z)`. This can be achieved by declaring the `output_axes`</span>
<span class="sd">        argument.</span>

<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem3D</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">        &gt;&gt;&gt; cs = CartesianCoordinateSystem3D()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create the grid</span>
<span class="sd">        &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1,-1],[1,1,1]],[50,50,50],chunk_size=[5,5,5],ghost_zones=[2,2,2],center=&#39;cell&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create the field</span>
<span class="sd">        &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;,axes=[&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; Z = np.stack([np.sin((X**2+Y**2)),np.sin(5*(X**2+Y**2))],axis=-1) # (54,54,2)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">        &gt;&gt;&gt; derivatives = grid.dense_element_wise_partial_derivatives(Z,[&#39;x&#39;,&#39;y&#39;],output_axes=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])</span>
<span class="sd">        &gt;&gt;&gt; derivatives.shape</span>
<span class="sd">        (54, 54, 54, 2, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="p">,</span> <span class="n">field_axes_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>
        <span class="c1"># Confirm that the field matches the expected shape.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_field_shape</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">)</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="c1"># We do have some additional leg work to determine the element shape in this case.</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_axes</span><span class="p">)</span>
        <span class="n">element_shape</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:]</span>
        <span class="n">element_shape_out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">element_shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">output_element_shape</span><span class="o">=</span><span class="n">element_shape_out</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># --- Perform Gradient Operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Operation performed in chunks.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Cut the slice out of the input tensor field.</span>
                <span class="n">tensor_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">field</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Construct the coordinates from the slices.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">cov_grad</span> <span class="o">=</span> <span class="n">dense_element_wise_partial_derivatives</span><span class="p">(</span>
                    <span class="n">tensor_field_chunk</span><span class="p">,</span>
                    <span class="n">rank</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">output_indices</span><span class="o">=</span><span class="n">field_axes_indices</span><span class="p">,</span>  <span class="c1"># ensures we place grads into right slots.</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Assign to the output.</span>
                <span class="n">out</span><span class="p">[</span>
                    <span class="p">(</span>
                        <span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span>
                        <span class="o">...</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">cov_grad</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Operation performed in single call. Compute all</span>
            <span class="c1"># coordinates over the entire domain and then compute.</span>
            <span class="c1"># Cast the input field to the output axes.</span>
            <span class="n">reshaped_tensor_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>

            <span class="c1"># Compute the coordinates.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># Compute covariant gradient.</span>
            <span class="n">dense_element_wise_partial_derivatives</span><span class="p">(</span>
                <span class="n">reshaped_tensor_field</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="o">*</span><span class="n">coordinates</span><span class="p">,</span>
                <span class="n">output_indices</span><span class="o">=</span><span class="n">field_axes_indices</span><span class="p">,</span>  <span class="c1"># ensures we place grads into right slots.</span>
                <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Return the output buffer.</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_element_wise_laplacian">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_element_wise_laplacian.html#grids.mixins.mathops.DenseMathOpsMixin.dense_element_wise_laplacian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_element_wise_laplacian</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Lterm_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">derivative_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">second_derivative_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the element-wise Laplacian of an array-valued field on the grid.</span>

<span class="sd">        For an array field :math:`T_{\ldots}^{\ldots}`, this method computes the Laplacian</span>
<span class="sd">        of each element individually. The scalar Laplacian of an element :math:`\phi` is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla^2 \phi = \nabla \cdot \nabla \phi = \frac{1}{\rho} \partial_\mu \left( \rho g^{\mu\nu} \partial_\nu \phi \right)</span>

<span class="sd">        A numerically stable rearrangement is used in practice:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla^2 \phi = \frac{1}{\rho} \partial_\mu \left[ g^{\mu\nu} \rho \right] \partial_\nu \phi + g^{\mu\nu} \partial_\mu \partial_\nu \phi</span>
<span class="sd">                         = L^\nu \partial_\nu \phi + g^{\mu\nu} \partial_\mu \partial_\nu \phi</span>

<span class="sd">        This is the form used internally for stable, metric-aware computation.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            Internally calls either :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_diag` (for diagonal metrics)</span>
<span class="sd">            or :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_full` (for full metrics), depending on the coordinate system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : array-like</span>
<span class="sd">            The array-valued field on which to operate. This must meet all the</span>
<span class="sd">            necessary shape criteria (see Notes).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `tensor_field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        Lterm_field : array-like, optional</span>
<span class="sd">            The volume log-derivative field :math:`L^\nu = \frac{1}{\rho} \partial_\mu [g^{\mu\nu} \rho]`.</span>
<span class="sd">            If not provided, it is computed automatically using the coordinate system. This argument can be filled to</span>
<span class="sd">            reduce numerical error and improve computational efficiency if it is known.</span>

<span class="sd">            If specified, `Lterm_field` must be shape compliant (see Notes).</span>
<span class="sd">        inverse_metric_field : array-like, optional</span>
<span class="sd">            A buffer containing the inverse metric field :math:`g^{\mu\nu}`. `inverse_metric_field`</span>
<span class="sd">            can be provided to improve computation speed (by avoiding computing it in stride);</span>
<span class="sd">            however, it is not required.</span>

<span class="sd">            The inverse metric can be derived from the coordinate system when this</span>
<span class="sd">            argument is not provided. See `Notes` below</span>
<span class="sd">            for details on the shape of `inverse_metric_field`.</span>
<span class="sd">        derivative_field : array-like, optional</span>
<span class="sd">            A buffer containing the first derivatives of the field. Can be provided to improve</span>
<span class="sd">            computation speed (by avoiding computing it in stride); however, it is not required.</span>

<span class="sd">            If specified, `derivative_field` must be shape compliant (see Notes).</span>
<span class="sd">        second_derivative_field : array-like, optional</span>
<span class="sd">            A buffer containing the second derivatives of the field. Can be provided to improve</span>
<span class="sd">            computation speed (by avoiding computing it in stride); however, it is not required.</span>

<span class="sd">            If specified, `second_derivative_field` must be shape compliant (see Notes).</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_full` or</span>
<span class="sd">            :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_diag`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            Array of the same shape as `field`, optionally broadcast over additional axes.</span>
<span class="sd">            Contains the computed Laplacian :math:`\nabla^2 \phi` of each element in the input.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Shape and Broadcasting Requirements**</span>

<span class="sd">        The spatial dimensions of `field` must match the grid shape exactly over the `field_axes`.</span>
<span class="sd">        For a scalar field on a grid with shape ``(G1, ..., Gm)``, and `field_axes = [&#39;x&#39;, &#39;z&#39;]`,</span>
<span class="sd">        the field must have shape ``(Gₓ, G_z)``. For tensor fields, additional trailing dimensions</span>
<span class="sd">        (beyond the spatial ones) are interpreted as tensor indices and must either match `ndim` exactly</span>
<span class="sd">        or be nested in a form that makes the Laplacian contractable (i.e., act elementwise).</span>

<span class="sd">        The output shape will match the shape of `tensor_field` unless `output_axes` introduces</span>
<span class="sd">        additional broadcasting (e.g., singleton axes added by `broadcast_array_to_axes`).</span>

<span class="sd">        **Use of Auxiliary Fields**</span>

<span class="sd">        - `Lterm_field` is used to stabilize the Laplacian operator in curved coordinates.</span>
<span class="sd">        - `inverse_metric_field` allows skipping the on-the-fly metric computation.</span>
<span class="sd">        - `derivative_field` and `second_derivative_field` allow precomputing the necessary gradient terms.</span>

<span class="sd">        Each of these inputs must conform to specific shape constraints:</span>

<span class="sd">        - `Lterm_field`: (..., ndim)</span>
<span class="sd">        - `inverse_metric_field`: (..., ndim) or (..., ndim, ndim)</span>
<span class="sd">        - `derivative_field`: (..., ndim)</span>
<span class="sd">        - `second_derivative_field`: (..., ndim) or (..., ndim, ndim)</span>

<span class="sd">        **Chunked Execution**</span>

<span class="sd">        When `in_chunks=True`, the Laplacian is computed in small memory-efficient blocks with</span>
<span class="sd">        halo padding of 1 cell. This is especially useful when `tensor_field` and `out` are backed</span>
<span class="sd">        by HDF5 or other lazy-loading array backends. Chunking requires the grid to support</span>
<span class="sd">        `iter_chunk_slices(...)`.</span>

<span class="sd">        **Applicability**</span>

<span class="sd">        This method applies the scalar Laplacian element-wise to each component of the input field.</span>
<span class="sd">        It is appropriate for scalar fields, vector fields, or element-wise defined tensor fields</span>
<span class="sd">        in arbitrary curvilinear coordinates.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_element_wise_partial_derivatives: Generic form for general array-valued fields.</span>
<span class="sd">        dense_covariant_gradient: Covariant gradient of a tensor field.</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_gradient_contravariant_full: Low-level callable version (full metric)</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_gradient_contravariant_diag: Low-level callable version (diag metric)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">field_axes_indices</span><span class="p">,</span>
            <span class="n">output_axes_indices</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">)</span>
        <span class="n">differential_axes_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">_a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_axes</span><span class="p">)</span> <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">field_axes</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fixed_axes_and_values</span><span class="p">(</span>
            <span class="n">free_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_axes</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="c1"># --- Determine the correct operator --- #</span>
        <span class="c1"># We need to check the metric shape to determine.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">metric_tensor_symbol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">dense_scalar_laplacian_diag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">dense_scalar_laplacian_full</span>

        <span class="c1"># --- Perform the operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Compute the divergence in chunks. Broadly speaking, this proceeds in</span>
            <span class="c1"># the following order of operations:</span>
            <span class="c1"># 1. Ensure that chunking is supported.</span>
            <span class="c1"># 2. Determine if we are given the D-term and (if so), mark that</span>
            <span class="c1">#    we don&#39;t need to try to compute on each round.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="c1"># Determine if we need to try to generate the</span>
            <span class="c1"># D-term field for each chunk or if we can just grab it.</span>
            <span class="n">_try_F</span> <span class="o">=</span> <span class="n">Lterm_field</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">_try_metric</span> <span class="o">=</span> <span class="n">inverse_metric_field</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">_has_derivative</span> <span class="o">=</span> <span class="n">derivative_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">_has_second_derivative</span> <span class="o">=</span> <span class="n">second_derivative_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># Iterate through each of the chunk slices in the</span>
            <span class="c1"># output space.</span>
            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Compute coordinates. Cut down to the correct set of coordinates and</span>
                <span class="c1"># slices for the input field axes.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>
                <span class="n">differential_chunk_slices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">chunk_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>

                <span class="c1"># Broadcast the vector field onto the chunk.</span>
                <span class="n">vector_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">field</span><span class="p">[(</span><span class="o">*</span><span class="n">differential_chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Attempt to build the D-term if it is needed.</span>
                <span class="k">if</span> <span class="n">_try_F</span><span class="p">:</span>
                    <span class="n">Fterm_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">compute_expression_from_coordinates</span><span class="p">(</span>
                        <span class="s2">&quot;Lterm&quot;</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Fterm_chunk</span> <span class="o">=</span> <span class="n">Lterm_field</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span>

                <span class="k">if</span> <span class="n">_try_metric</span><span class="p">:</span>
                    <span class="n">inverse_metric_field_chunk</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">compute_expression_from_coordinates</span><span class="p">(</span>
                            <span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">,</span>
                            <span class="n">coordinates</span><span class="p">,</span>
                            <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inverse_metric_field_chunk</span> <span class="o">=</span> <span class="n">inverse_metric_field</span><span class="p">[</span>
                        <span class="p">(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                    <span class="p">]</span>

                <span class="c1"># If we have the derivative field, we need to cut into it.</span>
                <span class="k">if</span> <span class="n">_has_derivative</span><span class="p">:</span>
                    <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                        <span class="n">derivative_field</span><span class="p">[(</span><span class="o">*</span><span class="n">differential_chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                        <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                        <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">_has_second_derivative</span><span class="p">:</span>
                    <span class="n">second_derivative_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                        <span class="n">second_derivative_field</span><span class="p">[(</span><span class="o">*</span><span class="n">differential_chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                        <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                        <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">second_derivative_field_broadcast</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">out</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span> <span class="o">=</span> <span class="n">__op__</span><span class="p">(</span>
                    <span class="n">vector_field_chunk</span><span class="p">,</span>
                    <span class="n">Fterm_chunk</span><span class="p">,</span>
                    <span class="n">inverse_metric_field_chunk</span><span class="p">,</span>
                    <span class="n">rank</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                    <span class="n">derivative_field</span><span class="o">=</span><span class="n">derivative_field_broadcast</span><span class="p">,</span>
                    <span class="n">second_derivative_field</span><span class="o">=</span><span class="n">second_derivative_field_broadcast</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="o">=</span><span class="n">output_axes_indices</span><span class="p">,</span>
                    <span class="n">derivative_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Perform the operation in one pass. Broadly, the steps are</span>
            <span class="c1"># 1. Broadcast the field to the output axes for consistency.</span>
            <span class="c1"># 2. Compute the coordinates in the output axes space.</span>
            <span class="c1"># 3. Compute the Dterm_field if it is not provided.</span>
            <span class="c1"># 4. Broadcast the derivative field / 2nd derivative field if it is provided.</span>

            <span class="c1"># Broadcast to output axes. This will be (F1, ..., 1, ... FM) or something</span>
            <span class="c1"># of the sort.</span>
            <span class="n">tensor_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>

            <span class="c1"># Compute the output coordinates so that we can</span>
            <span class="c1"># perform the differentiation operation.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
            <span class="p">]</span>

            <span class="c1"># Broadcast required fields.</span>
            <span class="k">if</span> <span class="n">derivative_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">derivative_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">second_derivative_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">second_derivative_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">second_derivative_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">second_derivative_field_broadcast</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Create the D-term field over the free coordinates.</span>
            <span class="n">Lterm_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">Lterm_field</span><span class="p">,</span>
                <span class="s2">&quot;Lterm&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">inverse_metric_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">__op__</span><span class="p">(</span>
                <span class="n">tensor_field_broadcast</span><span class="p">,</span>
                <span class="n">Lterm_field</span><span class="p">,</span>
                <span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                <span class="n">field_axes</span><span class="o">=</span><span class="n">output_axes_indices</span><span class="p">,</span>
                <span class="n">derivative_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="n">first_derivative_field</span><span class="o">=</span><span class="n">derivative_field_broadcast</span><span class="p">,</span>
                <span class="n">second_derivative_field</span><span class="o">=</span><span class="n">second_derivative_field_broadcast</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


    <span class="c1"># ======================================= #</span>
    <span class="c1"># Dense Utils                             #</span>
    <span class="c1"># ======================================= #</span>
    <span class="c1"># These methods allow wrapping for methods</span>
    <span class="c1"># in `dense_utils`.</span>
<div class="viewcode-block" id="DenseMathOpsMixin.dense_contract_with_metric">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_contract_with_metric.html#grids.mixins.mathops.DenseMathOpsMixin.dense_contract_with_metric">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_contract_with_metric</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">tensor_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Contract a tensor index with the metric tensor or its inverse.</span>

<span class="sd">        This method raises or lowers a single index of a tensor field by contracting</span>
<span class="sd">        it with the metric tensor :math:`g_{\mu\nu}` or its inverse :math:`g^{\mu\nu}`.</span>

<span class="sd">        Depending on the mode:</span>

<span class="sd">        - ``mode=&#39;lower&#39;`` applies :math:`T^\mu \mapsto T_\nu = g_{\mu\nu} T^\mu`</span>
<span class="sd">        - ``mode=&#39;raise&#39;`` applies :math:`T_\mu \mapsto T^\nu = g^{\mu\nu} T_\mu`</span>

<span class="sd">        The appropriate form (full vs. diagonal) of the metric is automatically chosen based</span>
<span class="sd">        on the coordinate system&#39;s geometry.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            Internally wraps :func:`~differential_geometry.dense_utils.dense_contract_with_metric`,</span>
<span class="sd">            using the diagonal or full version depending on the metric type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor_field : array-like</span>
<span class="sd">            The tensor field whose index signature is to be adjusted.</span>
<span class="sd">            See `Notes` for more details on the shape requirements.</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `tensor_field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        index : int</span>
<span class="sd">            Slot to raise or lower (``0 &lt;= index &lt; rank``).</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;lower&#39;}, default &#39;lower&#39;</span>
<span class="sd">            Conversion direction. If ``&#39;raise&#39;``, then the inverse metric tensor is</span>
<span class="sd">            used in the contraction. Otherwise, the metric tensor is used.</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        metric_field : array-like, optional</span>
<span class="sd">            Optional precomputed metric or inverse metric to use in the contraction:</span>
<span class="sd">            - For ``mode=&#39;raise&#39;``, this must be the inverse metric.</span>
<span class="sd">            - For ``mode=&#39;lower&#39;``, this must be the metric.</span>

<span class="sd">            May be diagonal (shape ``(..., ndim)``) or full (``(..., ndim, ndim)``).</span>
<span class="sd">            If not provided, it is computed from the coordinate system.</span>
<span class="sd">            See `Notes` for more details on the shape requirements.</span>
<span class="sd">        in_chunks : bool, default False</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        pbar : bool, default True</span>
<span class="sd">            Show a progress bar when ``in_chunks=True``.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Extra keyword arguments forwarded to *tqdm*.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Passed straight to the low-level metric-contraction kernels</span>
<span class="sd">            (e.g. `where=` masks).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            The tensor with the selected slot converted.  Shape equals</span>
<span class="sd">            ``broadcast(grid_shape over output_axes) + element_shape``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Shape and Broadcasting Requirements**</span>

<span class="sd">        The shape of `tensor_field` must exactly match the grid shape over `field_axes`.</span>
<span class="sd">        Any trailing axes are treated as component dimensions of the tensor, and must match the</span>
<span class="sd">        expected rank.</span>

<span class="sd">        The `out` buffer (if supplied) must match the computed output shape.</span>

<span class="sd">        **Metric Input**</span>

<span class="sd">        If `metric_field` is not supplied, it is computed from the coordinate system.</span>
<span class="sd">        Supported metric shapes:</span>

<span class="sd">        - Diagonal metric: shape ``(..., ndim)``</span>
<span class="sd">        - Full metric: shape ``(..., ndim, ndim)``</span>

<span class="sd">        **Chunked Execution**</span>

<span class="sd">        When `in_chunks=True`, the grid is processed in small chunks (with ghost zones).</span>
<span class="sd">        This reduces memory overhead and improves performance with lazy buffers like HDF5.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_element_wise_partial_derivatives : Computes directional derivatives.</span>
<span class="sd">        dense_covariant_gradient : Computes the full covariant gradient of a tensor.</span>
<span class="sd">        ~differential_geometry.dense_utils.dense_contract_with_metric : Low-level backend for index contraction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="p">,</span> <span class="n">field_axes_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>
        <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fixed_axes_and_values</span><span class="p">(</span>
            <span class="n">free_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Determine the correct operator --- #</span>
        <span class="c1"># We need to check the metric shape to determine.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">metric_tensor_symbol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">_dense_contract_index_with_diagonal_metric</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">_dense_contract_index_with_metric</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="n">tensor_field_ndim</span><span class="p">,</span> <span class="n">tensor_field_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_field_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_axes</span><span class="p">)</span>
        <span class="n">tensor_field_element_shape</span> <span class="o">=</span> <span class="n">tensor_field_shape</span><span class="p">[</span><span class="n">tensor_field_ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:]</span>
        <span class="n">output_field_element_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tensor_field_element_shape</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">output_element_shape</span><span class="o">=</span><span class="n">output_field_element_shape</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># --- Perform Gradient Operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Operation performed in chunks.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="c1"># -- Create the chunk fetchers -- #</span>
            <span class="c1"># These allow us to seamlessly generate the correct</span>
            <span class="c1"># metric field over the chunks regardless of it being</span>
            <span class="c1"># pre-specified.</span>
            <span class="n">_metric_fetcher_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_expression_chunk_fetcher</span><span class="p">(</span>
                <span class="s2">&quot;inverse_metric_tensor&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="k">else</span> <span class="s2">&quot;metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">fixed_values</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Cycle through chunks.</span>
            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Compute coordinates. Cut down to the correct set of coordinates and</span>
                <span class="c1"># slices for the input field axes.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="n">tensor_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">tensor_field</span><span class="p">,</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Attempt to build the metric tensor.</span>
                <span class="n">metric_field_chunk</span> <span class="o">=</span> <span class="n">_metric_fetcher_</span><span class="p">(</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">out</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span> <span class="o">=</span> <span class="n">__op__</span><span class="p">(</span>
                    <span class="n">tensor_field_chunk</span><span class="p">,</span>
                    <span class="n">metric_field_chunk</span><span class="p">,</span>
                    <span class="n">index</span><span class="p">,</span>
                    <span class="n">rank</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Operation performed in single call. Compute all</span>
            <span class="c1"># coordinates over the entire domain and then compute.</span>
            <span class="c1"># Cast the input field to the output axes.</span>
            <span class="n">reshaped_tensor_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">tensor_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>

            <span class="c1"># Compute the coordinates over the output axes. The differential coordinates</span>
            <span class="c1"># are then also constructed.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># Ensure that the inverse metric tensor has been computed</span>
            <span class="c1"># on the coordinates.</span>
            <span class="n">metric_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">metric_field</span><span class="p">,</span>
                <span class="s2">&quot;inverse_metric_tensor&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span> <span class="k">else</span> <span class="s2">&quot;metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Compute covariant gradient.</span>
            <span class="n">__op__</span><span class="p">(</span>
                <span class="n">reshaped_tensor_field</span><span class="p">,</span>
                <span class="n">metric_field</span><span class="p">,</span>
                <span class="n">index</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Return the output buffer.</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_adjust_tensor_signature">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_adjust_tensor_signature.html#grids.mixins.mathops.DenseMathOpsMixin.dense_adjust_tensor_signature">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_adjust_tensor_signature</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">tensor_field</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">tensor_signature</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjust the index signature of a tensor field by raising or lowering multiple indices.</span>

<span class="sd">        This method converts the variance (covariant vs. contravariant) of one or more indices</span>
<span class="sd">        of a tensor field to match a desired target signature. The transformation is applied in a</span>
<span class="sd">        single pass using the appropriate metric tensor, which may be full or diagonal depending on</span>
<span class="sd">        the coordinate system.</span>

<span class="sd">        It generalizes :meth:`dense_contract_with_metric` to allow simultaneous transformation</span>
<span class="sd">        of multiple indices and automatically selects raise/lower operations based on the</span>
<span class="sd">        desired `tensor_signature`.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            Wraps :func:`~differential_geometry.dense_utils._dense_adjust_tensor_signature`</span>
<span class="sd">            or its diagonal-metric variant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor_field : array-like</span>
<span class="sd">            The input tensor field whose indices will be transformed. The array shape must match</span>
<span class="sd">            the grid over `field_axes` followed by `rank` trailing axes representing tensor components.</span>

<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `tensor_field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        indices : list of int</span>
<span class="sd">            Indices among the last `rank` axes to be modified.</span>
<span class="sd">        tensor_signature : list of int</span>
<span class="sd">            Current signature of the tensor&#39;s component axes. Must be of length `rank` and contain</span>
<span class="sd">            values `+1` for contravariant and `-1` for covariant indices.</span>

<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        metric_field, inverse_metric_field : array-like, optional</span>
<span class="sd">            Pre-computed metric and inverse metric used for the</span>
<span class="sd">            conversions.  Provide one or both to avoid recomputation.</span>
<span class="sd">            Shape rules follow :meth:`dense_contract_with_metric`.</span>
<span class="sd">        in_chunks: bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        pbar : bool, default True</span>
<span class="sd">            Show a progress bar when ``in_chunks=True``.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Extra keyword arguments forwarded to *tqdm*.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Passed straight to the low-level metric-contraction kernels</span>
<span class="sd">            (e.g. `where=` masks).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            Tensor with the specified slots in the requested variance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Signature Logic**</span>

<span class="sd">        For each index `k` in `indices`, this method compares the target signature with</span>
<span class="sd">        the current one from `tensor_signature`:</span>

<span class="sd">        - If ``tensor_signature[k] == -1`` and the index is currently contravariant, it is lowered.</span>
<span class="sd">        - If ``tensor_signature[k] == +1`` and the index is currently covariant, it is raised.</span>
<span class="sd">        - If already in the correct form, no operation is applied to that index.</span>

<span class="sd">        **Metric Field Requirements**</span>

<span class="sd">        Depending on the operation and coordinate system, the following metric shapes are supported:</span>

<span class="sd">        - Diagonal metric: shape ``(..., ndim)``</span>
<span class="sd">        - Full metric: shape ``(..., ndim, ndim)``</span>

<span class="sd">        If not provided, both metric and inverse metric are computed automatically</span>
<span class="sd">        from the coordinate system (globally or chunk-wise).</span>

<span class="sd">        **Chunked Execution**</span>

<span class="sd">        When `in_chunks=True`, the field is processed in chunks with halo padding.</span>
<span class="sd">        This is useful for HDF5-backed or large fields where full-domain memory</span>
<span class="sd">        use is undesirable.</span>

<span class="sd">        **Efficiency Tip**</span>

<span class="sd">        For repeated transformations over the same grid (e.g., adjusting multiple tensor fields),</span>
<span class="sd">        you can precompute `metric_field` and `inverse_metric_field` using</span>
<span class="sd">        :meth:`compute_function_on_grid` or similar and pass them in to avoid redundant evaluation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_contract_with_metric : Lower- or raise a single tensor index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="p">,</span> <span class="n">field_axes_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>
        <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fixed_axes_and_values</span><span class="p">(</span>
            <span class="n">free_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Determine the correct operator --- #</span>
        <span class="c1"># We need to check the metric shape to determine.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">metric_tensor_symbol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">_dense_adjust_tensor_signature_diagonal_metric</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">_dense_adjust_tensor_signature</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="n">tensor_field_ndim</span><span class="p">,</span> <span class="n">tensor_field_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_field_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_axes</span><span class="p">)</span>
        <span class="n">tensor_field_element_shape</span> <span class="o">=</span> <span class="n">tensor_field_shape</span><span class="p">[</span><span class="n">tensor_field_ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:]</span>
        <span class="n">output_field_element_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tensor_field_element_shape</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">output_element_shape</span><span class="o">=</span><span class="n">output_field_element_shape</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># --- Perform Gradient Operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Operation performed in chunks.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="c1"># -- Create the chunk fetchers -- #</span>
            <span class="c1"># These allow us to seamlessly generate the correct</span>
            <span class="c1"># metric field over the chunks regardless of it being</span>
            <span class="c1"># pre-specified.</span>
            <span class="n">_metric_fetcher_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_expression_chunk_fetcher</span><span class="p">(</span>
                <span class="s2">&quot;metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">fixed_values</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_inverse_metric_fetcher_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_expression_chunk_fetcher</span><span class="p">(</span>
                <span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">fixed_values</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Cycle through chunks.</span>
            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Compute coordinates. Cut down to the correct set of coordinates and</span>
                <span class="c1"># slices for the input field axes.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="n">tensor_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">tensor_field</span><span class="p">,</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Attempt to build the metric tensor.</span>
                <span class="n">metric_field_chunk</span> <span class="o">=</span> <span class="n">_metric_fetcher_</span><span class="p">(</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>
                <span class="n">inv_metric_field_chunk</span> <span class="o">=</span> <span class="n">_inverse_metric_fetcher_</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">coordinates</span>
                <span class="p">)</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">out</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span> <span class="o">=</span> <span class="n">__op__</span><span class="p">(</span>
                    <span class="n">tensor_field_chunk</span><span class="p">,</span>
                    <span class="n">indices</span><span class="p">,</span>
                    <span class="n">tensor_signature</span><span class="p">,</span>
                    <span class="n">metric_field</span><span class="o">=</span><span class="n">metric_field_chunk</span><span class="p">,</span>
                    <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inv_metric_field_chunk</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Operation performed in single call. Compute all</span>
            <span class="c1"># coordinates over the entire domain and then compute.</span>
            <span class="c1"># Cast the input field to the output axes.</span>
            <span class="n">reshaped_tensor_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">tensor_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>

            <span class="c1"># Compute the coordinates over the output axes. The differential coordinates</span>
            <span class="c1"># are then also constructed.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># Ensure that the inverse metric tensor has been computed</span>
            <span class="c1"># on the coordinates.</span>
            <span class="n">metric_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">metric_field</span><span class="p">,</span>
                <span class="s2">&quot;metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">inverse_metric_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">metric_field</span><span class="p">,</span>
                <span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Compute covariant gradient.</span>
            <span class="n">__op__</span><span class="p">(</span>
                <span class="n">reshaped_tensor_field</span><span class="p">,</span>
                <span class="n">indices</span><span class="p">,</span>
                <span class="n">tensor_signature</span><span class="p">,</span>
                <span class="n">metric_field</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
                <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Return the output buffer.</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="c1"># ============================================================ #</span>
    <span class="c1"># Index–raising / –lowering convenience wrappers               #</span>
    <span class="c1"># ============================================================ #</span>
<div class="viewcode-block" id="DenseMathOpsMixin.dense_raise_index">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_raise_index.html#grids.mixins.mathops.DenseMathOpsMixin.dense_raise_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_raise_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">tensor_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise a single covariant index of a tensor field.</span>

<span class="sd">        This method performs a metric contraction with the inverse metric tensor</span>
<span class="sd">        :math:`g^{\mu\nu}` to convert a covariant (lower) index to contravariant (upper)</span>
<span class="sd">        form. The `index` argument specifies which slot of the tensor should be raised.</span>

<span class="sd">        This is a specialized wrapper around :meth:`dense_contract_with_metric`</span>
<span class="sd">        with ``mode=&#39;raise&#39;``.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            Use this method to promote a component of a mixed or covariant tensor</span>
<span class="sd">            in curvilinear coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor_field : array-like</span>
<span class="sd">            The input tensor field. Its shape must be compatible with the grid dimensions</span>
<span class="sd">            over `field_axes`, followed by one or more component axes representing the tensor rank.</span>

<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the tensor field to raise. This should range from 0 to `rank` and is</span>
<span class="sd">            measured from the last spatial dimension of the tensor field.</span>
<span class="sd">        inverse_metric_field : array-like, optional</span>
<span class="sd">            A buffer containing the inverse metric field :math:`g^{\mu\nu}`. `inverse_metric_field`</span>
<span class="sd">            can be provided to improve computation speed (by avoiding computing it in stride);</span>
<span class="sd">            however, it is not required.</span>

<span class="sd">            The inverse metric can be derived from the coordinate system when this</span>
<span class="sd">            argument is not provided. See `Notes` below</span>
<span class="sd">            for details on the shape of `inverse_metric_field`.</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        in_chunks: bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        pbar : bool, default True</span>
<span class="sd">            Show a progress bar when ``in_chunks=True``.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Extra keyword arguments forwarded to *tqdm*.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Passed straight to the low-level metric-contraction kernels</span>
<span class="sd">            (e.g. `where=` masks).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            A tensor with the specified index raised. Shape equals</span>
<span class="sd">            ``broadcast(grid_shape over output_axes) + element_shape``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_contract_with_metric : General routine for index contraction with a metric.</span>
<span class="sd">        dense_lower_index : Inverse operation that lowers an index using the metric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_contract_with_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span>
            <span class="n">field_axes</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
            <span class="n">in_chunks</span><span class="o">=</span><span class="n">in_chunks</span><span class="p">,</span>
            <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
            <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
            <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_lower_index">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_lower_index.html#grids.mixins.mathops.DenseMathOpsMixin.dense_lower_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_lower_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">tensor_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Lower a single contravariant index of a tensor field.</span>

<span class="sd">        This method performs a metric contraction with the metric tensor</span>
<span class="sd">        :math:`g_{\mu\nu}` to convert a contravariant (upper) index to covariant (lower)</span>
<span class="sd">        form. The `index` argument specifies which slot of the tensor should be lowered.</span>

<span class="sd">        This is a specialized wrapper around :meth:`dense_contract_with_metric`</span>
<span class="sd">        with ``mode=&#39;lower&#39;``.</span>

<span class="sd">        .. hint::</span>
<span class="sd">            Use this method to convert a component of a vector or higher-rank tensor</span>
<span class="sd">            into covariant form in curved coordinate systems.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor_field : array-like</span>
<span class="sd">            The input tensor field. Its shape must be compatible with the grid dimensions</span>
<span class="sd">            over `field_axes`, followed by one or more component axes representing the tensor rank.</span>

<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        index : int</span>
<span class="sd">            The index of the tensor field to raise. This should range from 0 to `rank` and is</span>
<span class="sd">            measured from the last spatial dimension of the tensor field.</span>
<span class="sd">        metric_field : array-like, optional</span>
<span class="sd">            A buffer containing the metric field :math:`g_{\mu\nu}`. `metric_field`</span>
<span class="sd">            can be provided to improve computation speed (by avoiding computing it in stride);</span>
<span class="sd">            however, it is not required.</span>

<span class="sd">            The metric can be derived from the coordinate system when this</span>
<span class="sd">            argument is not provided. See `Notes` below</span>
<span class="sd">            for details on the shape of `metric_field`.</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        in_chunks: bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        pbar : bool, default True</span>
<span class="sd">            Show a progress bar when ``in_chunks=True``.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Extra keyword arguments forwarded to *tqdm*.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Passed straight to the low-level metric-contraction kernels</span>
<span class="sd">            (e.g. `where=` masks).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            A tensor with the specified index lowered. Shape equals</span>
<span class="sd">            ``broadcast(grid_shape over output_axes) + element_shape``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_contract_with_metric : General routine for index contraction with a metric.</span>
<span class="sd">        dense_raise_index : Inverse operation that raises an index using the inverse metric.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_contract_with_metric</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="p">,</span>
            <span class="n">field_axes</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;lower&quot;</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">metric_field</span><span class="o">=</span><span class="n">metric_field</span><span class="p">,</span>
            <span class="n">in_chunks</span><span class="o">=</span><span class="n">in_chunks</span><span class="p">,</span>
            <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
            <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
            <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># ======================================= #</span>
    <span class="c1"># Gradient Methods                        #</span>
    <span class="c1"># ======================================= #</span>
    <span class="c1"># These methods are used for computing the gradient</span>
    <span class="c1"># on grids.</span>
<div class="viewcode-block" id="DenseMathOpsMixin.dense_covariant_gradient">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_covariant_gradient.html#grids.mixins.mathops.DenseMathOpsMixin.dense_covariant_gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_covariant_gradient</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">tensor_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the covariant gradient of a dense-representation tensor field on a grid.</span>

<span class="sd">        For a tensor field :math:`T_{\ldots}^{\ldots}({\bf x})`, the covariant gradient is the</span>
<span class="sd">        rank :math:`rank(T)+1` tensor :math:`T_{\ldots\mu}^{\ldots}({\bf x})` such that</span>

<span class="sd">        .. math::</span>

<span class="sd">            T_{\ldots \mu}^{\ldots}({\bf x}) = \partial_\mu T_{\ldots}^{\ldots}({\bf x}).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor_field : array-like</span>
<span class="sd">            The tensor field on which to compute the partial derivatives. This should be an array-like object</span>
<span class="sd">            with a compliant shape (see `Notes` below).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `tensor_field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_compute_gradient_covariant`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            The computed partial derivatives. The resulting array will have a field shape matching the grid&#39;s</span>
<span class="sd">            shape over the `output_axes` and an element shape matching that of `field` but with an additional `(ndim,)`</span>
<span class="sd">            sized dimension containing each of the partial derivatives for each index.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Broadcasting and Array Shapes**:</span>

<span class="sd">        The input ``tensor_field`` must have a very precise shape to be valid for this operation. If the underlying grid</span>
<span class="sd">        (**including ghost zones**) has shape ``grid_shape = (G_1,...,G_ndim)``, then the spatial dimensions of the field must</span>
<span class="sd">        match exactly ``grid_shape[axes]``. Any remaining dimensions of the ``field`` are treated as densely populated tensor indices</span>
<span class="sd">        and therefore must **each** have :attr:`~grids.base.GridBase.ndim` elements.</span>

<span class="sd">        Thus, if a ``(G1,G3,ndim,ndim,...)`` field is passed with ``field_axes = [&#39;x&#39;,&#39;z&#39;]`` (in cartesian coordinates), then</span>
<span class="sd">        the resulting output array will have shape ``(G1,G3,ndim,ndim,...,ndim)`` and ``out[...,1] == 0`` because the field does not</span>
<span class="sd">        contain any variability over the ``y`` variable.</span>

<span class="sd">        If ``output_axes`` is specified, then that resulting grid will be broadcast to any additional grid axes necessary.</span>

<span class="sd">        When ``out`` is specified, it must match (exactly) the expected output buffer shape or an error will arise.</span>

<span class="sd">        **Chunking Semantics**:</span>

<span class="sd">        When ``in_chunks=True``, chunking is enabled for this operation. In that case, the ``out`` buffer is filled</span>
<span class="sd">        iteratively by performing computations on each chunk of the grid over the specified `output_axes`. When the</span>
<span class="sd">        computation is performed, each chunk is extracted with an additional 1-cell halo to ensure that :func:`numpy.gradient`</span>
<span class="sd">        attains its maximal accuracy on each chunk.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Chunking is (generally) only useful when ``out`` and ``tensor_field`` are array-like lazy-loaded buffers like</span>
<span class="sd">            HDF5 datasets. In those cases, the maximum memory load is only that required to load each individual chunk.</span>
<span class="sd">            If the ``out`` buffer is not specified, it is allocated fully anyways, making chunking somewhat redundant.</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_element_wise_partial_derivatives: Generic form for general array-valued fields.</span>
<span class="sd">        dense_contravariant_gradient: Contravariant gradient of a tensor field.</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_compute_gradient_covariant: Low-level callable version.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Covariant Gradient of a Scalar Field**</span>

<span class="sd">        The easiest example is the derivative of a generic scalar field.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem2D</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = CartesianCoordinateSystem2D()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1],[1,1]],[500,500],chunk_size=[50,50],ghost_zones=[[2,2],[2,2]],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;)</span>
<span class="sd">            &gt;&gt;&gt; Z = np.sin((X**2+Y**2))</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives = grid.dense_covariant_gradient(Z,[&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(1,3,sharey=True,sharex=True,figsize=(7,3))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0].imshow(Z.T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1].imshow(derivatives[...,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[2].imshow(derivatives[...,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        **Derivatives of a vector field**:</span>

<span class="sd">        Similarly, this can be applied to vector field (or more general tensor field).</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem2D</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = CartesianCoordinateSystem2D()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1],[1,1]],[500,500],chunk_size=[50,50],ghost_zones=[[2,2],[2,2]],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;)</span>
<span class="sd">            &gt;&gt;&gt; Z = np.stack([np.sin((X**2+Y**2)),np.sin(5*(X**2+Y**2))],axis=-1) # (504,504,2)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives = grid.dense_covariant_gradient(Z,[&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(2,3,sharey=True,sharex=True,figsize=(7,6))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,0].imshow(Z[...,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,1].imshow(derivatives[...,0,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,2].imshow(derivatives[...,0,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,0].imshow(Z[...,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,1].imshow(derivatives[...,1,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-5,vmax=5,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,2].imshow(derivatives[...,1,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-5,vmax=5,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        **Expanding to output axes**:</span>

<span class="sd">        In some cases, you might have a field :math:`T_{ijk\ldots}(x,y)` and you may need</span>
<span class="sd">        :math:`\partial_\mu T_{ijk\ldots}(x,y,z)`. This can be achieved by declaring the `output_axes`</span>
<span class="sd">        argument.</span>

<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem3D</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">        &gt;&gt;&gt; cs = CartesianCoordinateSystem3D()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create the grid</span>
<span class="sd">        &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1,-1],[1,1,1]],[50,50,50],chunk_size=[5,5,5],ghost_zones=[2,2,2],center=&#39;cell&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Create the field</span>
<span class="sd">        &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;,axes=[&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">        &gt;&gt;&gt; Z = np.stack([np.sin((X**2+Y**2)),np.sin(5*(X**2+Y**2)),np.zeros_like(X)],axis=-1) # (54,54,3)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">        &gt;&gt;&gt; derivatives = grid.dense_covariant_gradient(Z,[&#39;x&#39;,&#39;y&#39;],output_axes=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])</span>
<span class="sd">        &gt;&gt;&gt; derivatives.shape</span>
<span class="sd">        (54, 54, 54, 3, 3)</span>

<span class="sd">        **Inconsistent Input Field**:</span>

<span class="sd">        Note that in the previous example, we required</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            Z = np.stack([np.sin((X**2+Y**2)),np.sin(5*(X**2+Y**2)),np.zeros_like(X)],axis=-1) # (54,54,3)</span>

<span class="sd">        to have an additional element. This is because :meth:`dense_covariant_gradient` requires dense representations. The</span>
<span class="sd">        same result can be achieved under less strict conventions with :meth:`dense_element_wise_partial_derivatives`.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            Z = np.stack([np.sin((X**2+Y**2)),np.sin(5*(X**2+Y**2))],axis=-1) # (54,54,3)</span>
<span class="sd">            derivatives = grid.dense_covariant_gradient(Z,[&#39;x&#39;,&#39;y&#39;],output_axes=[&#39;x&#39;,&#39;y&#39;,&#39;z&#39;])</span>
<span class="sd">            ValueError: Incompatible full field shape.</span>
<span class="sd">              Expected: (54, 54, 3)</span>
<span class="sd">              Found   : (54, 54, 2)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="p">,</span> <span class="n">field_axes_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_axes</span><span class="p">)</span>
        <span class="n">element_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:]</span>
        <span class="n">element_shape_out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">element_shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span>

        <span class="c1"># Check the input field first.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_field_shape</span><span class="p">(</span>
            <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">field_shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span> <span class="o">*</span> <span class="n">rank</span>
        <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">output_element_shape</span><span class="o">=</span><span class="n">element_shape_out</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># --- Perform Gradient Operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Operation performed in chunks.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Cut the slice out of the input tensor field.</span>
                <span class="n">tensor_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">tensor_field</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Construct the coordinates from the slices.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">cov_grad</span> <span class="o">=</span> <span class="n">dense_gradient_covariant</span><span class="p">(</span>
                    <span class="n">tensor_field_chunk</span><span class="p">,</span>
                    <span class="n">rank</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">output_indices</span><span class="o">=</span><span class="n">field_axes_indices</span><span class="p">,</span>  <span class="c1"># ensures we place grads into right slots.</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Assign to the output.</span>
                <span class="n">out</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cov_grad</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Operation performed in single call. Compute all</span>
            <span class="c1"># coordinates over the entire domain and then compute.</span>
            <span class="c1"># Cast the input field to the output axes.</span>
            <span class="n">reshaped_tensor_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">tensor_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>

            <span class="c1"># Compute the coordinates.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># Compute covariant gradient.</span>
            <span class="n">dense_gradient_covariant</span><span class="p">(</span>
                <span class="n">reshaped_tensor_field</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                <span class="o">*</span><span class="n">coordinates</span><span class="p">,</span>
                <span class="n">output_indices</span><span class="o">=</span><span class="n">field_axes_indices</span><span class="p">,</span>  <span class="c1"># ensures we place grads into right slots.</span>
                <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Return the output buffer.</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_contravariant_gradient">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_contravariant_gradient.html#grids.mixins.mathops.DenseMathOpsMixin.dense_contravariant_gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_contravariant_gradient</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">tensor_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the contravariant gradient of a dense-representation tensor field on a grid.</span>

<span class="sd">        For a tensor field :math:`T_{\ldots}^{\ldots}({\bf x})`, the contravariant gradient is the</span>
<span class="sd">        rank :math:`rank(T)+1` tensor :math:`T_{\ldots\mu}^{\ldots}({\bf x})` such that</span>

<span class="sd">        .. math::</span>

<span class="sd">            T_{\ldots}^{\ldots\mu}({\bf x}) = g^{\mu\nu}\partial_\nu T_{\ldots}^{\ldots}({\bf x}).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor_field : array-like</span>
<span class="sd">            The tensor field on which to compute the partial derivatives. This should be an array-like object</span>
<span class="sd">            with a compliant shape (see `Notes` below).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `tensor_field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        inverse_metric_field : array-like, optional</span>
<span class="sd">            A buffer containing the inverse metric field :math:`g^{\mu\nu}`. `inverse_metric_field`</span>
<span class="sd">            can be provided to improve computation speed (by avoiding computing it in stride);</span>
<span class="sd">            however, it is not required.</span>

<span class="sd">            The inverse metric can be derived from the coordinate system when this</span>
<span class="sd">            argument is not provided. See `Notes` below</span>
<span class="sd">            for details on the shape of `inverse_metric_field`.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_compute_gradient_contravariant_full`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            The computed partial derivatives. The resulting array will have a field shape matching the grid&#39;s</span>
<span class="sd">            shape over the `output_axes` and an element shape matching that of `field` but with an additional `(ndim,)`</span>
<span class="sd">            sized dimension containing each of the partial derivatives for each index.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Broadcasting and Array Shapes**:</span>

<span class="sd">        The input ``tensor_field`` must have a very precise shape to be valid for this operation. If the underlying grid</span>
<span class="sd">        (**including ghost zones**) has shape ``grid_shape = (G_1,...,G_ndim)``, then the spatial dimensions of the field must</span>
<span class="sd">        match exactly ``grid_shape[axes]``. Any remaining dimensions of the ``field`` are treated as densely populated tensor indices</span>
<span class="sd">        and therefore must **each** have :attr:`~grids.base.GridBase.ndim` elements.</span>

<span class="sd">        Thus, if a ``(G1,G3,ndim,ndim,...)`` field is passed with ``field_axes = [&#39;x&#39;,&#39;z&#39;]`` (in cartesian coordinates), then</span>
<span class="sd">        the resulting output array will have shape ``(G1,G3,ndim,ndim,...,ndim)`` and ``out[...,1] == 0`` because the field does not</span>
<span class="sd">        contain any variability over the ``y`` variable.</span>

<span class="sd">        If ``output_axes`` is specified, then that resulting grid will be broadcast to any additional grid axes necessary.</span>

<span class="sd">        When ``out`` is specified, it must match (exactly) the expected output buffer shape or an error will arise.</span>

<span class="sd">        **Chunking Semantics**:</span>

<span class="sd">        When ``in_chunks=True``, chunking is enabled for this operation. In that case, the ``out`` buffer is filled</span>
<span class="sd">        iteratively by performing computations on each chunk of the grid over the specified `output_axes`. When the</span>
<span class="sd">        computation is performed, each chunk is extracted with an additional 1-cell halo to ensure that :func:`numpy.gradient`</span>
<span class="sd">        attains its maximal accuracy on each chunk.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Chunking is (generally) only useful when ``out`` and ``tensor_field`` are array-like lazy-loaded buffers like</span>
<span class="sd">            HDF5 datasets. In those cases, the maximum memory load is only that required to load each individual chunk.</span>
<span class="sd">            If the ``out`` buffer is not specified, it is allocated fully anyways, making chunking somewhat redundant.</span>

<span class="sd">        **Inverse Metric**:</span>

<span class="sd">        In most cases, the inverse metric is computed by the coordinate system behind the scenes; however, it may be</span>
<span class="sd">        provided directly in cases where doing so is convenient. If this is done, the provided field must have a</span>
<span class="sd">        spatial portion corresponding to the grid&#39;s shape (including ghost zones) over the **output axes**. Depending on</span>
<span class="sd">        the coordinate system, the provided metric may either be a rank-2 array (non-orthogonal coordinate systems) or</span>
<span class="sd">        a rank-1 array (orthogonal coordinate systems) in which each element corresponds to the diagonal element. The</span>
<span class="sd">        correct low-level callable is determined based on the coordinate system&#39;s type.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_element_wise_partial_derivatives: Generic form for general array-valued fields.</span>
<span class="sd">        dense_covariant_gradient: Covariant gradient of a tensor field.</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_compute_gradient_contravariant_full: Low-level callable version (full metric)</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_compute_gradient_contravariant_diag: Low-level callable version (diag metric)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Contravariant Gradient of a Scalar Field**</span>

<span class="sd">        The easiest example is the derivative of a generic scalar field. In cartesian coordinates, this should</span>
<span class="sd">        behave exactly the same as the covariant gradient.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem2D</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = CartesianCoordinateSystem2D()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1],[1,1]],[500,500],chunk_size=[50,50],ghost_zones=[[2,2],[2,2]],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;)</span>
<span class="sd">            &gt;&gt;&gt; Z = np.sin((X**2+Y**2))</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives = grid.dense_contravariant_gradient(Z,[&#39;x&#39;,&#39;y&#39;])</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(1,3,sharey=True,sharex=True,figsize=(7,3))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0].imshow(Z.T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1].imshow(derivatives[...,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[2].imshow(derivatives[...,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        In the more interesting case, we might consider the contravariant gradient in a non-cartesian coordinate system!</span>
<span class="sd">        Let</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi(r,\theta) = r^2 \cos(2\theta).</span>

<span class="sd">        The covariant gradient is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla_\mu \phi = \left[ 2r \cos(2\theta), \; -2r^2 \sin(2\theta) \right],</span>

<span class="sd">        while the contravariant gradient is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla^\mu \phi = g^{\mu\mu} \nabla_\mu \phi = \left[ 2r \cos(2\theta),\; -2\sin(2\theta) \right].</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[0,1],[0,np.pi],[0,2*np.pi]],</span>
<span class="sd">            ...                   [500,50,50],</span>
<span class="sd">            ...                   chunk_size=[50,50,50],</span>
<span class="sd">            ...                   ghost_zones=[2,2,2],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; R, THETA = grid.compute_domain_mesh(origin=&#39;global&#39;,axes=[&#39;r&#39;,&#39;theta&#39;])</span>
<span class="sd">            &gt;&gt;&gt; Z = (R**2) * np.cos(2*THETA)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives_cont = grid.dense_contravariant_gradient(Z,[&#39;r&#39;,&#39;theta&#39;])</span>
<span class="sd">            &gt;&gt;&gt; derivatives_co = grid.dense_covariant_gradient(Z,[&#39;r&#39;,&#39;theta&#39;])</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(2,3,sharey=True,sharex=True,figsize=(7,6))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,0].imshow(Z.T                 ,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,1].imshow(derivatives_co[...,0].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,2].imshow(derivatives_cont[...,0].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,0].imshow(Z.T                 ,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,1].imshow(derivatives_co[...,1].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,2].imshow(derivatives_cont[...,1].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="p">,</span> <span class="n">field_axes_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>
        <span class="n">differential_axes_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">_a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_axes</span><span class="p">)</span> <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">field_axes</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fixed_axes_and_values</span><span class="p">(</span>
            <span class="n">free_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Determine the correct operator --- #</span>
        <span class="c1"># We need to check the metric shape to determine.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">metric_tensor_symbol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">dense_gradient_contravariant_diag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">dense_gradient_contravariant_full</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="n">tensor_field_ndim</span><span class="p">,</span> <span class="n">tensor_field_shape</span> <span class="o">=</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">tensor_field</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">rank</span> <span class="o">=</span> <span class="n">tensor_field_ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">field_axes</span><span class="p">)</span>
        <span class="n">tensor_field_element_shape</span> <span class="o">=</span> <span class="n">tensor_field_shape</span><span class="p">[</span><span class="n">tensor_field_ndim</span> <span class="o">-</span> <span class="n">rank</span> <span class="p">:]</span>
        <span class="n">output_field_element_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tensor_field_element_shape</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">output_element_shape</span><span class="o">=</span><span class="n">output_field_element_shape</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tensor_field</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># --- Perform Gradient Operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Operation performed in chunks.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="c1"># -- Create the chunk fetchers -- #</span>
            <span class="c1"># These allow us to seamlessly generate the correct</span>
            <span class="c1"># metric field over the chunks regardless of it being</span>
            <span class="c1"># pre-specified.</span>
            <span class="n">_metric_fetcher_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_expression_chunk_fetcher</span><span class="p">(</span>
                <span class="s2">&quot;inverse_metric_field&quot;</span><span class="p">,</span>
                <span class="n">fixed_values</span><span class="p">,</span>
                <span class="n">value</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Cycle through chunks.</span>
            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Compute coordinates. Cut down to the correct set of coordinates and</span>
                <span class="c1"># slices for the input field axes.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>
                <span class="n">differential_chunk_slices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">chunk_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>

                <span class="n">tensor_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">tensor_field</span><span class="p">[(</span><span class="o">*</span><span class="n">differential_chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Attempt to build the metric tensor.</span>
                <span class="n">inverse_metric_field_chunk</span> <span class="o">=</span> <span class="n">_metric_fetcher_</span><span class="p">(</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">out</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span> <span class="o">=</span> <span class="n">__op__</span><span class="p">(</span>
                    <span class="n">tensor_field_chunk</span><span class="p">,</span>
                    <span class="n">inverse_metric_field_chunk</span><span class="p">,</span>
                    <span class="n">rank</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                    <span class="n">output_indices</span><span class="o">=</span><span class="n">field_axes_indices</span><span class="p">,</span>  <span class="c1"># ensures we place grads into right slots.</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Operation performed in single call. Compute all</span>
            <span class="c1"># coordinates over the entire domain and then compute.</span>
            <span class="c1"># Cast the input field to the output axes.</span>
            <span class="n">reshaped_tensor_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">tensor_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>

            <span class="c1"># Compute the coordinates over the output axes. The differential coordinates</span>
            <span class="c1"># are then also constructed.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
            <span class="p">]</span>

            <span class="c1"># Ensure that the inverse metric tensor has been computed</span>
            <span class="c1"># on the coordinates.</span>
            <span class="n">inverse_metric_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Compute covariant gradient.</span>
            <span class="n">__op__</span><span class="p">(</span>
                <span class="n">reshaped_tensor_field</span><span class="p">,</span>
                <span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="n">rank</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
                <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                <span class="n">field_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                <span class="n">output_indices</span><span class="o">=</span><span class="n">field_axes_indices</span><span class="p">,</span>  <span class="c1"># ensures we place grads into right slots.</span>
                <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Return the output buffer.</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_gradient">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_gradient.html#grids.mixins.mathops.DenseMathOpsMixin.dense_gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_gradient</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">tensor_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">basis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;contravariant&quot;</span><span class="p">,</span> <span class="s2">&quot;covariant&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;covariant&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the element-wise gradient of a tensor field over a grid.</span>

<span class="sd">        :meth:`dense_gradient` is a wrapper around the two basis-dependent gradient methods</span>
<span class="sd">        (:meth:`dense_contravariant_gradient` and :meth:`dense_covariant_gradient`) and uses the `basis` input</span>
<span class="sd">        to determine the correct method to direct the call sequence to.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tensor_field : array-like</span>
<span class="sd">            The tensor field on which to compute the partial derivatives. This should be an array-like object</span>
<span class="sd">            with a compliant shape (see `Notes` below).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `tensor_field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        inverse_metric_field : array-like, optional</span>
<span class="sd">            A buffer containing the inverse metric field :math:`g^{\mu\nu}`. `inverse_metric_field`</span>
<span class="sd">            can be provided to improve computation speed (by avoiding computing it in stride);</span>
<span class="sd">            however, it is not required.</span>

<span class="sd">            The inverse metric can be derived from the coordinate system when this</span>
<span class="sd">            argument is not provided. See `Notes` below</span>
<span class="sd">            for details on the shape of `inverse_metric_field`.</span>
<span class="sd">        basis: {&#39;contravariant&#39;, &#39;covariant&#39;}, optional</span>
<span class="sd">            The basis in which to compute the gradient tensor. If ``&quot;covariant&quot;``, then the gradient tensor will simply</span>
<span class="sd">            be the element-wise partial derivatives. If ``&quot;contravariant&quot;``, then the covariant solution will have its index</span>
<span class="sd">            raised using the `inverse_metric_field`.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_compute_gradient_covariant`,</span>
<span class="sd">            or :func:`~differential_geometry.dense_ops.dense_compute_gradient_contravariant_full`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            The computed partial derivatives. The resulting array will have a field shape matching the grid&#39;s</span>
<span class="sd">            shape over the `output_axes` and an element shape matching that of `field` but with an additional `(ndim,)`</span>
<span class="sd">            sized dimension containing each of the partial derivatives for each index.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Broadcasting and Array Shapes**:</span>

<span class="sd">        The input ``tensor_field`` must have a very precise shape to be valid for this operation. If the underlying grid</span>
<span class="sd">        (**including ghost zones**) has shape ``grid_shape = (G_1,...,G_ndim)``, then the spatial dimensions of the field must</span>
<span class="sd">        match exactly ``grid_shape[axes]``. Any remaining dimensions of the ``field`` are treated as densely populated tensor indices</span>
<span class="sd">        and therefore must **each** have :attr:`~grids.base.GridBase.ndim` elements.</span>

<span class="sd">        Thus, if a ``(G1,G3,ndim,ndim,...)`` field is passed with ``field_axes = [&#39;x&#39;,&#39;z&#39;]`` (in cartesian coordinates), then</span>
<span class="sd">        the resulting output array will have shape ``(G1,G3,ndim,ndim,...,ndim)`` and ``out[...,1] == 0`` because the field does not</span>
<span class="sd">        contain any variability over the ``y`` variable.</span>

<span class="sd">        If ``output_axes`` is specified, then that resulting grid will be broadcast to any additional grid axes necessary.</span>

<span class="sd">        When ``out`` is specified, it must match (exactly) the expected output buffer shape or an error will arise.</span>

<span class="sd">        **Chunking Semantics**:</span>

<span class="sd">        When ``in_chunks=True``, chunking is enabled for this operation. In that case, the ``out`` buffer is filled</span>
<span class="sd">        iteratively by performing computations on each chunk of the grid over the specified `output_axes`. When the</span>
<span class="sd">        computation is performed, each chunk is extracted with an additional 1-cell halo to ensure that :func:`numpy.gradient`</span>
<span class="sd">        attains its maximal accuracy on each chunk.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Chunking is (generally) only useful when ``out`` and ``tensor_field`` are array-like lazy-loaded buffers like</span>
<span class="sd">            HDF5 datasets. In those cases, the maximum memory load is only that required to load each individual chunk.</span>
<span class="sd">            If the ``out`` buffer is not specified, it is allocated fully anyways, making chunking somewhat redundant.</span>

<span class="sd">        **Inverse Metric**:</span>

<span class="sd">        In most cases, the inverse metric is computed by the coordinate system behind the scenes; however, it may be</span>
<span class="sd">        provided directly in cases where doing so is convenient. If this is done, the provided field must have a</span>
<span class="sd">        spatial portion corresponding to the grid&#39;s shape (including ghost zones) over the **output axes**. Depending on</span>
<span class="sd">        the coordinate system, the provided metric may either be a rank-2 array (non-orthogonal coordinate systems) or</span>
<span class="sd">        a rank-1 array (orthogonal coordinate systems) in which each element corresponds to the diagonal element. The</span>
<span class="sd">        correct low-level callable is determined based on the coordinate system&#39;s type.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_element_wise_partial_derivatives: Generic form for general array-valued fields.</span>
<span class="sd">        dense_covariant_gradient: Covariant gradient of a tensor field.</span>
<span class="sd">        dense_contravariant_gradient: Contravariant gradient of a tensor field.</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_compute_gradient_contravariant_full: Low-level callable version (full metric)</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_compute_gradient_contravariant_diag: Low-level callable version (diag metric)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Contravariant Gradient of a Scalar Field**</span>

<span class="sd">        The easiest example is the derivative of a generic scalar field. In cartesian coordinates, this should</span>
<span class="sd">        behave exactly the same as the covariant gradient.</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import CartesianCoordinateSystem2D</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = CartesianCoordinateSystem2D()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[-1,-1],[1,1]],[500,500],chunk_size=[50,50],ghost_zones=[[2,2],[2,2]],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; X,Y = grid.compute_domain_mesh(origin=&#39;global&#39;)</span>
<span class="sd">            &gt;&gt;&gt; Z = np.sin((X**2+Y**2))</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives = grid.dense_gradient(Z,[&#39;x&#39;,&#39;y&#39;],basis=&#39;contravariant&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(1,3,sharey=True,sharex=True,figsize=(7,3))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0].imshow(Z.T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1].imshow(derivatives[...,0].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[2].imshow(derivatives[...,1].T,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-1,vmax=1,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>

<span class="sd">        In the more interesting case, we might consider the contravariant gradient in a non-cartesian coordinate system!</span>
<span class="sd">        Let</span>

<span class="sd">        .. math::</span>

<span class="sd">            \phi(r,\theta) = r^2 \cos(2\theta).</span>

<span class="sd">        The covariant gradient is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla_\mu \phi = \left[ 2r \cos(2\theta), \; -2r^2 \sin(2\theta) \right],</span>

<span class="sd">        while the contravariant gradient is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla^\mu \phi = g^{\mu\mu} \nabla_\mu \phi = \left[ 2r \cos(2\theta),\; -2\sin(2\theta) \right].</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[0,1],[0,np.pi],[0,2*np.pi]],</span>
<span class="sd">            ...                   [500,50,50],</span>
<span class="sd">            ...                   chunk_size=[50,50,50],</span>
<span class="sd">            ...                   ghost_zones=[2,2,2],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; R, THETA = grid.compute_domain_mesh(origin=&#39;global&#39;,axes=[&#39;r&#39;,&#39;theta&#39;])</span>
<span class="sd">            &gt;&gt;&gt; Z = (R**2) * np.cos(2*THETA)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the partial derivatives.</span>
<span class="sd">            &gt;&gt;&gt; derivatives_cont = grid.dense_gradient(Z,[&#39;r&#39;,&#39;theta&#39;],basis=&#39;contravariant&#39;)</span>
<span class="sd">            &gt;&gt;&gt; derivatives_co = grid.dense_gradient(Z,[&#39;r&#39;,&#39;theta&#39;],basis=&#39;covariant&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(2,3,sharey=True,sharex=True,figsize=(7,6))</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,0].imshow(Z.T                 ,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,1].imshow(derivatives_co[...,0].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[0,2].imshow(derivatives_cont[...,0].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,0].imshow(Z.T                 ,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,1].imshow(derivatives_co[...,1].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes[1,2].imshow(derivatives_cont[...,1].T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-2,vmax=2,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distinguish the basis and proceed to the low-level callable</span>
        <span class="c1"># depending on which basis is specified.</span>
        <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;covariant&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_covariant_gradient</span><span class="p">(</span>
                    <span class="n">tensor_field</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">in_chunks</span><span class="o">=</span><span class="n">in_chunks</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                    <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                    <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to compute covariant gradient: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;contravariant&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_contravariant_gradient</span><span class="p">(</span>
                    <span class="n">tensor_field</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
                    <span class="n">in_chunks</span><span class="o">=</span><span class="n">in_chunks</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                    <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                    <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to compute covariant gradient: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`basis` must be &#39;covariant&#39; or &#39;contravariant&#39;, not &#39;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span></div>


    <span class="c1"># ======================================= #</span>
    <span class="c1"># Divergence Methods                      #</span>
    <span class="c1"># ======================================= #</span>
    <span class="c1"># These methods are used to compute the divergence of</span>
    <span class="c1"># a field.</span>
<div class="viewcode-block" id="DenseMathOpsMixin.dense_vector_divergence_contravariant">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_vector_divergence_contravariant.html#grids.mixins.mathops.DenseMathOpsMixin.dense_vector_divergence_contravariant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_vector_divergence_contravariant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">vector_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Dterm_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">derivative_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the divergence of a contravariant vector field on a grid.</span>

<span class="sd">        For a contravariant vector field :math:`V^\mu`, the divergence is given by:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla \cdot V = \frac{1}{\rho} \partial_\mu(\rho V^\mu)</span>
<span class="sd">                           = \partial_\mu V^\mu + V^\mu \frac{\partial_\mu \rho}{\rho}</span>

<span class="sd">        This expanded form is used for improved numerical stability and implemented</span>
<span class="sd">        as a sum of a standard derivative and a geometry-aware &quot;D-term&quot;.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector_field : array-like</span>
<span class="sd">            The vector field on which to compute the divergence. This should be an array-like object</span>
<span class="sd">            with a compliant shape (see `Notes` below).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        Dterm_field : array-like, optional</span>
<span class="sd">            The D-term field for the specific coordinate system. This can be specified to improve computation speed; however,</span>
<span class="sd">            it can also be derived directly from the grid&#39;s coordinate system. If it is provided, it should be compliant with</span>
<span class="sd">            the shaping / broadcasting rules (see `Notes`).</span>
<span class="sd">        derivative_field : array-like, optional</span>
<span class="sd">            The first derivatives of the `vector_field`. `derivative_field` can be specified to improve computational speed or</span>
<span class="sd">            to improve accuracy if the derivatives are known analytically; however, they can also be computed numerically if</span>
<span class="sd">            not provided. If `derivative_field` is provided, it must comply with the shaping / broadcasting rules (see `Notes`).</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_vector_divergence_contravariant`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            The computed partial derivatives. The resulting array will have a field shape matching the grid&#39;s</span>
<span class="sd">            shape over the `output_axes` and an element shape matching that of `field` but with an additional `(ndim,)`</span>
<span class="sd">            sized dimension containing each of the partial derivatives for each index.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Broadcasting and Array Shapes**:</span>

<span class="sd">        The input ``vector_field`` must have a very precise shape to be valid for this operation. If the underlying grid</span>
<span class="sd">        (**including ghost zones**) has shape ``grid_shape = (G_1,...,G_ndim)``, then the spatial dimensions of the field must</span>
<span class="sd">        match exactly ``grid_shape[axes]``. ``vector_field`` should have 1 additional dimension representing the vector components</span>
<span class="sd">        which must have a size of :attr:`~grids.base.GridBase.ndim`. The resulting output array will be a scalar field over</span>
<span class="sd">        the relevant grid axes.</span>

<span class="sd">        Thus, if a ``(G1,G3,ndim)`` field is passed with ``field_axes = [&#39;x&#39;,&#39;z&#39;]`` (in cartesian coordinates), then</span>
<span class="sd">        the resulting output array will have shape ``(G1,G3)``.</span>

<span class="sd">        If ``output_axes`` is specified, then that resulting grid will be broadcast to any additional grid axes necessary.</span>

<span class="sd">        If either ``derivative_field`` or ``Dterm_field`` are not provided, then they must each be provided over the ``output_axes``</span>
<span class="sd">        (if they are specified, otherwise ``field_axes``). The ``Dterm_field`` should have 1 additional dimension of size</span>
<span class="sd">        :attr:`~grid.base.GridBase.ndim` containing each of the elements of the covector field. The ``derivative_field`` must</span>
<span class="sd">        also be specified over the ``output_axes`` (if they are specified, otherwise ``field_axes``), but can have any number</span>
<span class="sd">        of elements in its 1 additional dimension (corresponding to the set of non-zero derivatives).</span>

<span class="sd">        When ``out`` is specified, it must match (exactly) the expected output buffer shape or an error will arise.</span>

<span class="sd">        **Chunking Semantics**:</span>

<span class="sd">        When ``in_chunks=True``, chunking is enabled for this operation. In that case, the ``out`` buffer is filled</span>
<span class="sd">        iteratively by performing computations on each chunk of the grid over the specified `output_axes`. When the</span>
<span class="sd">        computation is performed, each chunk is extracted with an additional 1-cell halo to ensure that :func:`numpy.gradient`</span>
<span class="sd">        attains its maximal accuracy on each chunk.</span>

<span class="sd">        .. note::</span>

<span class="sd">            Chunking is (generally) only useful when ``out`` and ``vector_field`` are array-like lazy-loaded buffers like</span>
<span class="sd">            HDF5 datasets. In those cases, the maximum memory load is only that required to load each individual chunk.</span>
<span class="sd">            If the ``out`` buffer is not specified, it is allocated fully anyways, making chunking somewhat redundant.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        In Spherical Coordinates, the divergence is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla \cdot V = \frac{1}{r^2}\partial_r\left(r^2V^r\right) + \frac{1}{\sin \theta} \partial_\theta \left(\sin \theta V^\theta\right)</span>
<span class="sd">            + \partial_\phi V^\phi.</span>

<span class="sd">        As such, if :math:`V^\mu = \left(r cos \theta,\; \sin\theta,\; 0\right)`, then</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla \cdot V = \frac{\cos \theta}{r^2}\partial_r r^3 + \frac{1}{\sin \theta}\partial_\theta \sin^2\theta = 5 \cos \theta.</span>

<span class="sd">        To see this numerically, we can do the following:</span>

<span class="sd">        .. plot::</span>
<span class="sd">            :include-source:</span>

<span class="sd">            &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">            &gt;&gt;&gt; from pymetric.coordinates import SphericalCoordinateSystem</span>
<span class="sd">            &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the coordinate system</span>
<span class="sd">            &gt;&gt;&gt; cs = SphericalCoordinateSystem()</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the grid</span>
<span class="sd">            &gt;&gt;&gt; grid = UniformGrid(cs,[[0,0,0],[1,np.pi,2*np.pi]],</span>
<span class="sd">            ...                   [500,50,50],</span>
<span class="sd">            ...                   chunk_size=[50,50,50],</span>
<span class="sd">            ...                   ghost_zones=[2,2,2],center=&#39;cell&#39;)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Create the field</span>
<span class="sd">            &gt;&gt;&gt; R, THETA = grid.compute_domain_mesh(origin=&#39;global&#39;,axes=[&#39;r&#39;,&#39;theta&#39;])</span>
<span class="sd">            &gt;&gt;&gt; Z = np.stack([R * np.cos(THETA), np.sin(THETA), np.zeros_like(R)],axis=-1)</span>
<span class="sd">            &gt;&gt;&gt; Z.shape</span>
<span class="sd">            (504, 54, 3)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Compute the divergence.</span>
<span class="sd">            &gt;&gt;&gt; DivZ = grid.dense_vector_divergence_contravariant(Z,[&#39;r&#39;,&#39;theta&#39;],in_chunks=True)</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; fig,axes = plt.subplots(1,1)</span>
<span class="sd">            &gt;&gt;&gt; _ = axes.imshow(DivZ.T,aspect=&#39;auto&#39;,origin=&#39;lower&#39;,extent=grid.gbbox.T.ravel(),vmin=-5,vmax=5,cmap=&#39;coolwarm&#39;)</span>
<span class="sd">            &gt;&gt;&gt; plt.show()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">field_axes_indices</span><span class="p">,</span>
            <span class="n">output_axes_indices</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">)</span>
        <span class="n">differential_axes_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">_a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_axes</span><span class="p">)</span> <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">field_axes</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fixed_axes_and_values</span><span class="p">(</span>
            <span class="n">free_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vector_field</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="c1"># --- Perform the operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Compute the divergence in chunks. Broadly speaking, this proceeds in</span>
            <span class="c1"># the following order of operations:</span>
            <span class="c1"># 1. Ensure that chunking is supported.</span>
            <span class="c1"># 2. Determine if we are given the D-term and (if so), mark that</span>
            <span class="c1">#    we don&#39;t need to try to compute on each round.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="c1"># Determine if we need to try to generate the</span>
            <span class="c1"># D-term field for each chunk or if we can just grab it.</span>
            <span class="n">_Dterm_generator_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_expression_chunk_fetcher</span><span class="p">(</span>
                <span class="s2">&quot;Dterm&quot;</span><span class="p">,</span> <span class="n">fixed_values</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">Dterm_field</span>
            <span class="p">)</span>

            <span class="n">_has_derivative</span> <span class="o">=</span> <span class="n">derivative_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># Iterate through each of the chunk slices in the</span>
            <span class="c1"># output space.</span>
            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Compute coordinates. Cut down to the correct set of coordinates and</span>
                <span class="c1"># slices for the input field axes.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>
                <span class="n">differential_chunk_slices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">chunk_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>

                <span class="c1"># Broadcast the vector field onto the chunk.</span>
                <span class="n">vector_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">vector_field</span><span class="p">[(</span><span class="o">*</span><span class="n">differential_chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Attempt to build the D-term if it is needed.</span>
                <span class="n">Dterm_chunk</span> <span class="o">=</span> <span class="n">_Dterm_generator_</span><span class="p">(</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>

                <span class="c1"># If we have the derivative field, we need to cut into it.</span>
                <span class="k">if</span> <span class="n">_has_derivative</span><span class="p">:</span>
                    <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                        <span class="n">derivative_field</span><span class="p">[(</span><span class="o">*</span><span class="n">differential_chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                        <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                        <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">out</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dense_vector_divergence_contravariant</span><span class="p">(</span>
                    <span class="n">vector_field_chunk</span><span class="p">,</span>
                    <span class="n">Dterm_chunk</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                    <span class="n">derivative_field</span><span class="o">=</span><span class="n">derivative_field_broadcast</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="o">=</span><span class="n">output_axes_indices</span><span class="p">,</span>
                    <span class="n">derivative_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Perform the operation in one pass. Broadly, the steps are</span>
            <span class="c1"># 1. Broadcast the field to the output axes for consistency.</span>
            <span class="c1"># 2. Compute the coordinates in the output axes space.</span>
            <span class="c1"># 3. Compute the Dterm_field if it is not provided.</span>
            <span class="c1"># 4. Broadcast the derivative field if it is provided.</span>

            <span class="c1"># Broadcast to output axes. This will be (F1, ..., 1, ... FM) or something</span>
            <span class="c1"># of the sort.</span>
            <span class="n">vector_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">vector_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">derivative_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">derivative_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">derivative_field_broadcast</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Compute the output coordinates so that we can</span>
            <span class="c1"># perform the differentiation operation.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
            <span class="p">]</span>

            <span class="c1"># Create the D-term field over the free coordinates.</span>
            <span class="n">Dterm_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">Dterm_field</span><span class="p">,</span>
                <span class="s2">&quot;Dterm&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">dense_vector_divergence_contravariant</span><span class="p">(</span>
                <span class="n">vector_field_broadcast</span><span class="p">,</span>
                <span class="n">Dterm_field</span><span class="p">,</span>
                <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                <span class="n">derivative_field</span><span class="o">=</span><span class="n">derivative_field_broadcast</span><span class="p">,</span>
                <span class="n">field_axes</span><span class="o">=</span><span class="n">output_axes_indices</span><span class="p">,</span>
                <span class="n">derivative_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_vector_divergence_covariant">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_vector_divergence_covariant.html#grids.mixins.mathops.DenseMathOpsMixin.dense_vector_divergence_covariant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_vector_divergence_covariant</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">vector_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Dterm_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the divergence of a covariant vector field on a grid.</span>

<span class="sd">        For a covariant vector field :math:`V_\mu`, the divergence is:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla \cdot V = \frac{1}{\rho} \partial_\mu(\rho g^{\mu\nu} V_\nu)</span>

<span class="sd">        Expanded for numerical stability:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla \cdot V = g^{\mu\nu} V_\nu \frac{\partial_\mu \rho}{\rho}</span>
<span class="sd">                           + \partial_\mu(g^{\mu\nu} V_\nu)</span>

<span class="sd">        This form is used internally, with precomputed or on-the-fly inverse metrics.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector_field : array-like</span>
<span class="sd">            The vector field on which to compute the divergence. This should be an array-like object</span>
<span class="sd">            with a compliant shape (see `Notes` below).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        Dterm_field : array-like, optional</span>
<span class="sd">            The D-term field for the specific coordinate system. This can be specified to improve computation speed; however,</span>
<span class="sd">            it can also be derived directly from the grid&#39;s coordinate system. If it is provided, it should be compliant with</span>
<span class="sd">            the shaping / broadcasting rules (see `Notes`).</span>
<span class="sd">        inverse_metric_field : array-like, optional</span>
<span class="sd">            A buffer containing the inverse metric field :math:`g^{\mu\nu}`. `inverse_metric_field`</span>
<span class="sd">            can be provided to improve computation speed (by avoiding computing it in stride);</span>
<span class="sd">            however, it is not required.</span>

<span class="sd">            The inverse metric can be derived from the coordinate system when this</span>
<span class="sd">            argument is not provided. See `Notes` below</span>
<span class="sd">            for details on the shape of `inverse_metric_field`.</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_vector_divergence_contravariant`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array‑like</span>
<span class="sd">            Scalar divergence on the grid.  The shape equals the broadcasted</span>
<span class="sd">            grid shape over ``output_axes`` (ghost zones included when the grid</span>
<span class="sd">            carries them).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Broadcasting &amp; shapes**</span>

<span class="sd">        If the full grid (including ghosts) has shape</span>
<span class="sd">        ``grid_shape = (G1, …, G_ndim)``, then</span>

<span class="sd">        * ``vector_field[..., k]`` must match ``grid_shape[field_axes[k]]``.</span>
<span class="sd">        * ``out`` must match ``grid_shape[output_axes]``.</span>
<span class="sd">        * ``Dterm_field`` and ``inverse_metric_field`` (when supplied) must be</span>
<span class="sd">          broadcast‑compatible with the same grid shape.</span>

<span class="sd">        **Chunking semantics**</span>

<span class="sd">        When ``in_chunks=True`` the routine iterates over the grid’s stored</span>
<span class="sd">        chunks, fetching or generating the necessary D‑terms and inverse</span>
<span class="sd">        metric on each sub‑domain.  A one‑cell halo is automatically included</span>
<span class="sd">        to maintain gradient accuracy, and progress is reported through</span>
<span class="sd">        *tqdm*.</span>

<span class="sd">        **Inverse Metric**:</span>

<span class="sd">        In most cases, the inverse metric is computed by the coordinate system behind the scenes; however, it may be</span>
<span class="sd">        provided directly in cases where doing so is convenient. If this is done, the provided field must have a</span>
<span class="sd">        spatial portion corresponding to the grid&#39;s shape (including ghost zones) over the **output axes**. Depending on</span>
<span class="sd">        the coordinate system, the provided metric may either be a rank-2 array (non-orthogonal coordinate systems) or</span>
<span class="sd">        a rank-1 array (orthogonal coordinate systems) in which each element corresponds to the diagonal element. The</span>
<span class="sd">        correct low-level callable is determined based on the coordinate system&#39;s type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Divergence of a covariant field in *2‑D cylindrical coordinates*</span>
<span class="sd">        \((r, z)\):</span>

<span class="sd">        &gt;&gt;&gt; from pymetric.grids.core import UniformGrid</span>
<span class="sd">        &gt;&gt;&gt; from pymetric.coordinates import CylindricalCoordinateSystem</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Coordinate system &amp; grid</span>
<span class="sd">        &gt;&gt;&gt; cs = CylindricalCoordinateSystem()       # (r, φ, z) – φ suppressed</span>
<span class="sd">        &gt;&gt;&gt; grid = UniformGrid(cs,</span>
<span class="sd">        ...     [[0,0,0],[1,2*np.pi,1]],</span>
<span class="sd">        ...     [400, 10, 200],ghost_zones=1,center=&#39;cell&#39;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Covariant vector: V_r = r, V_z = z</span>
<span class="sd">        &gt;&gt;&gt; R, Z = grid.compute_domain_mesh(origin=&#39;global&#39;, axes=[&#39;rho&#39;, &#39;z&#39;])</span>
<span class="sd">        &gt;&gt;&gt; Vcov = np.stack([R,np.zeros_like(R), Z], axis=-1)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Divergence (automatic metric &amp; D‑term)</span>
<span class="sd">        &gt;&gt;&gt; div = grid.dense_vector_divergence_covariant(</span>
<span class="sd">        ...     Vcov, [&#39;rho&#39;, &#39;z&#39;])</span>
<span class="sd">        &gt;&gt;&gt; div.shape</span>
<span class="sd">        (402, 202)</span>
<span class="sd">        &gt;&gt;&gt; bool(np.isclose(div.mean(),3.0))   # → analytical result for this field is constant 3</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># --- Preparing axes --- #</span>
        <span class="c1"># To prepare the axes, we need to ensure that they are standardized and</span>
        <span class="c1"># then check for subsets. We also extract the indices so that they</span>
        <span class="c1"># can be used for various low-level callables.</span>
        <span class="p">(</span>
            <span class="n">field_axes</span><span class="p">,</span>
            <span class="n">output_axes</span><span class="p">,</span>
            <span class="n">field_axes_indices</span><span class="p">,</span>
            <span class="n">output_axes_indices</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_input_output_axes</span><span class="p">(</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">)</span>
        <span class="n">differential_axes_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[</span><span class="n">_i</span> <span class="k">for</span> <span class="n">_i</span><span class="p">,</span> <span class="n">_a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output_axes</span><span class="p">)</span> <span class="k">if</span> <span class="n">_a</span> <span class="ow">in</span> <span class="n">field_axes</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">fixed_axes</span><span class="p">,</span> <span class="n">fixed_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_fixed_axes_and_values</span><span class="p">(</span>
            <span class="n">free_axes</span><span class="o">=</span><span class="n">output_axes</span>
        <span class="p">)</span>

        <span class="c1"># --- Allocate `out` --- #</span>
        <span class="c1"># Having now determined the correct output axes, we can</span>
        <span class="c1"># simply generate the output. This logic is encapsulated in `_prepare_output_buffer`.</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_output_buffer</span><span class="p">(</span>
            <span class="n">output_axes</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">vector_field</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="c1"># --- Determine the correct operator --- #</span>
        <span class="c1"># We need to check the metric shape to determine.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">metric_tensor_symbol</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">dense_vector_divergence_covariant_diag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">__op__</span> <span class="o">=</span> <span class="n">dense_vector_divergence_covariant_full</span>

        <span class="c1"># --- Perform the operation --- #</span>
        <span class="k">if</span> <span class="n">in_chunks</span><span class="p">:</span>
            <span class="c1"># Compute the divergence in chunks. Broadly speaking, this proceeds in</span>
            <span class="c1"># the following order of operations:</span>
            <span class="c1"># 1. Ensure that chunking is supported.</span>
            <span class="c1"># 2. Determine if we are given the D-term and (if so), mark that</span>
            <span class="c1">#    we don&#39;t need to try to compute on each round.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_supports_chunking</span><span class="p">()</span>

            <span class="c1"># Determine if we need to try to generate the</span>
            <span class="c1"># D-term field for each chunk or if we can just grab it.</span>
            <span class="n">_try_D</span> <span class="o">=</span> <span class="n">Dterm_field</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">_try_metric</span> <span class="o">=</span> <span class="n">inverse_metric_field</span> <span class="ow">is</span> <span class="kc">None</span>

            <span class="c1"># Iterate through each of the chunk slices in the</span>
            <span class="c1"># output space.</span>
            <span class="k">for</span> <span class="n">chunk_slices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_chunk_slices</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="n">include_ghosts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">halo_offsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">oob_behavior</span><span class="o">=</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span>
                <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Compute coordinates. Cut down to the correct set of coordinates and</span>
                <span class="c1"># slices for the input field axes.</span>
                <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coords_from_slices</span><span class="p">(</span>
                    <span class="n">chunk_slices</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>
                <span class="n">differential_chunk_slices</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">chunk_slices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
                <span class="p">]</span>

                <span class="c1"># Broadcast the vector field onto the chunk.</span>
                <span class="n">vector_field_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                    <span class="n">vector_field</span><span class="p">[(</span><span class="o">*</span><span class="n">differential_chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)],</span>
                    <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="c1"># Attempt to build the D-term if it is needed.</span>
                <span class="k">if</span> <span class="n">_try_D</span><span class="p">:</span>
                    <span class="n">Dterm_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">compute_expression_from_coordinates</span><span class="p">(</span>
                        <span class="s2">&quot;Dterm&quot;</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">Dterm_chunk</span> <span class="o">=</span> <span class="n">Dterm_field</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span>

                <span class="c1"># Attempt to build the metric tensor.</span>
                <span class="k">if</span> <span class="n">_try_metric</span><span class="p">:</span>
                    <span class="n">inverse_metric_field_chunk</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">compute_expression_from_coordinates</span><span class="p">(</span>
                            <span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">,</span>
                            <span class="n">coordinates</span><span class="p">,</span>
                            <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inverse_metric_field_chunk</span> <span class="o">=</span> <span class="n">inverse_metric_field</span><span class="p">[</span>
                        <span class="p">(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                    <span class="p">]</span>

                <span class="c1"># Compute the covariant gradient.</span>
                <span class="n">out</span><span class="p">[(</span><span class="o">*</span><span class="n">chunk_slices</span><span class="p">,</span> <span class="o">...</span><span class="p">)]</span> <span class="o">=</span> <span class="n">__op__</span><span class="p">(</span>
                    <span class="n">vector_field_chunk</span><span class="p">,</span>
                    <span class="n">Dterm_chunk</span><span class="p">,</span>
                    <span class="n">inverse_metric_field_chunk</span><span class="p">,</span>
                    <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="o">=</span><span class="n">output_axes_indices</span><span class="p">,</span>
                    <span class="n">derivative_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Perform the operation in one pass. Broadly, the steps are</span>
            <span class="c1"># 1. Broadcast the field to the output axes for consistency.</span>
            <span class="c1"># 2. Compute the coordinates in the output axes space.</span>
            <span class="c1"># 3. Compute the Dterm_field if it is not provided.</span>
            <span class="c1"># 4. Broadcast the derivative field if it is provided.</span>

            <span class="c1"># Broadcast to output axes. This will be (F1, ..., 1, ... FM) or something</span>
            <span class="c1"># of the sort.</span>
            <span class="n">vector_field_broadcast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">broadcast_array_to_axes</span><span class="p">(</span>
                <span class="n">vector_field</span><span class="p">,</span> <span class="n">axes_in</span><span class="o">=</span><span class="n">field_axes</span><span class="p">,</span> <span class="n">axes_out</span><span class="o">=</span><span class="n">output_axes</span>
            <span class="p">)</span>

            <span class="c1"># Compute the output coordinates so that we can</span>
            <span class="c1"># perform the differentiation operation.</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_domain_coords</span><span class="p">(</span>
                <span class="n">axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;global&quot;</span><span class="p">,</span> <span class="n">__validate__</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">differential_coordinates</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">differential_axes_indices</span>
            <span class="p">]</span>

            <span class="c1"># Create the D-term field over the free coordinates.</span>
            <span class="n">Dterm_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">Dterm_field</span><span class="p">,</span>
                <span class="s2">&quot;Dterm&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">inverse_metric_field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cs__</span><span class="o">.</span><span class="n">requires_expression_from_coordinates</span><span class="p">(</span>
                <span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="s2">&quot;inverse_metric_tensor&quot;</span><span class="p">,</span>
                <span class="n">coordinates</span><span class="p">,</span>
                <span class="n">fixed_axes</span><span class="o">=</span><span class="n">fixed_values</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">__op__</span><span class="p">(</span>
                <span class="n">vector_field_broadcast</span><span class="p">,</span>
                <span class="n">Dterm_field</span><span class="p">,</span>
                <span class="n">inverse_metric_field</span><span class="p">,</span>
                <span class="o">*</span><span class="n">differential_coordinates</span><span class="p">,</span>
                <span class="n">field_axes</span><span class="o">=</span><span class="n">output_axes_indices</span><span class="p">,</span>
                <span class="n">derivative_axes</span><span class="o">=</span><span class="n">differential_axes_indices</span><span class="p">,</span>
                <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_vector_divergence">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_vector_divergence.html#grids.mixins.mathops.DenseMathOpsMixin.dense_vector_divergence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_vector_divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">vector_field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">basis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;covariant&quot;</span><span class="p">,</span> <span class="s2">&quot;contravariant&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;contravariant&quot;</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Dterm_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">derivative_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the divergence of a vector field, with automatic basis dispatching.</span>

<span class="sd">        This is a convenience wrapper around:</span>
<span class="sd">        - :meth:`dense_vector_divergence_contravariant` if `basis=&#39;contravariant&#39;`</span>
<span class="sd">        - :meth:`dense_vector_divergence_covariant` if `basis=&#39;covariant&#39;`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vector_field : array-like</span>
<span class="sd">            The vector field on which to compute the divergence. This should be an array-like object</span>
<span class="sd">            with a compliant shape (see `Notes` below).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        basis : {&#39;contravariant&#39;, &#39;covariant&#39;}, optional</span>
<span class="sd">            The basis in which the input vector field is represented:</span>

<span class="sd">            - If ``&#39;contravariant&#39;`` (default), the input is assumed to be a contravariant vector</span>
<span class="sd">              :math:`V^\mu`, and the divergence is computed directly using:</span>

<span class="sd">              .. math:: \nabla \cdot V = \partial_\mu V^\mu + D_\mu V^\mu</span>

<span class="sd">              The `inverse_metric_field` is **not** required or used. The `derivative_field` can be</span>
<span class="sd">              supplied in this case.</span>

<span class="sd">            - If ``&#39;covariant&#39;``, the input is assumed to be a covector field :math:`V_\mu`.</span>
<span class="sd">              In this case, the divergence is computed via:</span>

<span class="sd">              .. math:: \nabla \cdot V = \frac{1}{\rho} \partial_\mu(\rho g^{\mu\nu} V_\nu)</span>

<span class="sd">              which requires contraction with the **inverse metric** :math:`g^{\mu\nu}`.</span>
<span class="sd">              If not provided, this is derived automatically from the coordinate system. The</span>
<span class="sd">              `derivative_field` is ignored for this basis.</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        Dterm_field : array-like, optional</span>
<span class="sd">            The D-term field :math:`D_\mu = \frac{\partial_\mu \rho}{\rho}` for the coordinate system,</span>
<span class="sd">            where :math:`\rho = \sqrt{|g|}` is the metric volume element.</span>

<span class="sd">            If not provided, it is computed automatically from the coordinate system. Supplying it</span>
<span class="sd">            can improve performance or accuracy.</span>

<span class="sd">            The array must be broadcast-compatible with the grid shape over `output_axes`, and have a final</span>
<span class="sd">            dimension of size equal to `ndim`, one per coordinate direction.</span>

<span class="sd">        inverse_metric_field : array-like, optional</span>
<span class="sd">            The inverse metric tensor :math:`g^{\mu\nu}` used to raise covariant components.</span>

<span class="sd">            This field is only required if ``basis=&#39;covariant&#39;`` and will be ignored in contravariant mode.</span>

<span class="sd">            If omitted, it is computed from the coordinate system. The expected shape depends on the metric type:</span>

<span class="sd">            - For diagonal (orthogonal) metrics: shape `(..., ndim)`</span>
<span class="sd">            - For full (non-orthogonal) metrics: shape `(..., ndim, ndim)`</span>

<span class="sd">            In both cases, the leading shape must match the grid domain over `output_axes`.</span>

<span class="sd">        derivative_field : array-like, optional</span>
<span class="sd">            The first derivatives of the input vector field :math:`\partial_\mu V^\nu`.</span>

<span class="sd">            This is optional—if not provided, derivatives are computed numerically. If known analytically</span>
<span class="sd">            or precomputed, supplying this can improve accuracy and reduce compute time.</span>

<span class="sd">            The array must be broadcast-compatible with the grid over `output_axes`, and its final dimension</span>
<span class="sd">            should match the number of coordinate axes over which derivatives are taken (typically `ndim`).</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_vector_divergence_contravariant`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array‑like</span>
<span class="sd">            Scalar divergence on the grid.  The shape equals the broadcasted</span>
<span class="sd">            grid shape over ``output_axes`` (ghost zones included when the grid</span>
<span class="sd">            carries them).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - The divergence formula used depends on the input `basis`. The `contravariant` case requires only the vector field</span>
<span class="sd">          and optionally its derivatives. The `covariant` case requires the inverse metric for contraction.</span>

<span class="sd">        - If `output_axes` is provided, all fields (`vector_field`, `Dterm_field`, etc.) must be broadcastable over that domain.</span>

<span class="sd">        - If `in_chunks=True`, each chunk is extended by a 1-cell halo for stencil accuracy and processed independently.</span>
<span class="sd">          Chunking is useful when working with HDF5-backed or lazily loaded buffers.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_vector_divergence_contravariant : Compute divergence for contravariant vectors.</span>
<span class="sd">        dense_vector_divergence_covariant : Compute divergence for covariant vectors.</span>
<span class="sd">        dense_divergence : Basis-dispatching divergence for arbitrary-rank tensors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Distinguish the basis and proceed to the low-level callable</span>
        <span class="c1"># depending on which basis is specified.</span>
        <span class="k">if</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;covariant&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_vector_divergence_covariant</span><span class="p">(</span>
                    <span class="n">vector_field</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">Dterm_field</span><span class="o">=</span><span class="n">Dterm_field</span><span class="p">,</span>
                    <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
                    <span class="n">in_chunks</span><span class="o">=</span><span class="n">in_chunks</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                    <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                    <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to compute covariant gradient: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">elif</span> <span class="n">basis</span> <span class="o">==</span> <span class="s2">&quot;contravariant&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_vector_divergence_contravariant</span><span class="p">(</span>
                    <span class="n">vector_field</span><span class="p">,</span>
                    <span class="n">field_axes</span><span class="p">,</span>
                    <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">Dterm_field</span><span class="o">=</span><span class="n">Dterm_field</span><span class="p">,</span>
                    <span class="n">derivative_field</span><span class="o">=</span><span class="n">derivative_field</span><span class="p">,</span>
                    <span class="n">in_chunks</span><span class="o">=</span><span class="n">in_chunks</span><span class="p">,</span>
                    <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
                    <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
                    <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
                    <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to compute covariant gradient: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;`basis` must be &#39;covariant&#39; or &#39;contravariant&#39;, not &#39;</span><span class="si">{</span><span class="n">basis</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="DenseMathOpsMixin.dense_scalar_laplacian">
<a class="viewcode-back" href="../../../_as_gen/grids.mixins.mathops.DenseMathOpsMixin.dense_scalar_laplacian.html#grids.mixins.mathops.DenseMathOpsMixin.dense_scalar_laplacian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dense_scalar_laplacian</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">_SupDGMO</span><span class="p">,</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">field_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Lterm_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inverse_metric_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">derivative_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">second_derivative_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">in_chunks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">edge_order</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">output_axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pbar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pbar_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the element-wise Laplacian of a tensor field.</span>

<span class="sd">        For a generic array field :math:`T_{\ldots}^{\ldots}`, the Laplacian of a given element (denoted :math:`\phi`) is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla^2 \phi = \nabla \cdot \nabla \phi = \frac{1}{\rho}\partial_\mu \left(\rho g^{\mu\nu} \partial_\nu \phi\right).</span>

<span class="sd">        A more numerically stable expression of this result is</span>

<span class="sd">        .. math::</span>

<span class="sd">            \nabla^2\phi = \frac{1}{\rho}\partial_\mu \left[g^{\mu\nu} \rho\right] \partial_\nu \phi + g^{\mu\nu} \partial_\mu\partial_\nu \phi</span>
<span class="sd">            = L^\nu \partial_\nu \phi + g^{\mu\nu} \partial_\mu\partial_\nu \phi.</span>

<span class="sd">        This is the formula used here.</span>

<span class="sd">        .. hint::</span>

<span class="sd">            This method wraps the low-level :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_full` or</span>
<span class="sd">            (if the metric tensor is diagonal), it wraps :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_diag`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        field : array-like</span>
<span class="sd">            The tensor field on which to operate. This must meet all the</span>
<span class="sd">            necessary shape criteria (see Notes).</span>
<span class="sd">        field_axes : list of str</span>
<span class="sd">            The coordinate axes over which the `tensor_field` spans. This should be a sequence of strings referring to</span>
<span class="sd">            the various coordinates of the underlying :attr:`~grids.base.GridBase.coordinate_system` of the grid.</span>
<span class="sd">            For each element in `field_axes`, `tensor_field`&#39;s `i`-th index should match the shape</span>
<span class="sd">            of the grid for that coordinate. (See `Notes` for more details).</span>
<span class="sd">        out : array-like, optional</span>
<span class="sd">            An optional buffer in which to store the result.</span>
<span class="sd">            This can be used to reduce memory usage when performing</span>
<span class="sd">            computations. The shape of `out` must be compliant</span>
<span class="sd">            with broadcasting rules (see `Notes`). `out` may be a buffer or any</span>
<span class="sd">            other array-like object.</span>
<span class="sd">        Lterm_field : array-like, optional</span>
<span class="sd">            The volume log-derivative field :math:`L^\nu = \frac{1}{\rho} \partial_\mu [g^{\mu\nu} \rho]`.</span>
<span class="sd">            If not provided, it is computed automatically using the coordinate system. This argument can be filled to</span>
<span class="sd">            reduce numerical error and improve computational efficiency if it is known.</span>

<span class="sd">            If specified, `Lterm_field` must be shape compliant (see Notes).</span>
<span class="sd">        inverse_metric_field : array-like, optional</span>
<span class="sd">            A buffer containing the inverse metric field :math:`g^{\mu\nu}`. `inverse_metric_field`</span>
<span class="sd">            can be provided to improve computation speed (by avoiding computing it in stride);</span>
<span class="sd">            however, it is not required.</span>

<span class="sd">            The inverse metric can be derived from the coordinate system when this</span>
<span class="sd">            argument is not provided. See `Notes` below</span>
<span class="sd">            for details on the shape of `inverse_metric_field`.</span>
<span class="sd">        derivative_field : array-like, optional</span>
<span class="sd">            A buffer containing the first derivatives of the field. Can be provided to improve</span>
<span class="sd">            computation speed (by avoiding computing it in stride); however, it is not required.</span>

<span class="sd">            If specified, `derivative_field` must be shape compliant (see Notes).</span>
<span class="sd">        second_derivative_field : array-like, optional</span>
<span class="sd">            A buffer containing the second derivatives of the field. Can be provided to improve</span>
<span class="sd">            computation speed (by avoiding computing it in stride); however, it is not required.</span>

<span class="sd">            If specified, `second_derivative_field` must be shape compliant (see Notes).</span>
<span class="sd">        output_axes : list of str, optional</span>
<span class="sd">            The axes of the coordinate system over which the result should</span>
<span class="sd">            span. By default, `output_axes` is the same as `field_axes` and</span>
<span class="sd">            the output field matches the span of the input field.</span>

<span class="sd">            This argument may be specified to expand the number of axes onto which</span>
<span class="sd">            the output field is computed. `output_axes` must be a superset of the</span>
<span class="sd">            `field_axes`.</span>
<span class="sd">        in_chunks : bool, optional</span>
<span class="sd">            Whether to perform the computation in chunks. This can help reduce memory usage during the operation but</span>
<span class="sd">            will increase runtime due to increased computational load. If input buffers are all fully-loaded into memory,</span>
<span class="sd">            chunked performance will only marginally improve; however, if buffers are lazy loaded, then chunked operations</span>
<span class="sd">            will significantly improve efficiency. Defaults to ``False``.</span>
<span class="sd">        edge_order : {1, 2}, optional</span>
<span class="sd">            Order of the finite difference scheme to use when computing derivatives. See :func:`numpy.gradient` for more</span>
<span class="sd">            details on this argument. Defaults to ``2``.</span>
<span class="sd">        pbar : bool, optional</span>
<span class="sd">            Whether to display a progress bar when `in_chunks=True`.</span>
<span class="sd">        pbar_kwargs : dict, optional</span>
<span class="sd">            Additional keyword arguments passed to the progress bar utility. These can be any valid arguments</span>
<span class="sd">            to :func:`tqdm.tqdm`.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments passed to :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_full` or</span>
<span class="sd">            :func:`~differential_geometry.dense_ops.dense_scalar_laplacian_diag`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array-like</span>
<span class="sd">            The computed partial derivatives. The resulting array will have a field shape matching the grid&#39;s</span>
<span class="sd">            shape over the `output_axes` and an element shape matching that of `field` but with an additional `(ndim,)`</span>
<span class="sd">            sized dimension containing each of the partial derivatives for each index.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Shape and Broadcasting Requirements**</span>

<span class="sd">        The spatial dimensions of `field` must match the grid shape exactly over the `field_axes`.</span>
<span class="sd">        For a scalar field on a grid with shape ``(G1, ..., Gm)``, and `field_axes = [&#39;x&#39;, &#39;z&#39;]`,</span>
<span class="sd">        the field must have shape ``(Gₓ, G_z)``. For tensor fields, additional trailing dimensions</span>
<span class="sd">        (beyond the spatial ones) are interpreted as tensor indices and must either match `ndim` exactly</span>
<span class="sd">        or be nested in a form that makes the Laplacian contractable (i.e., act elementwise).</span>

<span class="sd">        The output shape will match the shape of `tensor_field` unless `output_axes` introduces</span>
<span class="sd">        additional broadcasting (e.g., singleton axes added by `broadcast_array_to_axes`).</span>

<span class="sd">        **Lterm and Inverse Metric**</span>

<span class="sd">        The Laplacian operator requires knowledge of both the inverse metric and the volume derivative term (Lterm).</span>
<span class="sd">        These are automatically computed from the coordinate system unless explicitly provided.</span>
<span class="sd">        If supplied manually:</span>

<span class="sd">        - `Lterm_field` must have shape ``(..., ndim)``</span>
<span class="sd">        - `inverse_metric_field` must be either ``(..., ndim)`` (diagonal) or ``(..., ndim, ndim)`` (full)</span>

<span class="sd">        Additionally, the derivative fields may be supplied. In that case,</span>

<span class="sd">        - `derivative_field` must have shape ``(..., ndim)``</span>
<span class="sd">        - `second_derivative_field` must have shape ``(..., ndim)`` if the metric is diagonal and</span>
<span class="sd">          ``(..., ndim, ndim)`` if it is full.</span>

<span class="sd">        **Chunked Execution**</span>

<span class="sd">        When `in_chunks=True`, the Laplacian is computed in small memory-efficient blocks with</span>
<span class="sd">        halo padding of 1 cell. This is especially useful when `tensor_field` and `out` are backed</span>
<span class="sd">        by HDF5 or other lazy-loading array backends. Chunking requires the grid to support</span>
<span class="sd">        `iter_chunk_slices(...)`.</span>

<span class="sd">        **When to Use This**</span>

<span class="sd">        This method is suitable for computing the Laplace–Beltrami operator in arbitrary curvilinear</span>
<span class="sd">        coordinate systems. It generalizes to higher-rank tensors when `tensor_field` contains dense</span>
<span class="sd">        component axes. For fields with symbolic or sparse component structure, see symbolic APIs.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dense_element_wise_partial_derivatives: Generic form for general array-valued fields.</span>
<span class="sd">        dense_covariant_gradient: Covariant gradient of a tensor field.</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_gradient_contravariant_full: Low-level callable version (full metric)</span>
<span class="sd">        ~differential_geometry.dense_ops.dense_gradient_contravariant_diag: Low-level callable version (diag metric)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dense_element_wise_laplacian</span><span class="p">(</span>
            <span class="n">field</span><span class="p">,</span>
            <span class="n">field_axes</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">Lterm_field</span><span class="o">=</span><span class="n">Lterm_field</span><span class="p">,</span>
            <span class="n">inverse_metric_field</span><span class="o">=</span><span class="n">inverse_metric_field</span><span class="p">,</span>
            <span class="n">derivative_field</span><span class="o">=</span><span class="n">derivative_field</span><span class="p">,</span>
            <span class="n">second_derivative_field</span><span class="o">=</span><span class="n">second_derivative_field</span><span class="p">,</span>
            <span class="n">in_chunks</span><span class="o">=</span><span class="n">in_chunks</span><span class="p">,</span>
            <span class="n">edge_order</span><span class="o">=</span><span class="n">edge_order</span><span class="p">,</span>
            <span class="n">output_axes</span><span class="o">=</span><span class="n">output_axes</span><span class="p">,</span>
            <span class="n">pbar</span><span class="o">=</span><span class="n">pbar</span><span class="p">,</span>
            <span class="n">pbar_kwargs</span><span class="o">=</span><span class="n">pbar_kwargs</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, Eliza Diggins.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>